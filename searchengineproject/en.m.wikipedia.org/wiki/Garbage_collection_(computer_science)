<!doctype html>
	<html lang="en" dir="ltr" class="">
	<head>
		<title>Garbage collection (computer science) - Wikipedia, the free encyclopedia</title>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<meta name="robots" content="noindex,nofollow"/>		<link rel="stylesheet" href="http://bits.wikimedia.org/en.wikipedia.org/load.php?debug=false&amp;lang=en&amp;modules=mobile%7Cmobile.production-only%2Cproduction-jquery%7Cmobile.device.default&amp;only=styles&amp;skin=mobile&amp;version=1352163471&amp;*" />
<link rel="stylesheet" href="http://bits.wikimedia.org/en.wikipedia.org/load.php?debug=false&amp;lang=en&amp;modules=mobile.site&amp;only=styles&amp;skin=mobile&amp;*" />		<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png" />		<script type="text/javascript">
			var _mwStart = +new Date;
			window._evq = window._evq || [];
			if ( typeof console === 'undefined' ) {
				console = { log: function() {} };
			}
			if( typeof mw === 'undefined' ) {
				mw = {};
			}
			var mwMobileFrontendConfig = {"messages":{"mobile-frontend-watchlist-add":"Added $1 to your watchlist","mobile-frontend-watchlist-removed":"Removed $1 from your watchlist","mobile-frontend-watchlist-view":"View your watchlist","mobile-frontend-ajax-random-heading":"Locating knowledge...","mobile-frontend-ajax-random-quote":"Intellectual growth should commence at birth and cease only at death","mobile-frontend-ajax-random-quote-author":"Albert Einstein","mobile-frontend-ajax-random-question":"Read this article?","mobile-frontend-ajax-random-yes":"Yes","mobile-frontend-ajax-random-retry":"Try again","mobile-frontend-ajax-page-loading":"Loading $1","mobile-frontend-page-saving":"Saving $1","mobile-frontend-ajax-page-error":"Whoops! Something went wrong there. Please try refreshing your browser window.","mobile-frontend-meta-data-issues":"This article has some issues","mobile-frontend-meta-data-issues-header":"Issues","expand-section":"Show","collapse-section":"Hide","remove-results":"Back...","mobile-frontend-search-noresults":"No article titles match your search. Change your search, or press the keyboard search button to search inside articles.","mobile-frontend-search-help":"Type search term above and matching article titles will appear here.","contents-heading":"Contents","language-heading":"Read this article in","mobile-frontend-close-section":"Close this section","mobile-frontend-language-footer":"<a href="http://en.m.wikipedia.org/wiki/\&quot;\/wiki\/Special:MobileOptions\/Language\&quot;">Note: This article may not be written in your preferred language. You can see which languages Wikipedia supports by clicking here.<\/a>","mobile-frontend-language-site-choose":"Search language","mobile-frontend-language-site-nomatches":"No matching languages"},"settings":{"action":"","authenticated":false,"scriptPath":"\/w","shim":"\/\/bits.wikimedia.org\/static-1.21wmf3\/extensions\/MobileFrontend\/stylesheets\/common\/images\/blank.gif","pageUrl":"\/wiki\/$1","beta":null,"title":"Garbage collection (computer science)","useFormatCookieName":"mf_mobileFormat","useFormatCookieDuration":-1,"useFormatCookieDomain":"en.wikipedia.org","useFormatCookiePath":"\/","stopMobileRedirectCookieName":"stopMobileRedirect","stopMobileRedirectCookieDuration":15552000,"stopMobileRedirectCookieDomain":".wikipedia.org","hookOptions":""}};
			function _mwLogEvent( data, additionalInformation ) {
				var timestamp = + new Date;
				var ev = { event_id: 'mobile', delta: timestamp - _mwStart, data: data, beta: mwMobileFrontendConfig.settings.beta,
					session: _mwStart, page: mwMobileFrontendConfig.settings.title, info: additionalInformation || '' };
				_evq.push( ev );
				console.log( typeof JSON === 'undefined' ? ev : JSON.stringify( ev ) );
			}
		</script>
				<link rel="canonical" href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" >
	</head>
	<body class="mobile live">
				<div id="mw-mf-viewport">
		<div id="mw-mf-page-left">
		<div id='mw-mf-content-left'>
		<ul id="mw-mf-menu-main">
			<li class='icon'><a href="Main_Page"
				title="Home">
				Home</a></li>
			<li class='icon2'><a href="Special:Random#mw-mf-page-left" id="randomButton"
				title="Random"
				class="button">Random</a></li>
						<li class='icon5'>
				<a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileOptions&amp;returnto=Garbage+collection+%28computer+science%29"
					title="Settings">
				Settings				</a>
			</li>
					</ul>
		</div>
		</div>
		<div id='mw-mf-page-center'>
									<div id="mw-mf-header">
		<a title="Open main menu" href="Special:MobileMenu#mw-mf-page-left" id="mw-mf-main-menu-button">				<img alt="menu"
				src="http://bits.wikimedia.org/static-1.21wmf3/extensions/MobileFrontend/stylesheets/common/images/blank.gif">
		</a>			<form id="mw-mf-searchForm" action="http://en.m.wikipedia.org/w/index.php" class="search_bar" method="get">
			<input type="hidden" value="Special:Search" name="title" />
			<div id="mw-mf-sq" class="divclearable">
				<input type="search" name="search" id="mw-mf-search" size="22" value="" autocomplete="off" maxlength="1024" class="search"
					placeholder="Search Wikipedia"
					/>
				<img src="http://bits.wikimedia.org/static-1.21wmf3/extensions/MobileFrontend/stylesheets/common/images/blank.gif" alt="Clear" class="clearlink" id="mw-mf-clearsearch" title="Clear"/>
				<input class='searchSubmit' type="submit" value="Go">
			</div>
		</form>
	</div>
	<div id="results"></div>
		<div class='show ' id='content_wrapper'>
						<h1 id="firstHeading">Garbage collection (computer science)</h1>			
<div class="dablink">This article is about garbage collection in memory management.  For garbage collection in an SSD, see <a href="http://en.m.wikipedia.org/wiki/Garbage_collection_(SSD)" title="Garbage collection (SSD)" class="mw-redirect">Garbage collection (SSD)</a>.</div>
<table class="metadata plainlinks ambox ambox-content ambox-Original_research" style=""><tr>
<td class="mbox-image">
<div style="width: 52px;"><img alt="" src="http://upload.wikimedia.org/wikipedia/en/f/f4/Ambox_content.png" width="40" height="40"></div>
</td>
<td class="mbox-text" style=""><span class="mbox-text-span">This article <b>may contain <a href="http://en.m.wikipedia.org/wiki/Wikipedia:No_original_research" title="Wikipedia:No original research">original research</a></b>. <span class="hide-when-compact">Please <a class="external text" href="http://en.wikipedia.org/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit">improve it</a> by <a href="Wikipedia:Verifiability" title="Wikipedia:Verifiability">verifying</a> the claims made and adding <a href="http://en.m.wikipedia.org/wiki/Wikipedia:References" title="Wikipedia:References" class="mw-redirect">references</a>. Statements consisting only of original research may be removed.</span> <small><i>(October 2012)</i></small> </span></td>
</tr></table>
<table class="metadata plainlinks ambox ambox-content ambox-Refimprove" style=""><tr>
<td class="mbox-image">
<div style="width: 52px;"><img alt="" src="http://upload.wikimedia.org/wikipedia/en/thumb/9/99/Question_book-new.svg/50px-Question_book-new.svg.png" width="50" height="39" srcset="//upload.wikimedia.org/wikipedia/en/thumb/9/99/Question_book-new.svg/75px-Question_book-new.svg.png 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/9/99/Question_book-new.svg/100px-Question_book-new.svg.png 2x"></div>
</td>
<td class="mbox-text" style=""><span class="mbox-text-span">This article <b>needs additional <a href="Wikipedia:Citing_sources#Inline_citations" title="Wikipedia:Citing sources">citations</a> for <a href="Wikipedia:Verifiability" title="Wikipedia:Verifiability">verification</a></b>. <span class="hide-when-compact">Please help <a class="external text" href="http://en.wikipedia.org/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit">improve this article</a> by adding citations to <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Identifying_reliable_sources" title="Wikipedia:Identifying reliable sources">reliable sources</a>. Unsourced material may be <a href="http://en.m.wikipedia.org/wiki/Template:Citation_needed" title="Template:Citation needed">challenged</a> and <a href="Wikipedia:Verifiability#Burden_of_evidence" title="Wikipedia:Verifiability">removed</a>.</span> <small><i>(July 2010)</i></small> </span></td>
</tr></table>
<table class="metadata plainlinks ambox ambox-style ambox-essay-like" style=""><tr>
<td class="mbox-image">
<div style="width: 52px;"><img alt="" src="http://upload.wikimedia.org/wikipedia/en/thumb/f/f2/Edit-clear.svg/40px-Edit-clear.svg.png" width="40" height="40" srcset="//upload.wikimedia.org/wikipedia/en/thumb/f/f2/Edit-clear.svg/60px-Edit-clear.svg.png 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/f/f2/Edit-clear.svg/80px-Edit-clear.svg.png 2x"></div>
</td>
<td class="mbox-text" style=""><span class="mbox-text-span">This article <b>is written like a <a href="http://en.m.wikipedia.org/wiki/Wikipedia:What_Wikipedia_is_not#PUBLISHER" title="Wikipedia:What Wikipedia is not">personal reflection or essay</a> rather than an encyclopedic description of the subject</b>. <span class="hide-when-compact">Please <a class="external text" href="http://en.wikipedia.org/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit">help improve it</a> by rewriting it in an <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Encyclopedic_style" title="Wikipedia:Encyclopedic style" class="mw-redirect">encyclopedic style</a>.</span> <small><i>(July 2010)</i></small> </span></td>
</tr></table>
<p>In <a href="http://en.m.wikipedia.org/wiki/Computer_science" title="Computer science">computer science</a>, <b>garbage collection</b> (<b>GC</b>) is a form of automatic <a href="http://en.m.wikipedia.org/wiki/Memory_management" title="Memory management">memory management</a>. The <i>garbage collector</i>, or just <i>collector</i>, attempts to reclaim <i><a href="http://en.m.wikipedia.org/wiki/Garbage_(computer_science)" title="Garbage (computer science)">garbage</a></i>, or memory occupied by <a href="http://en.m.wikipedia.org/wiki/Object_(computer_science)" title="Object (computer science)">objects</a> that are no longer in use by the <a href="http://en.m.wikipedia.org/wiki/Application_software" title="Application software">program</a>. Garbage collection was invented by <a href="http://en.m.wikipedia.org/wiki/John_McCarthy_(computer_scientist)" title="John McCarthy (computer scientist)">John McCarthy</a> around 1959 to solve problems in <a href="http://en.m.wikipedia.org/wiki/Lisp_(programming_language)" title="Lisp (programming language)">Lisp</a>.<sup id="cite_ref-1" class="reference"><a href="Garbage_collection_(computer_science)#cite_note-1"><span>[</span>1<span>]</span></a></sup><sup id="cite_ref-2" class="reference"><a href="Garbage_collection_(computer_science)#cite_note-2"><span>[</span>2<span>]</span></a></sup></p>
<p>Garbage collection is often portrayed as the opposite of <a href="http://en.m.wikipedia.org/wiki/Manual_memory_management" title="Manual memory management">manual memory management</a>, which requires the programmer to specify which objects to deallocate and return to the memory system. However, many systems use a combination of approaches, including other techniques such as <a href="http://en.m.wikipedia.org/wiki/Stack-based_memory_allocation" title="Stack-based memory allocation">stack allocation</a> and <a href="http://en.m.wikipedia.org/wiki/Region_inference" title="Region inference" class="mw-redirect">region inference</a>.</p>
<p>Resources other than memory, such as <a href="http://en.m.wikipedia.org/wiki/Network_socket" title="Network socket">network sockets</a>, database <a href="http://en.m.wikipedia.org/wiki/Handle_(computing)" title="Handle (computing)">handles</a>, user interaction windows, and file and device descriptors, are not typically handled by garbage collection. Methods used to manage such resources, particularly <a href="http://en.m.wikipedia.org/wiki/Destructor_(computer_science)" title="Destructor (computer science)" class="mw-redirect">destructors</a>, may suffice to manage memory as well, leaving no need for GC. Some GC systems allow such other resources to be associated with a region of memory that, when collected, causes the other resource to be reclaimed; this is called <a href="http://en.m.wikipedia.org/wiki/Finalizer" title="Finalizer"><i>finalization</i></a>. Finalization may introduce complications limiting its usability, such as intolerable latency between disuse and reclaim of especially limited resources, or a lack of control over which thread performs the work of reclaiming.</p>
<h2> <span class="mw-headline" id="Principles">Principles</span>
</h2>
<p>The basic principles of garbage collection are:</p>
<ol>
<li>Find data objects in a program that cannot be accessed in the future</li>
<li>Reclaim the resources used by those objects</li>
</ol>
<p>Many <a href="Programming_language" title="Programming language">computer languages</a> require garbage collection, either as part of the <a href="http://en.m.wikipedia.org/wiki/Language_specification" title="Language specification" class="mw-redirect">language specification</a> (e.g., <a href="Java_(programming_language)" title="Java (programming language)">Java</a>, <a href="C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a>, and most <a href="http://en.m.wikipedia.org/wiki/Scripting_language" title="Scripting language">scripting languages</a>) or effectively for practical implementation (e.g., formal languages like <a href="http://en.m.wikipedia.org/wiki/Lambda_calculus" title="Lambda calculus">lambda calculus</a>); these are said to be <b>garbage collected languages</b>. Other languages were designed for use with manual memory management, but have garbage collected implementations available (e.g., <a href="http://en.m.wikipedia.org/wiki/C_(programming_language)" title="C (programming language)">C</a>, <a href="C++" title="C++">C++</a>). Some languages, like <a href="http://en.m.wikipedia.org/wiki/Ada_(programming_language)" title="Ada (programming language)">Ada</a>, <a href="http://en.m.wikipedia.org/wiki/Modula-3" title="Modula-3">Modula-3</a>, and <a href="C++/CLI" title="C++/CLI">C++/CLI</a> allow both garbage collection and <a href="http://en.m.wikipedia.org/wiki/Manual_memory_management" title="Manual memory management">manual memory management</a> to co-exist in the same application by using separate <a href="http://en.m.wikipedia.org/wiki/Heap_(data_structure)" title="Heap (data structure)">heaps</a> for collected and manually managed objects; others, like <a href="D_(programming_language)" title="D (programming language)">D</a>, are garbage collected but allow the user to manually delete objects and also entirely disable garbage collection when speed is required. While integrating garbage collection into the language's <a href="Compiler" title="Compiler">compiler</a> and <a href="http://en.m.wikipedia.org/wiki/Run_time_system" title="Run time system" class="mw-redirect">runtime</a> system enables a much wider choice of methods,<sup class="Template-Fact" style="white-space:nowrap;">[<i><a href="http://en.m.wikipedia.org/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources from June 2007">citation needed</span></a></i>]</sup><i>post hoc</i> GC systems exist, including some that do not require recompilation. (<i>Post-hoc</i> GC is sometimes distinguished as <i>litter collection</i>.) The garbage collector will almost always be closely integrated with the <a href="Dynamic_memory_allocation" title="Dynamic memory allocation" class="mw-redirect">memory allocator</a>.</p>
<h3> <span class="mw-headline" id="Benefits">Benefits</span>
</h3>
<p>Garbage collection frees the programmer from manually dealing with memory deallocation. As a result, certain categories of bugs are eliminated or substantially reduced:</p>
<ul>
<li>
<b><a href="Dangling_pointer" title="Dangling pointer">Dangling pointer</a> bugs</b>, which occur when a piece of memory is freed while there are still pointers to it, and one of those pointers is dereferenced. By then the memory may have been re-assigned to another use, with unpredictable results.</li>
<li>
<b>Double free bugs</b>, which occur when the program tries to free a region of memory that has already been freed, and perhaps already been allocated again.</li>
<li>Certain kinds of <b><a href="Memory_leak" title="Memory leak">memory leaks</a></b>, in which a program fails to free memory occupied by objects that have actually become <a href="http://en.m.wikipedia.org/wiki/Unreachable" title="Unreachable" class="mw-redirect">unreachable</a>, which leads to memory exhaustion if such a behavior is repeated many times enough. (Garbage collection typically does not deal with the unbounded accumulation of data which is reachable, but which will actually not be used by the program.)</li>
</ul>
<p>Some of the bugs addressed by garbage collection can have security implications.</p>
<h3> <span class="mw-headline" id="Disadvantages">Disadvantages</span>
</h3>
<p>Typically, garbage collection has certain disadvantages:</p>
<ul>
<li>Garbage collection consumes computing resources in deciding which memory to free, even though the programmer may have already known this information. The penalty for the convenience of not annotating object lifetime manually in the source code is <a href="http://en.m.wikipedia.org/wiki/Computational_overhead" title="Computational overhead" class="mw-redirect">overhead</a>, which can lead to decreased or uneven performance. Interaction with memory hierarchy effects can make this overhead intolerable in circumstances that are hard to predict or to detect in routine testing.</li>
<li>The moment when the garbage is actually collected can be unpredictable, resulting in stalls scattered throughout a session. Unpredictable stalls can be unacceptable in <a href="http://en.m.wikipedia.org/wiki/Real-time_computing" title="Real-time computing">real-time environments</a>, in <a href="http://en.m.wikipedia.org/wiki/Transaction_processing" title="Transaction processing">transaction processing</a>, or in interactive programs. Incremental, concurrent, and real-time garbage collectors address these problems, with varying trade-offs.</li>
<li>Non-deterministic GC is incompatible with <a href="http://en.m.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization" title="Resource Acquisition Is Initialization">RAII</a> based management of non GCed resources. As a result, the need for explicit manual resource management (release/close) for non-GCed resources becomes transitive to composition. That is: in a non-deterministic GC system, if a resource or a resource like object requires manual resource management (release/close), and this object is used as 'part of' another object, then the composed object will also become a resource like object that itself requires manual resource management (release/close).</li>
</ul>
<h2> <span class="mw-headline" id="Tracing_garbage_collectors">Tracing garbage collectors</span>
</h2>
<table class="metadata plainlinks ambox ambox-style ambox-Wikify" style=""><tr>
<td class="mbox-image">
<div style="width: 52px;"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/e/e1/Ambox_wikify.svg/40px-Ambox_wikify.svg.png" width="40" height="40" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/e/e1/Ambox_wikify.svg/60px-Ambox_wikify.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/e/e1/Ambox_wikify.svg/80px-Ambox_wikify.svg.png 2x"></div>
</td>
<td class="mbox-text" style="">
<span class="mbox-text-span">This article <b>may need to be <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Glossary#Wikify" title="Wikipedia:Glossary">wikified</a> to meet Wikipedia's <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Manual_of_Style" title="Wikipedia:Manual of Style">quality standards</a></b>. <span class="hide-when-compact">Please <a class="external text" href="http://en.wikipedia.org/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit">help</a> by adding <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Linking" title="Wikipedia:Linking" class="mw-redirect"><i>relevant</i> internal links</a>, or by improving the article's <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Layout" title="Wikipedia:Layout" class="mw-redirect">layout</a>.</span> <small><i>(August 2012)</i></small></span>
<div class="NavFrame collapsed hide-when-compact" style="border:none;">
<div class="NavHead" style="font-weight:bold; background:transparent; text-align:center; padding-right:3em; font-weight:normal; text-align:left;"><span class="hide-when-compact">Click [show] on right for more details.</span></div>
<div class="NavContent" style="font-weight:normal; background-color:transparent; text-align:left;">
<p><span class="hide-when-compact"><b>No reason has been cited for the Wikify tag on this article.<small>You can insert a reason using the <code>|<span style="white-space:nowrap;">reason</span>=</code> parameter, like this: <code><code>{{<a href="http://en.m.wikipedia.org/wiki/Template:Wikify" title="Template:Wikify">Wikify</a>|reason=Your reason here}}</code></code></small></b></span></p>
<ul>
<li><small>Please <b>replace <a href="http://en.m.wikipedia.org/wiki/HTML_element" title="HTML element">HTML markup</a> with <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Cheatsheet" title="Wikipedia:Cheatsheet">wiki markup</a></b> where appropriate.</small></li>
<li><small><b>Add wikilinks.</b> Where appropriate, make links to other articles by putting "[[" and "]]" on either side of relevant words (see <a href="http://en.m.wikipedia.org/wiki/Wikipedia:LINK" title="Wikipedia:LINK" class="mw-redirect">WP:LINK</a> for more information) and check that your links work as expected. Please do not link terms that most readers are familiar with, such as common occupations, well-known geographical terms, and everyday items.</small></li>
<li><small><b>Format the lead.</b> Create or improve the <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Manual_of_Style_(lead_section)" title="Wikipedia:Manual of Style (lead section)" class="mw-redirect">lead paragraph</a>.</small></li>
<li><small><b>Arrange section headers</b> as described at <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Guide_to_layout" title="Wikipedia:Guide to layout" class="mw-redirect">Wikipedia:Guide to layout</a>.</small></li>
<li><small><b>Add an <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Infobox_templates" title="Wikipedia:Infobox templates" class="mw-redirect">infobox</a></b> if it is appropriate for the article.</small></li>
<li><small><b>Clean up any <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Linkrot" title="Wikipedia:Linkrot" class="mw-redirect">linkrot</a> / format the <a href="Wikipedia:Citing_sources" title="Wikipedia:Citing sources">references</a> and <a href="http://en.m.wikipedia.org/wiki/Help:Footnotes" title="Help:Footnotes">footnotes</a></b>, using <a href="http://en.m.wikipedia.org/wiki/Wikipedia:Citation_templates" title="Wikipedia:Citation templates">citation templates</a> when appropriate.</small></li>
<li><small><b>Remove this tag.</b></small></li>
</ul>
</div>
</div>
</td>
</tr></table>
<p>Tracing garbage collectors are the most common type of garbage collector. They first determine which objects are <i>reachable</i> (or potentially reachable), and then discard all remaining objects.</p>
<h3> <span class="mw-headline" id="Reachability_of_an_object">Reachability of an object</span>
</h3>
<p>Informally, an object is reachable if it is referenced by at least one variable in the program, either directly or through references from other reachable objects. More precisely, objects can be reachable in only two ways:</p>
<ol>
<li>A distinguished set of objects are assumed to be reachable: these are known as the <i>roots.</i> Typically, these include all the objects referenced from anywhere in the <a href="Call_stack" title="Call stack">call stack</a> (that is, all <a href="http://en.m.wikipedia.org/wiki/Local_variable" title="Local variable">local variables</a> and <a href="Parameter_(computer_science)" title="Parameter (computer science)" class="mw-redirect">parameters</a> in the functions currently being invoked), and any <a href="http://en.m.wikipedia.org/wiki/Global_variable" title="Global variable">global variables</a>.</li>
<li>Anything referenced from a reachable object is itself reachable; more formally, reachability is a <a href="http://en.m.wikipedia.org/wiki/Transitive_closure" title="Transitive closure">transitive closure</a>.</li>
</ol>
<p>The reachability definition of "garbage" is not optimal, insofar as the last time a program uses an object could be long before that object falls out of the environment scope. A distinction is sometimes drawn between <i>syntactic garbage</i>, those objects the program cannot possibly reach, and <i>semantic garbage</i>, those objects the program will in fact never again use. For example:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="java source-java">
<pre class="de1">
<span class="kw3">Object</span> x <span class="sy0">=</span> <span class="kw1">new</span> Foo<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="kw3">Object</span> y <span class="sy0">=</span> <span class="kw1">new</span> Bar<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
x <span class="sy0">=</span> <span class="kw1">new</span> Quux<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="coMULTI">/* at this point, we know that the Foo object 
 * originally assigned to x will never be
 * accessed: it is syntactic garbage
 */</span>
 
<span class="kw1">if</span><span class="br0">(</span>x.<span class="me1">check_something</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
 x.<span class="me1">do_something</span><span class="br0">(</span>y<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw3">System</span>.<span class="me1">exit</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
<span class="coMULTI">/* in the above block, y *could* be semantic garbage,
 * but we won't know until x.check_something() returns
 * some value -- if it returns at all
 */</span>
</pre>
</div>
</div>
<p>The problem of precisely identifying semantic garbage can easily be shown to be <a href="http://en.m.wikipedia.org/wiki/Decision_problem" title="Decision problem">partially decidable</a>: a program that allocates an object <i>X</i>, runs an arbitrary input program <i>P</i>, and uses <i>X</i> if and only if <i>P</i> finishes would require a semantic garbage collector to solve the <a href="http://en.m.wikipedia.org/wiki/Halting_problem" title="Halting problem">halting problem</a>. Although conservative heuristic methods for semantic garbage detection remain an active research area, essentially all practical garbage collectors focus on syntactic garbage.<sup class="Template-Fact" style="white-space:nowrap;">[<i><a href="http://en.m.wikipedia.org/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources from September 2008">citation needed</span></a></i>]</sup></p>
<p>Another complication with this approach is that, in languages with both <a href="http://en.m.wikipedia.org/wiki/Reference_type" title="Reference type">reference types</a> and unboxed <a href="http://en.m.wikipedia.org/wiki/Value_type" title="Value type">value types</a>, the garbage collector needs to somehow be able to distinguish which variables on the stack or fields in an object are regular values and which are references: in memory, an integer and a reference might look alike. The garbage collector then needs to know whether to treat the element as a reference and follow it, or whether it is a primitive value. One common solution is the use of <a href="http://en.m.wikipedia.org/wiki/Tagged_pointer" title="Tagged pointer">tagged pointers</a>.</p>
<h3> <span class="mw-headline" id="Strong_and_Weak_references">Strong and Weak references</span>
</h3>
<p>The garbage collector can reclaim only objects that have no references pointing to them either directly or indirectly from the root set. However, some programs require <a href="http://en.m.wikipedia.org/wiki/Weak_reference" title="Weak reference">weak references</a>, which should be usable for as long as the object exists but should not prolong its lifetime. In discussions about weak references, ordinary references are sometimes called <a href="http://en.m.wikipedia.org/wiki/Strong_reference" title="Strong reference">strong references</a>. An object is eligible for garbage collection if there are no strong (i.e. ordinary) references to it, even though there still might be some weak references to it.</p>
<p>A weak reference is not merely just any pointer to the object that a garbage collector does not care about. The term is usually reserved for a properly managed category of special reference objects which are safe to use even after the object disappears because they <i>lapse</i> to a safe value. An unsafe reference that is not known to the garbage collector will simply remain dangling by continuing to refer to the address where the object previously resided. This is not a weak reference.</p>
<p>In some implementations, weak references are divided into subcategories. For example, the <a href="http://en.m.wikipedia.org/wiki/Java_Virtual_Machine" title="Java Virtual Machine" class="mw-redirect">Java Virtual Machine</a> provides three forms of weak references, namely <a href="http://en.m.wikipedia.org/wiki/Soft_reference" title="Soft reference">soft references</a> <sup id="cite_ref-3" class="reference"><a href="Garbage_collection_(computer_science)#cite_note-3"><span>[</span>3<span>]</span></a></sup>, <a href="http://en.m.wikipedia.org/wiki/Phantom_reference" title="Phantom reference">phantom references</a> <sup id="cite_ref-4" class="reference"><a href="Garbage_collection_(computer_science)#cite_note-4"><span>[</span>4<span>]</span></a></sup>, and regular weak references <sup id="cite_ref-5" class="reference"><a href="Garbage_collection_(computer_science)#cite_note-5"><span>[</span>5<span>]</span></a></sup>. A softly referenced object is only eligible for reclamation, if the garbage collector decides that the program is low on memory. Unlike a soft reference or a regular weak reference, a phantom reference does not provide access to the object that it references. Instead, a phantom reference is a mechanism that allows the garbage collector to notify the program when the referenced object has become <i>phantom reachable</i>. An object is phantom reachable, if it still resides in memory and it is referenced by a phantom reference, but its <a href="http://en.m.wikipedia.org/wiki/Finalizer" title="Finalizer">finalizer</a> has already executed. Similarly, <a href="http://en.m.wikipedia.org/wiki/.NET_Framework" title=".NET Framework">Microsoft.NET</a> provides two subcategories of weak references<sup id="cite_ref-6" class="reference"><a href="Garbage_collection_(computer_science)#cite_note-6"><span>[</span>6<span>]</span></a></sup>, namely long weak references (tracks resurrection) and short weak references.</p>
<h3> <span class="mw-headline" id="Weak_Collections">Weak Collections</span>
</h3>
<p><a href="http://en.m.wikipedia.org/wiki/Data_structure" title="Data structure">Data structures</a> can also be devised which have weak tracking features. For instance, weak <a href="http://en.m.wikipedia.org/wiki/Hash_table" title="Hash table">hash tables</a> are useful. Like a regular hash table, a weak hash table maintains an association between pairs of objects, where each pair is understood to be a key and value. However, the hash table does not actually maintain a strong reference on these objects. A special behavior takes place when either the key or value or both become garbage: the hash table entry is spontaneously deleted. There exist further refinements such as hash tables which have only weak keys (value references are ordinary, strong references) or only weak values (key references are strong).</p>
<p>Weak hash tables are important for maintaining associations between objects, such that the objects engaged in the association can still become garbage if nothing in the program refers to them any longer (other than the associating hash table).</p>
<p>The use of a regular hash table for such a purpose could lead to a "<a href="http://en.m.wikipedia.org/wiki/Logical_memory" title="Logical memory" class="mw-redirect">logical memory</a> leak": the accumulation of reachable data which the program does not need and will not use.</p>
<h3> <span class="mw-headline" id="Basic_algorithm">Basic algorithm</span>
</h3>
<p>Tracing collectors are so called because they trace through the working set of memory. These garbage collectors perform collection in cycles. A cycle is started when the collector decides (or is notified) that it needs to reclaim memory, which happens most often when the system is low on memory<sup class="Template-Fact" style="white-space:nowrap;">[<i><a href="http://en.m.wikipedia.org/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources from June 2011">citation needed</span></a></i>]</sup>. The original method involves a naïve <b>mark-and-sweep</b> in which the entire memory set is touched several times.</p>
<h4> <span class="mw-headline" id="Na.C3.AFve_mark-and-sweep">Naïve mark-and-sweep</span>
</h4>
<div class="thumb tright">
<div class="thumbinner" style="width:222px;">
<a href="http://en.m.wikipedia.org/wiki/File:Animation_of_the_Naive_Mark_and_Sweep_Garbage_Collector_Algorithm.gif" class="image"><img alt="caption" src="http://upload.wikimedia.org/wikipedia/en/thumb/4/4a/Animation_of_the_Naive_Mark_and_Sweep_Garbage_Collector_Algorithm.gif/220px-Animation_of_the_Naive_Mark_and_Sweep_Garbage_Collector_Algorithm.gif" width="220" height="168" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/en/thumb/4/4a/Animation_of_the_Naive_Mark_and_Sweep_Garbage_Collector_Algorithm.gif/330px-Animation_of_the_Naive_Mark_and_Sweep_Garbage_Collector_Algorithm.gif 1.5x, //upload.wikimedia.org/wikipedia/en/4/4a/Animation_of_the_Naive_Mark_and_Sweep_Garbage_Collector_Algorithm.gif 2x"></a>
<div class="thumbcaption">

Naive Mark and Sweep in action on a <a href="Dynamic_memory_allocation#Dynamic_memory_allocation" title="Dynamic memory allocation" class="mw-redirect">heap</a> containing eight <a href="http://en.m.wikipedia.org/wiki/Object_(computer_science)" title="Object (computer science)">objects</a>. Arrows represent <a href="Reference_(computer_science)#References_in_object_oriented_languages" title="Reference (computer science)">object references</a>. Circles represent the objects themselves. Objects #1, #2, #3, #4, and #6 are strongly referenced from the root set. On the other hand, objects #5, #7, and #8 are not strongly referenced either directly or indirectly from the root set; therefore, they are garbage.</div>
</div>
</div>
<p>In the naive mark-and-sweep method, each object in memory has a flag (typically a single bit) reserved for garbage collection use only. This flag is always <i>cleared</i>, except during the collection cycle. The first stage of collection does a tree traversal of the entire 'root set', marking each object that is pointed to as being 'in-use'. All objects that those objects point to, and so on, are marked as well, so that every object that is ultimately pointed to from the root set is marked. Finally, all memory is scanned from start to finish, examining all free or used blocks; those with the in-use flag still cleared are not reachable by any program or data, and their memory is freed. (For objects which are marked in-use, the in-use flag is cleared again, preparing for the next cycle.)</p>
<p>This method has several disadvantages, the most notable being that the entire system must be suspended during collection; no mutation of the working set can be allowed. This will cause programs to 'freeze' periodically (and generally unpredictably), making real-time and time-critical applications impossible. In addition, the entire working memory must be examined, much of it twice, potentially causing problems in <a href="http://en.m.wikipedia.org/wiki/Paged_memory" title="Paged memory" class="mw-redirect">paged memory</a> systems.</p>
<h4> <span class="mw-headline" id="Tri-color_marking">Tri-color marking</span>
</h4>
<p>Because of these pitfalls, most modern tracing garbage collectors implement some variant of the <i>tri-colour marking</i> <a href="http://en.m.wikipedia.org/wiki/Abstraction_(computer_science)" title="Abstraction (computer science)">abstraction</a>, but simple collectors (such as the <i>mark-and-sweep</i> collector) often do not make this abstraction explicit. Tri-colour marking works as follows:</p>
<ol>
<li>Create initial white, grey, and black sets; these sets will be used to maintain progress during the cycle.
<ul>
<li>Initially the white set or <i>condemned set</i> is the set of objects that are candidates for having their memory recycled.</li>
<li>The black set is the set of objects that can cheaply be proven to have no references to objects in the white set, but are also not chosen to be candidates for recycling; in many implementations, the black set starts off empty.</li>
<li>The grey set is all the objects that are reachable from root references but the objects referenced by grey objects haven't been scanned yet. Grey objects are known to be reachable from the root, so cannot be garbage collected: grey objects will eventually end up in the black set. The grey state means we still need to check any objects that the object references.</li>
<li>The grey set is initialised to objects which are referenced directly at root level; typically all other objects are initially placed in the white set.</li>
<li>Objects can move from white to grey to black, never in the other direction.</li>
</ul>
</li>
<li>Pick an object from the grey set. <i>Blacken</i> this object (move it to the black set), by <i>greying</i> all the white objects it references directly. This confirms that this object cannot be garbage collected, and also that any objects it references cannot be garbage collected.</li>
<li>Repeat the previous step until the grey set is empty.</li>
<li>When there are no more objects in the grey set, then all the objects remaining in the white set have been demonstrated not to be reachable, and the storage occupied by them can be reclaimed.</li>
</ol>
<p>The 3 sets <a href="http://en.m.wikipedia.org/wiki/Partition_of_a_set" title="Partition of a set">partition</a> memory; every object in the system, including the root set, is in precisely one set.</p>
<p>The tri-colour marking algorithm preserves an important invariant:</p>
<dl>
<dd>No black object points directly to a white object.</dd>
</dl>
<p>This ensures that the white objects can be safely destroyed once the grey set is empty. (Some variations on the algorithm do not preserve the tricolour invariant but they use a modified form for which all the important properties hold.)</p>
<p>The tri-colour method has an important advantage: it can be performed 'on-the-fly', without halting the system for significant time periods. This is accomplished by marking objects as they are allocated and during mutation, maintaining the various sets. By monitoring the size of the sets, the system can perform garbage collection periodically, rather than as-needed. Also, the need to touch the entire working set each cycle is avoided.</p>
<h3> <span class="mw-headline" id="Implementation_strategies">Implementation strategies</span>
</h3>
<p>In order to implement the basic tri-colour algorithm, several important design decisions must be made, which can significantly affect the performance characteristics of the garbage collector.</p>
<h4> <span class="mw-headline" id="Moving_vs._non-moving">Moving vs. non-moving</span>
</h4>
<p>Once the unreachable set has been determined, the garbage collector may simply release the <a href="http://en.m.wikipedia.org/wiki/Unreachable_object" title="Unreachable object" class="mw-redirect">unreachable objects</a> and leave everything else as it is, or it may copy some or all of the reachable objects into a new area of memory, updating all references to those objects as needed. These are called "non-moving" and "moving" (or, alternatively, "non-compacting" and "compacting") garbage collectors, respectively.</p>
<p>At first, a moving GC strategy may seem inefficient and costly compared to the non-moving approach, since much more work would appear to be required on each cycle. In fact, however, the moving GC strategy leads to several performance advantages, both during the garbage collection cycle itself and during actual program execution:</p>
<ul>
<li>No additional work is required to reclaim the space freed by dead objects; the entire region of memory from which reachable objects were moved can be considered free space. In contrast, a non-moving GC must visit each unreachable object and somehow record that the memory it alone occupied is available.</li>
<li>Similarly, new objects can be allocated very quickly. Since large contiguous regions of memory are usually made available by the moving GC strategy, new objects can be allocated by simply incrementing a 'free memory' pointer. A non-moving strategy may, after some time, lead to a heavily <a href="http://en.m.wikipedia.org/wiki/Fragmentation_(computer)" title="Fragmentation (computer)" class="mw-redirect">fragmented</a> heap, requiring expensive consultation of "free lists" of small available blocks of memory in order to allocate new objects.</li>
<li>If an appropriate traversal order is used (such as cdr-first for list <a href="http://en.m.wikipedia.org/wiki/Cons" title="Cons">conses</a>), objects that refer to each other frequently can be moved very close to each other in memory, increasing the likelihood that they will be located in the same <a href="http://en.m.wikipedia.org/wiki/Cache_line" title="Cache line" class="mw-redirect">cache line</a> or <a href="http://en.m.wikipedia.org/wiki/Virtual_memory" title="Virtual memory">virtual memory</a> page. This can significantly speed up access to these objects through these references.</li>
</ul>
<p>One disadvantage of a moving garbage collector is that it only allows access through references that are managed by the garbage collected environment, and does not allow <a href="Pointer_arithmetic" title="Pointer arithmetic" class="mw-redirect">pointer arithmetic</a>. This is because any native pointers to objects will be invalidated when the garbage collector moves the object (they become <a href="Dangling_pointer" title="Dangling pointer">dangling pointers</a>). For <a href="http://en.m.wikipedia.org/wiki/Interoperability" title="Interoperability">interoperability</a> with native code, the garbage collector must copy the object contents to a location outside of the garbage collected region of memory. An alternative approach is to <b>pin</b> the object in memory, preventing the garbage collector from moving it and allowing the memory to be directly shared with native pointers (and possibly allowing pointer arithmetic).<sup id="cite_ref-7" class="reference"><a href="Garbage_collection_(computer_science)#cite_note-7"><span>[</span>7<span>]</span></a></sup></p>
<h4> <span class="mw-headline" id="Copying_vs._mark-and-sweep_vs._mark-and-don.27t-sweep">Copying vs. mark-and-sweep vs. mark-and-don't-sweep</span>
</h4>
<p>To further refine the distinction, tracing collectors can also be divided by considering how the three sets of objects (white, grey, and black) are maintained during a collection cycle.</p>
<p>The most straightforward approach is the <b>semi-space collector</b>, which dates to 1969. In this moving GC scheme, memory is partitioned into a "from space" and "to space". Initially, objects are allocated into "to space" until they become full and a collection is triggered. At the start of a collection, the "to space" becomes the "from space", and vice versa. The objects reachable from the root set are copied from the "from space" to the "to space". These objects are scanned in turn, and all objects that they point to are copied into "to space", until all reachable objects have been copied into "to space". Once the program continues execution, new objects are once again allocated in the "to space" until it is once again full and the process is repeated. This approach has the advantage of conceptual simplicity (the three object color sets are implicitly constructed during the copying process), but the disadvantage that a (possibly) very large contiguous region of free memory is necessarily required on every collection cycle. This technique is also known as <b>stop-and-copy</b>. <a href="http://en.m.wikipedia.org/wiki/Cheney%27s_algorithm" title="Cheney's algorithm">Cheney's algorithm</a> is an improvement on the semi-space collector.</p>
<p>A <b>mark and sweep</b> garbage collector maintains a bit (or two) with each object to record whether it is white or black; the grey set is either maintained as a separate list (such as the process stack) or using another bit. As the reference tree is traversed during a collection cycle (the "mark" phase), these bits are manipulated by the collector to reflect the current state. A final "sweep" of the memory areas then frees white objects. The mark and sweep strategy has the advantage that, once the unreachable set is determined, either a moving or non-moving collection strategy can be pursued; this choice of strategy can even be made at runtime, as available memory permits. It has the disadvantage of "bloating" objects by a small amount.</p>
<p>A <b>mark and don't sweep</b> garbage collector, like the mark-and-sweep, maintains a bit with each object to record whether it is white or black; the gray set is either maintained as a separate list (such as the process stack) or using another bit. There are two key differences here. First, black and white mean different things than they do in the mark and sweep collector. In a "mark and don't sweep" system, all reachable objects are always black. An object is marked black at the time it is allocated, and it will stay black even if it becomes unreachable. A white object is unused memory and may be allocated. Second, the interpretation of the black/white bit can change. Initially, the black/white bit may have the sense of (0=white, 1=black). If an allocation operation ever fails to find any available (white) memory, that means all objects are marked used (black). The sense of the black/white bit is then inverted (for example, 0=black, 1=white). Everything becomes white. This momentarily breaks the invariant that reachable objects are black, but a full marking phase follows immediately, to mark them black again. Once this is done, all unreachable memory is white. No "sweep" phase is necessary.</p>
<h4> <span class="mw-headline" id="Generational_GC_.28ephemeral_GC.29">Generational GC (ephemeral GC)</span>
</h4>
<p>It has been empirically observed that in many programs, the most recently created objects are also those most likely to become unreachable quickly (known as <i>infant mortality</i> or the <i>generational hypothesis</i>). A generational GC (also known as ephemeral GC) divides objects into generations and, on most cycles, will place only the objects of a subset of generations into the initial white (condemned) set. Furthermore, the runtime system maintains knowledge of when references cross generations by observing the creation and overwriting of references. When the garbage collector runs, it may be able to use this knowledge to prove that some objects in the initial white set are unreachable without having to traverse the entire reference tree. If the generational hypothesis holds, this results in much faster collection cycles while still reclaiming most unreachable objects.</p>
<p>In order to implement this concept, many generational garbage collectors use separate memory regions for different ages of objects. When a region becomes full, those few objects that are referenced from older memory regions are promoted to the next highest region, and the entire region can then be overwritten with fresh objects. This technique permits very fast incremental garbage collection, since the garbage collection of only one region at a time is all that is typically required.</p>
<p>Generational garbage collection is a <a href="http://en.m.wikipedia.org/wiki/Heuristic_(computer_science)" title="Heuristic (computer science)">heuristic</a> approach, and some unreachable objects may not be reclaimed on each cycle. It may therefore occasionally be necessary to perform a full mark and sweep or copying garbage collection to reclaim all available space. In fact, runtime systems for modern programming languages (such as <a href="Java_(programming_language)" title="Java (programming language)">Java</a> and the <a href="http://en.m.wikipedia.org/wiki/.NET_Framework" title=".NET Framework">.NET Framework</a>) usually use some hybrid of the various strategies that have been described thus far; for example, most collection cycles might look only at a few generations, while occasionally a mark-and-sweep is performed, and even more rarely a full copying is performed to combat fragmentation. The terms "minor cycle" and "major cycle" are sometimes used to describe these different levels of collector aggression.</p>
<h4> <span class="mw-headline" id="Stop-the-world_vs._incremental_vs._concurrent">Stop-the-world vs. incremental vs. concurrent</span>
</h4>
<p>Simple <i>stop-the-world</i> garbage collectors completely halt execution of the program to run a collection cycle, thus guaranteeing that new objects are not allocated and objects do not suddenly become unreachable while the collector is running.</p>
<p>This has the obvious disadvantage that the program can perform no useful work while a collection cycle is running (sometimes called the "embarrassing pause"). Stop-the-world garbage collection is therefore mainly suitable for non-interactive programs. Its advantage is that it is both simpler to implement and faster than incremental garbage collection.</p>
<p><i>Incremental</i> and <i>concurrent</i> garbage collectors are designed to reduce this disruption by interleaving their work with activity from the main program. Incremental garbage collectors perform the garbage collection cycle in discrete phases, with program execution permitted between each phase (and sometimes during some phases). Concurrent garbage collectors do not stop program execution at all, except perhaps briefly when the program's execution stack is scanned. However, the sum of the incremental phases takes longer to complete than one batch garbage collection pass, so these garbage collectors may yield lower total throughput.</p>
<p>Careful design is necessary with these techniques to ensure that the main program does not interfere with the garbage collector and vice versa; for example, when the program needs to allocate a new object, the runtime system may either need to suspend it until the collection cycle is complete, or somehow notify the garbage collector that there exists a new, reachable object.</p>
<h4> <span class="mw-headline" id="Precise_vs._conservative_and_internal_pointers">Precise vs. conservative and internal pointers</span>
</h4>
<p>Some collectors can correctly identify all pointers (references) in an object; these are called <i>precise</i> (also <i>exact</i> or <i>accurate</i>) collectors, the opposite being a <i>conservative</i> or <i>partly conservative</i> collector. Conservative collectors assume that any bit pattern in memory could be a pointer if, interpreted as a pointer, it would point into an allocated object. Conservative collectors may produce false positives, where unused memory is not released because of improper pointer identification. This is not always a problem in practice unless the program handles a lot of data that could easily be misidentified as a pointer. False positives are generally less problematic on 64-bit systems than on 32-bit systems because the range of valid memory addresses tends to be a tiny fraction of the range of 64-bit values. Thus, an arbitrary 64-bit pattern is unlikely to mimic a valid pointer. Whether a precise collector is practical usually depends on the type safety properties of the programming language in question. An example for which a conservative garbage collector would be needed is the <a href="http://en.m.wikipedia.org/wiki/C_(programming_language)" title="C (programming language)">C language</a>, which allows typed (non-void) pointers to be type cast into untyped (void) pointers, and vice versa.</p>
<p>A related issue concerns <i>internal pointers</i>, or pointers to fields within an object. If the semantics of a language allow internal pointers, then there may be many different addresses that can refer to parts of the same object, which complicates determining whether an object is garbage or not. An example for this is the <a href="C++" title="C++">C++</a> language, in which multiple inheritance can cause pointers to base objects to have different addresses. In a tightly optimized program, the corresponding pointer to the object itself may have been overwritten in its register, so such internal pointers need to be scanned.</p>
<h3> <span class="mw-headline" id="Performance_implications">Performance implications</span>
</h3>
<p>Tracing garbage collectors require some implicit runtime <a href="http://en.m.wikipedia.org/wiki/Computational_overhead" title="Computational overhead" class="mw-redirect">overhead</a> that may be beyond the control of the programmer, and can sometimes lead to performance problems. For example, commonly used stop-the-world garbage collectors, which pause program execution at arbitrary times, may make garbage collection inappropriate for some <a href="Embedded_system" title="Embedded system">embedded systems</a>, high-performance <a href="http://en.m.wikipedia.org/wiki/Server_(computing)" title="Server (computing)">server</a> software, and applications with <a href="http://en.m.wikipedia.org/wiki/Real-time_computing" title="Real-time computing">real-time</a> needs.</p>
<dl>
<dt>Manual heap allocation</dt>
</dl>
<ul>
<li>search for best/first-fit block of sufficient size</li>
<li>free list maintenance</li>
</ul>
<dl>
<dt>Garbage collection</dt>
</dl>
<ul>
<li>locate reachable objects</li>
<li>copy reachable objects for moving collectors</li>
<li>read/write barriers for incremental collectors</li>
<li>search for best/first-fit block and free list maintenance for non-moving collectors</li>
</ul>
<p>It is difficult to compare the two cases directly, as their behavior depends on the situation. For example, in the best case for a garbage collecting system, allocation just increments a pointer, but in the best case for manual heap allocation, the allocator maintains freelists of specific sizes and allocation only requires following a pointer. However, this size segregation usually cause a large degree of external fragmentation, which can have an adverse impact on cache behaviour. Memory allocation in a garbage collected language may be implemented using heap allocation behind the scenes (rather than simply incrementing a pointer), so the performance advantages listed above don't necessarily apply in this case. In some situations, most notably <a href="Embedded_system" title="Embedded system">embedded systems</a>, it is possible to avoid both garbage collection and heap management overhead by preallocating pools of memory and using a custom, lightweight scheme for allocation/deallocation.<sup id="cite_ref-8" class="reference"><a href="Garbage_collection_(computer_science)#cite_note-8"><span>[</span>8<span>]</span></a></sup></p>
<p>The overhead of write barriers is more likely to be noticeable in an <a href="Imperative_programming" title="Imperative programming">imperative</a>-style program which frequently writes pointers into existing data structures than in a <a href="Functional_programming" title="Functional programming">functional</a>-style program which constructs data only once and never changes them.</p>
<p>Some advances in garbage collection can be understood as reactions to performance issues. Early collectors were stop-the-world collectors, but the performance of this approach was distracting in interactive applications. Incremental collection avoided this disruption, but at the cost of decreased efficiency due to the need for barriers. Generational collection techniques are used with both stop-the-world and incremental collectors to increase performance; the trade-off is that some garbage is not detected as such for longer than normal.</p>
<h3> <span class="mw-headline" id="Determinism">Determinism</span>
</h3>
<ul>
<li>Tracing garbage collection is not <a href="http://en.m.wikipedia.org/wiki/Deterministic_algorithm" title="Deterministic algorithm">deterministic</a> in the timing of object finalization. An object which becomes eligible for garbage collection will usually be cleaned up eventually, but there is no guarantee when (or even if) that will happen. This is an issue for program correctness when objects are tied to non-memory resources, whose release is an externally visible program behavior, such as closing a network connection, releasing a device or closing a file. One garbage collection technique which provides determinism in this regard is <a href="http://en.m.wikipedia.org/wiki/Reference_counting" title="Reference counting">reference counting</a>.</li>
</ul>
<ul>
<li>Garbage collection can have a nondeterministic impact on execution time, by potentially introducing pauses into the execution of a program which are not correlated with the algorithm being processed. Under tracing garbage collection, the request to allocate a new object can sometimes return quickly and at other times trigger a lengthy garbage collection cycle. Under reference counting, whereas allocation of objects is usually fast, decrementing a reference is nondeterministic, since a reference may reach zero, triggering recursion to decrement the reference counts of other objects which that object holds.</li>
</ul>
<h3> <span class="mw-headline" id="Real-time_garbage_collection">Real-time garbage collection</span>
</h3>
<p>While garbage collection is generally nondeterministic, it is possible to use it in hard <a href="http://en.m.wikipedia.org/wiki/Real-time_computing" title="Real-time computing">real-time</a> systems. A real-time garbage collector should guarantee that even in the worst case it will dedicate a certain number of computational resources to mutator threads. Constraints imposed on a real-time garbage collector are usually either work based or time based. A time based constraint would look like: within each time window of duration <i>T</i>, mutator threads should be allowed to run at least for <i>Tm</i> time. For work based analysis, MMU (minimal mutator utilization)<sup id="cite_ref-9" class="reference"><a href="Garbage_collection_(computer_science)#cite_note-9"><span>[</span>9<span>]</span></a></sup> is usually used as a real time constraint for the garbage collection algorithm.</p>
<p>One of the first implementations of <a href="http://en.m.wikipedia.org/wiki/Real-time_computing" title="Real-time computing">real-time</a> garbage collection for the <a href="http://en.m.wikipedia.org/wiki/JVM" title="JVM" class="mw-redirect">JVM</a> was work on the Metronome algorithm.<sup id="cite_ref-10" class="reference"><a href="Garbage_collection_(computer_science)#cite_note-10"><span>[</span>10<span>]</span></a></sup> There are other commercial implementations.<sup id="cite_ref-11" class="reference"><a href="Garbage_collection_(computer_science)#cite_note-11"><span>[</span>11<span>]</span></a></sup></p>
<h2> <span class="mw-headline" id="Reference_counting">Reference counting</span>
</h2>
<div class="rellink relarticle mainarticle">Main article: <a href="http://en.m.wikipedia.org/wiki/Reference_counting" title="Reference counting">Reference counting</a>
</div>
<p>Reference counting is a form of garbage collection whereby each object has a count of the number of references to it. Garbage is identified by having a reference count of zero. An object's reference count is incremented when a reference to it is created, and decremented when a reference is destroyed. The object's memory is reclaimed when the count reaches zero.</p>
<p>Compared to tracing garbage collection, reference counting guarantees that objects are destroyed as soon as they become unreachable (assuming that there are no reference cycles), and usually only accesses memory which is either in CPU caches, in objects to be freed, or directly pointed by those, and thus tends to not have significant negative side effects on CPU cache and virtual memory operation.</p>
<p>There are some disadvantages to reference counting:</p>
<ul>
<li>If two or more objects refer to each other, they can create a cycle whereby neither will be collected as their mutual references never let their reference counts become zero. Some garbage collection systems using reference counting (like the one in <a href="CPython" title="CPython">CPython</a>) use specific cycle-detecting algorithms to deal with this issue.<sup id="cite_ref-12" class="reference"><a href="Garbage_collection_(computer_science)#cite_note-12"><span>[</span>12<span>]</span></a></sup> Another strategy is to use <a href="http://en.m.wikipedia.org/wiki/Weak_reference" title="Weak reference">weak references</a> for the "backpointers" which create cycles. Under reference counting, a weak reference is similar to a weak reference under a tracing garbage collector. It is a special reference object whose existence does not increment the reference count of the referent object. Furthermore, a weak reference is safe in that when the referent object becomes garbage, any weak reference to it <i>lapses</i>, rather than being permitted to remain dangling, meaning that it turns into a predictable value, such as a null reference.</li>
</ul>
<ul>
<li>In naive implementations, each assignment of a reference and each reference falling out of scope often require modifications of one or more reference counters. However, in the common case, when a reference is copied from an outer scope variable into an inner scope variable, such that the lifetime of the inner variable is bounded by the lifetime of the outer one, the reference incrementing can be eliminated. The outer variable "owns" the reference. In the programming language C++, this technique is readily implemented and demonstrated with the use of <code>const</code> references. Reference counting in C++ is usually implemented using "smart pointers" whose constructors, destructors and assignment operators manage the references. A smart pointer can be passed by reference to a function, which avoids the need to copy-construct a new reference (which would increase the reference count on entry into the function and decrease it on exit). Instead the function receives a reference to the smart pointer which is produced inexpensively.</li>
</ul>
<ul>
<li>When used in a <a href="http://en.m.wikipedia.org/wiki/Thread_(computing)" title="Thread (computing)">multithreaded</a> environment, these modifications (increment and decrement) may need to be atomic operations such as <a href="http://en.m.wikipedia.org/wiki/Compare-and-swap" title="Compare-and-swap">compare-and-swap</a>, at least for any objects which are shared, or potentially shared among multiple threads. Atomic operations are expensive on a multiprocessor, and even more expensive if they have to be emulated with software algorithms. It is possible to avoid this issue by adding per-thread or per-CPU reference counts and only accessing the global reference count when the local reference counts become or are no longer zero (or, alternatively, using a binary tree of reference counts, or even giving up deterministic destruction in exchange for not having a global reference count at all), but this adds significant memory overhead and thus tends to be only useful in special cases (it's used, for example, in the reference counting of Linux kernel modules).</li>
</ul>
<ul>
<li>Naive implementations of reference counting do not in general provide real-time behavior, because any pointer assignment can potentially cause a number of objects bounded only by total allocated memory size to be recursively freed while the thread is unable to perform other work. It is possible to avoid this issue by delegating the freeing of objects whose reference count dropped to zero to other threads, at the cost of extra overhead.</li>
</ul>
<h2> <span class="mw-headline" id="Escape_analysis">Escape analysis</span>
</h2>
<div class="rellink relarticle mainarticle">Main article: <a href="http://en.m.wikipedia.org/wiki/Escape_analysis" title="Escape analysis">Escape analysis</a>
</div>
<p><a href="http://en.m.wikipedia.org/wiki/Escape_analysis" title="Escape analysis">Escape analysis</a> can be used to convert heap allocations to stack allocations, thus reducing the amount of work needed to be done by the garbage collector.</p>
<h2> <span class="mw-headline" id="Compile-time">Compile-time</span>
</h2>
<p><span class="new" title="Compile-time garbage collection (page does not exist)">Compile-time garbage collection</span> is a form of <a href="http://en.m.wikipedia.org/wiki/Static_program_analysis" title="Static program analysis">static analysis</a> allowing memory to be reused and reclaimed based on invariants known during compilation. This form of garbage collection has been studied in the <a href="http://en.m.wikipedia.org/wiki/Mercury_(programming_language)" title="Mercury (programming language)">Mercury programming language</a><sup id="cite_ref-13" class="reference"><a href="Garbage_collection_(computer_science)#cite_note-13"><span>[</span>13<span>]</span></a></sup></p>
<h2> <span class="mw-headline" id="Availability">Availability</span>
</h2>
<p>Generally speaking, <a href="http://en.m.wikipedia.org/wiki/High-level_programming_language" title="High-level programming language">higher-level programming languages</a> are more likely to have garbage collection as a standard feature. In languages that do not have built in garbage collection, it can often be added through a library, as with the <a href="http://en.m.wikipedia.org/wiki/Boehm_garbage_collector" title="Boehm garbage collector">Boehm garbage collector</a> for C and C++. This approach is not without drawbacks, such as changing object creation and destruction mechanisms.</p>
<p>Most <a href="http://en.m.wikipedia.org/wiki/Functional_programming_language" title="Functional programming language" class="mw-redirect">functional programming languages</a>, such as <a href="http://en.m.wikipedia.org/wiki/ML_(programming_language)" title="ML (programming language)">ML</a>, <a href="http://en.m.wikipedia.org/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a>, and <a href="http://en.m.wikipedia.org/wiki/APL_(programming_language)" title="APL (programming language)">APL</a>, have garbage collection built in. <a href="http://en.m.wikipedia.org/wiki/Lisp_(programming_language)" title="Lisp (programming language)">Lisp</a>, which introduced <a href="Functional_programming" title="Functional programming">functional programming</a>, is especially notable for introducing this mechanism.</p>
<p>Other dynamic languages, such as <a href="http://en.m.wikipedia.org/wiki/Ruby_(programming_language)" title="Ruby (programming language)">Ruby</a> (but not <a href="Perl" title="Perl">Perl</a> 5, or <a href="PHP" title="PHP">PHP</a>, which use reference counting), also tend to use GC. <a href="Object-oriented_programming" title="Object-oriented programming">Object-oriented programming</a> languages such as <a href="Smalltalk" title="Smalltalk">Smalltalk</a>, <a href="Java_(programming_language)" title="Java (programming language)">Java</a> and <a href="http://en.m.wikipedia.org/wiki/ECMAScript" title="ECMAScript">ECMAScript</a> usually provide integrated garbage collection. Notable exceptions are <a href="C++" title="C++">C++</a> and <a href="http://en.m.wikipedia.org/wiki/Embarcadero_Delphi" title="Embarcadero Delphi">Delphi</a> which have <a href="http://en.m.wikipedia.org/wiki/Destructor_(computer_science)" title="Destructor (computer science)" class="mw-redirect">destructors</a>. <a href="Objective-C" title="Objective-C">Objective-C</a> has not traditionally had it, but ObjC 2.0 as implemented by Apple for <a href="http://en.m.wikipedia.org/wiki/Mac_OS_X" title="Mac OS X" class="mw-redirect">Mac OS X</a> uses a runtime collector developed in-house, while the <a href="http://en.m.wikipedia.org/wiki/GNUstep" title="GNUstep">GNUstep</a> project uses a Boehm collector.</p>
<p>Historically, languages intended for beginners, such as <a href="http://en.m.wikipedia.org/wiki/BASIC" title="BASIC">BASIC</a> and <a href="http://en.m.wikipedia.org/wiki/Logo_(programming_language)" title="Logo (programming language)">Logo</a>, have often used garbage collection for heap-allocated variable-length data types, such as strings and lists, so as not to burden programmers with manual memory management. On early microcomputers, with their limited memory and slow processors, BASIC garbage collection could often cause apparently random, inexplicable pauses in the midst of program operation. Some BASIC interpreters such as Applesoft BASIC on the Apple II family, had terribly inefficient garbage collectors for strings which repeatedly scanned the string descriptors for the string having the highest address in order to compact it toward high memory. This one-string-at-a-time processing loop resulted in O(N*N) time performance in the number of strings, which would introduce a pause more than one minute long into the execution of string-intensive programs. A replacement garbage collector for Applesoft BASIC published in <a href="http://en.m.wikipedia.org/wiki/Call-A.P.P.L.E." title="Call-A.P.P.L.E.">Call-A.P.P.L.E.</a> (January 1981, pages 40–45, <a href="http://en.m.wikipedia.org/wiki/Randy_Wigginton" title="Randy Wigginton">Randy Wigginton</a>) identified a group of strings in every pass over the heap, reducing a pause of two minutes into less than a second depending on the size of the group. Other approaches were published, but none ever made it into a new revision of the BASIC interpreter.</p>
<h2> <span class="mw-headline" id="Limited_environments">Limited environments</span>
</h2>
<p>Garbage collection is rarely used on embedded or real-time systems because of the perceived need for very tight control over the use of limited resources. However, garbage collectors compatible with such limited environments have been developed.<sup id="cite_ref-14" class="reference"><a href="Garbage_collection_(computer_science)#cite_note-14"><span>[</span>14<span>]</span></a></sup> The Microsoft <a href="http://en.m.wikipedia.org/wiki/.NET_Micro_Framework" title=".NET Micro Framework">.NET Micro Framework</a> and <a href="http://en.m.wikipedia.org/wiki/Java_Platform,_Micro_Edition" title="Java Platform, Micro Edition">Java Platform, Micro Edition</a> are embedded software platforms that, like their larger cousins, include garbage collection.</p>
<h2> <span class="mw-headline" id="See_also">See also</span>
</h2>
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/International_Symposium_on_Memory_Management" title="International Symposium on Memory Management">International Symposium on Memory Management</a></li>
<li><span class="new" title="Garbage-first collector (page does not exist)">Garbage-first collector</span></li>
</ul>
<h2> <span class="mw-headline" id="References">References</span>
</h2>
<div class="reflist references-column-width" style="-moz-column-width: 30em; -webkit-column-width: 30em; column-width: 30em; list-style-type: decimal;">
<ol class="references">
<li id="cite_note-1">
<span class="mw-cite-backlink"><b><a href="Garbage_collection_(computer_science)#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=367177.367199">"Recursive functions of symbolic expressions and their computation by machine"</a>. Portal.acm.org<span class="printonly">. <a rel="nofollow" class="external free" href="http://portal.acm.org/citation.cfm?id=367177.367199">http://portal.acm.org/citation.cfm?id=367177.367199</a></span><span class="reference-accessdate">. Retrieved 29 March 2009</span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Recursive+functions+of+symbolic+expressions+and+their+computation+by+machine&amp;rft.atitle=&amp;rft.pub=Portal.acm.org&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D367177.367199&amp;rfr_id=info:sid/en.wikipedia.org:Garbage_collection_(computer_science)"><span style="display: none;"> </span></span></span>
</li>
<li id="cite_note-2">
<span class="mw-cite-backlink"><b><a href="Garbage_collection_(computer_science)#cite_ref-2">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www-formal.stanford.edu/jmc/recursive.html">"Recursive functions of symbolic expressions and their computation by machine, Part I"</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://www-formal.stanford.edu/jmc/recursive.html">http://www-formal.stanford.edu/jmc/recursive.html</a></span><span class="reference-accessdate">. Retrieved 29 May 2009</span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Recursive+functions+of+symbolic+expressions+and+their+computation+by+machine%2C+Part+I&amp;rft.atitle=&amp;rft_id=http%3A%2F%2Fwww-formal.stanford.edu%2Fjmc%2Frecursive.html&amp;rfr_id=info:sid/en.wikipedia.org:Garbage_collection_(computer_science)"><span style="display: none;"> </span></span></span>
</li>
<li id="cite_note-3">
<span class="mw-cite-backlink"><b><a href="Garbage_collection_(computer_science)#cite_ref-3">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external free" href="http://docs.oracle.com/javase/7/docs/api/java/lang/ref/SoftReference.html">http://docs.oracle.com/javase/7/docs/api/java/lang/ref/SoftReference.html</a></span>
</li>
<li id="cite_note-4">
<span class="mw-cite-backlink"><b><a href="Garbage_collection_(computer_science)#cite_ref-4">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external free" href="http://docs.oracle.com/javase/7/docs/api/java/lang/ref/PhantomReference.html">http://docs.oracle.com/javase/7/docs/api/java/lang/ref/PhantomReference.html</a></span>
</li>
<li id="cite_note-5">
<span class="mw-cite-backlink"><b><a href="Garbage_collection_(computer_science)#cite_ref-5">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external free" href="http://docs.oracle.com/javase/7/docs/api/java/lang/ref/WeakReference.html">http://docs.oracle.com/javase/7/docs/api/java/lang/ref/WeakReference.html</a></span>
</li>
<li id="cite_note-6">
<span class="mw-cite-backlink"><b><a href="Garbage_collection_(computer_science)#cite_ref-6">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external free" href="http://msdn.microsoft.com/en-us/library/ms404247.aspx">http://msdn.microsoft.com/en-us/library/ms404247.aspx</a></span>
</li>
<li id="cite_note-7">
<span class="mw-cite-backlink"><b><a href="Garbage_collection_(computer_science)#cite_ref-7">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://msdn2.microsoft.com/en-us/library/23acw07k.aspx">"Copying and Pinning"</a>. Msdn2.microsoft.com<span class="printonly">. <a rel="nofollow" class="external free" href="http://msdn2.microsoft.com/en-us/library/23acw07k.aspx">http://msdn2.microsoft.com/en-us/library/23acw07k.aspx</a></span><span class="reference-accessdate">. Retrieved 9 July 2010</span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Copying+and+Pinning&amp;rft.atitle=&amp;rft.pub=Msdn2.microsoft.com&amp;rft_id=http%3A%2F%2Fmsdn2.microsoft.com%2Fen-us%2Flibrary%2F23acw07k.aspx&amp;rfr_id=info:sid/en.wikipedia.org:Garbage_collection_(computer_science)"><span style="display: none;"> </span></span></span>
</li>
<li id="cite_note-8">
<span class="mw-cite-backlink"><b><a href="Garbage_collection_(computer_science)#cite_ref-8">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.eros-os.org/pipermail/cap-talk/2007-January/006795.html">"Memory allocation in embedded systems"</a>. Eros-os.org<span class="printonly">. <a rel="nofollow" class="external free" href="http://www.eros-os.org/pipermail/cap-talk/2007-January/006795.html">http://www.eros-os.org/pipermail/cap-talk/2007-January/006795.html</a></span><span class="reference-accessdate">. Retrieved 29 March 2009</span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Memory+allocation+in+embedded+systems&amp;rft.atitle=&amp;rft.pub=Eros-os.org&amp;rft_id=http%3A%2F%2Fwww.eros-os.org%2Fpipermail%2Fcap-talk%2F2007-January%2F006795.html&amp;rfr_id=info:sid/en.wikipedia.org:Garbage_collection_(computer_science)"><span style="display: none;"> </span></span></span>
</li>
<li id="cite_note-9">
<span class="mw-cite-backlink"><b><a href="Garbage_collection_(computer_science)#cite_ref-9">^</a></b></span> <span class="reference-text"><span class="citation Journal">Perry Cheng; Guy E. Blelloch (22 June 2001). "A parallel, real-time garbage collector". <i>ACM SIGPLAN Notices</i> <b>36</b> (5): 125–136. <a href="Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F381694.378823">10.1145/381694.378823</a>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=A+parallel%2C+real-time+garbage+collector&amp;rft.jtitle=ACM+SIGPLAN+Notices&amp;rft.aulast=Perry+Cheng&amp;rft.au=Perry+Cheng&amp;rft.au=Guy+E.+Blelloch&amp;rft.date=22+June+2001&amp;rft.volume=36&amp;rft.issue=5&amp;rft.pages=125%E2%80%93136&amp;rft_id=info:doi/10.1145%2F381694.378823&amp;rfr_id=info:sid/en.wikipedia.org:Garbage_collection_(computer_science)"><span style="display: none;"> </span></span></span>
</li>
<li id="cite_note-10">
<span class="mw-cite-backlink"><b><a href="Garbage_collection_(computer_science)#cite_ref-10">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.research.ibm.com/people/d/dfb/papers/Bacon03Metronome.pdf">"The Metronome: A Simpler Approach to Garbage Collection in Real-Time Systems"</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://www.research.ibm.com/people/d/dfb/papers/Bacon03Metronome.pdf">http://www.research.ibm.com/people/d/dfb/papers/Bacon03Metronome.pdf</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=The+Metronome%3A+A+Simpler+Approach+to+Garbage+Collection+in+Real-Time+Systems&amp;rft.atitle=&amp;rft_id=http%3A%2F%2Fwww.research.ibm.com%2Fpeople%2Fd%2Fdfb%2Fpapers%2FBacon03Metronome.pdf&amp;rfr_id=info:sid/en.wikipedia.org:Garbage_collection_(computer_science)"><span style="display: none;"> </span></span></span>
</li>
<li id="cite_note-11">
<span class="mw-cite-backlink"><b><a href="Garbage_collection_(computer_science)#cite_ref-11">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.ibm.com/developerworks/java/library/j-rtj4/index.html">"Real-time Java, Part 4: Real-time garbage collection"</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://www.ibm.com/developerworks/java/library/j-rtj4/index.html">http://www.ibm.com/developerworks/java/library/j-rtj4/index.html</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Real-time+Java%2C+Part+4%3A+Real-time+garbage+collection&amp;rft.atitle=&amp;rft_id=http%3A%2F%2Fwww.ibm.com%2Fdeveloperworks%2Fjava%2Flibrary%2Fj-rtj4%2Findex.html&amp;rfr_id=info:sid/en.wikipedia.org:Garbage_collection_(computer_science)"><span style="display: none;"> </span></span></span>
</li>
<li id="cite_note-12">
<span class="mw-cite-backlink"><b><a href="Garbage_collection_(computer_science)#cite_ref-12">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.python.org/doc/2.5.2/ext/refcounts.html">"Reference Counts"</a>. <i>Extending and Embedding the Python Interpreter</i>. 21 February 2008<span class="printonly">. <a rel="nofollow" class="external free" href="http://www.python.org/doc/2.5.2/ext/refcounts.html">http://www.python.org/doc/2.5.2/ext/refcounts.html</a></span><span class="reference-accessdate">. Retrieved 13 November 2008</span>. "While Python uses the traditional reference counting implementation, it also offers a cycle detector that works to detect reference cycles."</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Reference+Counts&amp;rft.atitle=Extending+and+Embedding+the+Python+Interpreter&amp;rft.date=21+February+2008&amp;rft_id=http%3A%2F%2Fwww.python.org%2Fdoc%2F2.5.2%2Fext%2Frefcounts.html&amp;rfr_id=info:sid/en.wikipedia.org:Garbage_collection_(computer_science)"><span style="display: none;"> </span></span></span>
</li>
<li id="cite_note-13">
<span class="mw-cite-backlink"><b><a href="Garbage_collection_(computer_science)#cite_ref-13">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.mercury.csse.unimelb.edu.au/information/papers.html#mazur-thesis">"Compile-time garbage collection for the declarative language Mercury"</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://www.mercury.csse.unimelb.edu.au/information/papers.html#mazur-thesis">http://www.mercury.csse.unimelb.edu.au/information/papers.html#mazur-thesis</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Compile-time+garbage+collection+for+the+declarative+language+Mercury&amp;rft.atitle=&amp;rft_id=http%3A%2F%2Fwww.mercury.csse.unimelb.edu.au%2Finformation%2Fpapers.html%23mazur-thesis&amp;rfr_id=info:sid/en.wikipedia.org:Garbage_collection_(computer_science)"><span style="display: none;"> </span></span></span>
</li>
<li id="cite_note-14">
<span class="mw-cite-backlink"><b><a href="Garbage_collection_(computer_science)#cite_ref-14">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://portal.acm.org/ft_gateway.cfm?id=1140392&amp;type=pdf&amp;coll=GUIDE&amp;dl=GUIDE&amp;CFID=15151515&amp;CFTOKEN=6184618">"Wei Fu and Carl Hauser, "A Real-Time Garbage Collection Framework for Embedded Systems". ACM SCOPES '05, 2005"</a>. Portal.acm.org<span class="printonly">. <a rel="nofollow" class="external free" href="http://portal.acm.org/ft_gateway.cfm?id=1140392&amp;type=pdf&amp;coll=GUIDE&amp;dl=GUIDE&amp;CFID=15151515&amp;CFTOKEN=6184618">http://portal.acm.org/ft_gateway.cfm?id=1140392&amp;type=pdf&amp;coll=GUIDE&amp;dl=GUIDE&amp;CFID=15151515&amp;CFTOKEN=6184618</a></span><span class="reference-accessdate">. Retrieved 9 July 2010</span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Wei+Fu+and+Carl+Hauser%2C+%22A+Real-Time+Garbage+Collection+Framework+for+Embedded+Systems%22.+ACM+SCOPES+%2705%2C+2005&amp;rft.atitle=&amp;rft.pub=Portal.acm.org&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fft_gateway.cfm%3Fid%3D1140392%26type%3Dpdf%26coll%3DGUIDE%26dl%3DGUIDE%26CFID%3D15151515%26CFTOKEN%3D6184618&amp;rfr_id=info:sid/en.wikipedia.org:Garbage_collection_(computer_science)"><span style="display: none;"> </span></span></span>
</li>
</ol>
</div>
<h2> <span class="mw-headline" id="Further_reading">Further reading</span>
</h2>
<ul>
<li>
<span class="citation book" id="CITEREFJonesHoskingMoss2011"><span class="new" title="Richard Jones (computer scientist) (page does not exist)">Jones, Richard</span>; <span class="new" title="Antony Hosking (page does not exist)">Hosking, Antony</span>; <span class="new" title="Eliot Moss (page does not exist)">Moss, Eliot</span> (19 August 2011). <i>The Garbage Collection Handbook: The Art of Automatic Memory Management</i>. CRC Applied Algorithms and Data Structures Series. Chapman and Hall/CRC. <a href="International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="http://en.m.wikipedia.org/wiki/Special:BookSources/1-4200-8279-5" title="Special:BookSources/1-4200-8279-5">1-4200-8279-5</a>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=The+Garbage+Collection+Handbook%3A+The+Art+of+Automatic+Memory+Management&amp;rft.aulast=Jones&amp;rft.aufirst=Richard&amp;rft.au=Jones%2C%26%2332%3BRichard&amp;rft.au=Hosking%2C%26%2332%3BAntony&amp;rft.au=Moss%2C%26%2332%3BEliot&amp;rft.date=19+August+2011&amp;rft.series=CRC+Applied+Algorithms+and+Data+Structures+Series&amp;rft.pub=Chapman+and+Hall%2FCRC&amp;rft.isbn=1-4200-8279-5&amp;rfr_id=info:sid/en.wikipedia.org:Garbage_collection_(computer_science)"><span style="display: none;"> </span></span>
</li>
<li>
<span class="citation book" id="CITEREFJonesLins1996"><span class="new" title="Richard Jones (computer scientist) (page does not exist)">Jones, Richard</span>; <span class="new" title="Rafael D. Lins (page does not exist)">Lins, Rafael D.</span> (1996). <i>Garbage Collection: Algorithms for Automatic Dynamic Memory Management</i>. Wiley. <a href="International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="http://en.m.wikipedia.org/wiki/Special:BookSources/0-471-94148-4" title="Special:BookSources/0-471-94148-4">0-471-94148-4</a>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Garbage+Collection%3A+Algorithms+for+Automatic+Dynamic+Memory+Management&amp;rft.aulast=Jones&amp;rft.aufirst=Richard&amp;rft.au=Jones%2C%26%2332%3BRichard&amp;rft.au=Lins%2C%26%2332%3BRafael+D.&amp;rft.date=1996&amp;rft.pub=Wiley&amp;rft.isbn=0-471-94148-4&amp;rfr_id=info:sid/en.wikipedia.org:Garbage_collection_(computer_science)"><span style="display: none;"> </span></span>
</li>
<li>
<span class="citation Journal" id="CITEREFWilsonJohnstoneNeelyBoles1995">Wilson, Paul R.; Johnstone, M. S.; Neely, M.; Boles, D. (1995). <a rel="nofollow" class="external text" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.275">"Dynamic Storage Allocation: A Survey and Critical Review"</a>. <i><a href="http://en.m.wikipedia.org/wiki/International_Workshop_on_Memory_Management" title="International Workshop on Memory Management" class="mw-redirect">International Workshop on Memory Management</a></i><span class="printonly">. <a rel="nofollow" class="external free" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.275">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.275</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Dynamic+Storage+Allocation%3A+A+Survey+and+Critical+Review&amp;rft.jtitle=%5B%5BInternational+Workshop+on+Memory+Management%5D%5D&amp;rft.aulast=Wilson&amp;rft.aufirst=Paul+R.&amp;rft.au=Wilson%2C%26%2332%3BPaul+R.&amp;rft.au=Johnstone%2C%26%2332%3BM.+S.&amp;rft.au=Neely%2C%26%2332%3BM.&amp;rft.au=Boles%2C%26%2332%3BD.&amp;rft.date=1995&amp;rft_id=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fsummary%3Fdoi%3D10.1.1.47.275&amp;rfr_id=info:sid/en.wikipedia.org:Garbage_collection_(computer_science)"><span style="display: none;"> </span></span>
</li>
<li>
<span class="citation Journal" id="CITEREFWilson1992"><span class="new" title="Paul R. Wilson (page does not exist)">Wilson, Paul R.</span> (1992). <a rel="nofollow" class="external text" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.2438">"Uniprocessor Garbage Collection Techniques"</a>. <i>IWMM '92 Proceedings of the International Workshop on Memory Management</i> (Springer-Verlag)<span class="printonly">. <a rel="nofollow" class="external free" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.2438">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.2438</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Uniprocessor+Garbage+Collection+Techniques&amp;rft.jtitle=IWMM+%2792+Proceedings+of+the+International+Workshop+on+Memory+Management&amp;rft.aulast=Wilson&amp;rft.aufirst=Paul+R.&amp;rft.au=Wilson%2C%26%2332%3BPaul+R.&amp;rft.date=1992&amp;rft.pub=Springer-Verlag&amp;rft_id=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fsummary%3Fdoi%3D10.1.1.47.2438&amp;rfr_id=info:sid/en.wikipedia.org:Garbage_collection_(computer_science)"><span style="display: none;"> </span></span>
</li>
</ul>
<h2> <span class="mw-headline" id="External_links">External links</span>
</h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://gchandbook.org">The Garbage Collection Handbook: The Art of Automatic Memory Management</a></li>
<li>
<a rel="nofollow" class="external text" href="http://www.cs.kent.ac.uk/people/staff/rej/gc.html">Richard Jones' Garbage Collection Page</a> at the <a href="http://en.m.wikipedia.org/wiki/University_of_Kent" title="University of Kent">University of Kent</a>
</li>
<li><a rel="nofollow" class="external text" href="http://www.memorymanagement.org/">The Memory Management Reference</a></li>
<li>
<a rel="nofollow" class="external text" href="http://basen.oru.se/kurser/koi/2008-2009-p1/texter/gc/index.html">The Very Basics of Garbage Collection</a>, by Thomas Padron-McCarthy</li>
<li>
<a rel="nofollow" class="external text" href="http://www.cs.utexas.edu/users/oops/papers.html">Publications by the OOPS group</a> at the <a href="http://en.m.wikipedia.org/wiki/University_of_Texas_at_Austin" title="University of Texas at Austin">University of Texas at Austin</a>
</li>
<li>
<a rel="nofollow" class="external text" href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/">A garbage collector for C and C++</a> by <span class="new" title="Hans Boehm (page does not exist)">Hans Boehm</span>
</li>
<li>
<a rel="nofollow" class="external text" href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/example.html">Expensive Explicit Deallocation: An Example</a> by Hans Boehm</li>
<li>
<a rel="nofollow" class="external text" href="http://www.cs.utexas.edu/users/EWD/ewd05xx/EWD595.PDF">On-the-fly garbage collection: an exercise in cooperation</a> by <a href="http://en.m.wikipedia.org/wiki/Edsger_W._Dijkstra" title="Edsger W. Dijkstra">Edsger W. Dijkstra</a> and <a href="http://en.m.wikipedia.org/wiki/Leslie_Lamport" title="Leslie Lamport">Leslie Lamport</a> and A.J.Martin and C.S.Scholten and E.F.M.Steffens</li>
<li><a rel="nofollow" class="external text" href="http://www.academicresourcecenter.net/curriculum/pfv.aspx?ID=6182">A Garbage Collection Course Curriculum at MSDN Academic Alliance</a></li>
<li><a rel="nofollow" class="external text" href="http://www.osnews.com/story.php?news_id=6864">A Glance at Garbage Collection in Object-Oriented Languages</a></li>
<li><a rel="nofollow" class="external text" href="http://www.vineetgupta.com/2007/01/notes-on-the-clr-garbage-collector">Notes on the CLR Garbage Collector</a></li>
<li><a rel="nofollow" class="external text" href="http://aragozin.blogspot.com/2011/06/understanding-gc-pauses-in-jvm-hotspots.html">Understanding GC pauses in HotSpot JVM</a></li>
<li><a rel="nofollow" class="external text" href="http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html">Java SE 6 HotSpot™ Virtual Machine Garbage Collection Tuning</a></li>
</ul>
<dl>
<dt>Implementations</dt>
</dl>
<ul>
<li>
<a rel="nofollow" class="external text" href="http://web.media.mit.edu/~lieber/Lieberary/GC/Realtime/Realtime.html">A Real-Time Garbage Collector Based on the Lifetimes of Objects</a> by H. Lieberman and C. Hewitt, MIT Artificial Intelligence Laboratory</li>
<li><a rel="nofollow" class="external text" href="http://tinygc.sourceforge.net/">TinyGC - an independent implementation of the BoehmGC API</a></li>
<li><a rel="nofollow" class="external text" href="http://code.google.com/p/openrtl">OpenRTL - Contains a mark and sweep collector for a standard dynamic allocation heap, with precise scanning support.</a></li>
<li>
<a rel="nofollow" class="external text" href="http://www.codeproject.com/KB/cpp/conservative_gc.aspx">Conservative Garbage Collection Implementation for C Language</a> by Yasin Hınıslıoğlu</li>
<li><a rel="nofollow" class="external text" href="http://sourceforge.net/projects/meixnergc/">MeixnerGC - an incremental mark and sweep garbage collector for C++ using smart pointers</a></li>
</ul>
<table cellspacing="0" class="navbox" style="border-spacing:0;;"><tr>
<td style="padding:2px;">
<table cellspacing="0" class="nowraplinks hlist collapsible autocollapse navbox-inner" style="border-spacing:0;background:transparent;color:inherit;;">
<tr>
<th scope="col" style=";" class="navbox-title" colspan="2">
<div class="noprint plainlinks hlist navbar mini" style="">
<ul>
<li class="nv-view"><a href="http://en.m.wikipedia.org/wiki/Template:Memory_management_navbox" title="Template:Memory management navbox"><span title="View this template" style=";;background:none transparent;border:none;">v</span></a></li>
<li class="nv-talk"><a href="http://en.m.wikipedia.org/wiki/Template_talk:Memory_management_navbox" title="Template talk:Memory management navbox"><span title="Discuss this template" style=";;background:none transparent;border:none;">t</span></a></li>
<li class="nv-edit"><a class="external text" href="http://en.wikipedia.org/w/index.php?title=Template:Memory_management_navbox&amp;action=edit"><span title="Edit this template" style=";;background:none transparent;border:none;">e</span></a></li>
</ul>
</div>
<div class="" style="font-size:110%;"><a href="http://en.m.wikipedia.org/wiki/Memory_management" title="Memory management">Memory management</a></div>
</th>
</tr>
<tr style="height:2px">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=";;"><a href="http://en.m.wikipedia.org/wiki/Manual_memory_management" title="Manual memory management">Manual memory management</a></th>
<td style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Delete_(C%2B%2B)" title="Delete (C++)">delete (C++)</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/C_dynamic_memory_allocation" title="C dynamic memory allocation">C dynamic memory allocation</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/New_(C%2B%2B)" title="New (C++)">new (C++)</a></li>
<li><a href="Static_memory_allocation" title="Static memory allocation">Static memory allocation</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=";;"><a href="http://en.m.wikipedia.org/wiki/Virtual_memory" title="Virtual memory">Virtual memory</a></th>
<td style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Demand_paging" title="Demand paging">Demand paging</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Page_table" title="Page table">Page table</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Paging" title="Paging">Paging</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=";;">Hardware</th>
<td style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Memory_management_unit" title="Memory management unit">Memory management unit</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Translation_lookaside_buffer" title="Translation lookaside buffer">Translation lookaside buffer</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=";;"><strong class="selflink">Garbage collection</strong></th>
<td style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Boehm_garbage_collector" title="Boehm garbage collector">Boehm garbage collector</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Finalizer" title="Finalizer">Finalizer</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Garbage_(computer_science)" title="Garbage (computer science)">Garbage</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Mark-compact_algorithm" title="Mark-compact algorithm">Mark-compact algorithm</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Reference_counting" title="Reference counting">Reference counting</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Strong_reference" title="Strong reference">Strong reference</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Weak_reference" title="Weak reference">Weak reference</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=";;"><a href="http://en.m.wikipedia.org/wiki/Memory_segmentation" title="Memory segmentation">Memory segmentation</a></th>
<td style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Protected_mode" title="Protected mode">Protected mode</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Real_mode" title="Real mode">Real mode</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Virtual_8086_mode" title="Virtual 8086 mode">Virtual 8086 mode</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/X86_memory_segmentation" title="X86 memory segmentation">x86 memory segmentation</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=";;"><a href="http://en.m.wikipedia.org/wiki/Memory_safety" title="Memory safety">Memory safety</a></th>
<td style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<div style="padding:0em 0.25em">
<ul>
<li><a href="Buffer_overflow" title="Buffer overflow">Buffer overflow</a></li>
<li><a href="Dangling_pointer" title="Dangling pointer">Dangling pointer</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Stack_overflow" title="Stack overflow">Stack overflow</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=";;">Issues</th>
<td style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Fragmentation_(computer)" title="Fragmentation (computer)" class="mw-redirect">Fragmentation</a></li>
<li><a href="Memory_leak" title="Memory leak">Memory leak</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Unreachable_memory" title="Unreachable memory">Unreachable memory</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=";;">Other</th>
<td style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Automatic_variable" title="Automatic variable">Automatic variable</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/International_Symposium_on_Memory_Management" title="International Symposium on Memory Management">International Symposium on Memory Management</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Region-based_memory_management" title="Region-based memory management">Region-based memory management</a></li>
</ul>
</div>
</td>
</tr>
</table>
</td>
</tr></table>
<table cellspacing="0" class="navbox" style="border-spacing:0;;"><tr>
<td style="padding:2px;">
<table cellspacing="0" class="nowraplinks hlist collapsible autocollapse navbox-inner" style="border-spacing:0;background:transparent;color:inherit;;">
<tr>
<th scope="col" style=";" class="navbox-title" colspan="2">
<div class="noprint plainlinks hlist navbar mini" style="">
<ul>
<li class="nv-view"><a href="http://en.m.wikipedia.org/wiki/Template:John_McCarthy_navbox" title="Template:John McCarthy navbox"><span title="View this template" style=";;background:none transparent;border:none;">v</span></a></li>
<li class="nv-talk"><a href="http://en.m.wikipedia.org/wiki/Template_talk:John_McCarthy_navbox" title="Template talk:John McCarthy navbox"><span title="Discuss this template" style=";;background:none transparent;border:none;">t</span></a></li>
<li class="nv-edit"><a class="external text" href="http://en.wikipedia.org/w/index.php?title=Template:John_McCarthy_navbox&amp;action=edit"><span title="Edit this template" style=";;background:none transparent;border:none;">e</span></a></li>
</ul>
</div>
<div class="" style="font-size:110%;"><a href="http://en.m.wikipedia.org/wiki/John_McCarthy_(computer_scientist)" title="John McCarthy (computer scientist)">John McCarthy</a></div>
</th>
</tr>
<tr style="height:2px;">
<td></td>
</tr>
<tr>
<td colspan="2" style="width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Artificial_intelligence" title="Artificial intelligence">Artificial intelligence</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Circumscription_(logic)" title="Circumscription (logic)">Circumscription</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Dartmouth_Conferences" title="Dartmouth Conferences">Dartmouth Conferences</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Frame_problem" title="Frame problem">Frame problem</a></li>
<li><strong class="selflink">Garbage collection</strong></li>
<li><a href="http://en.m.wikipedia.org/wiki/Lisp_(programming_language)" title="Lisp (programming language)">Lisp</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/McCarthy_91_function" title="McCarthy 91 function">McCarthy 91 function</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Situation_calculus" title="Situation calculus">Situation calculus</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Space_fountain" title="Space fountain">Space fountain</a></li>
<li><span class="new" title="Vera Watson (page does not exist)">Vera Watson</span></li>
</ul>
</div>
</td>
</tr>
</table>
</td>
</tr></table>

						<div class="section" id="mw-mf-language-section">
				<h2 id="section_language" class="section_heading">Read in another language</h2>
				<div id="content_language" class="content_block">
					<p>This article is available in 28 languages</p>
					<ul id="mw-mf-language-selection"><li><a href="http://ar.m.wikipedia.org/wiki/%D8%AC%D9%85%D8%B9_%D8%A7%D9%84%D9%82%D9%85%D8%A7%D9%85%D8%A9" lang="ar" hreflang="ar">العربية</a></li><li><a href="http://ca.m.wikipedia.org/wiki/Recollida_d%27escombraries" lang="ca" hreflang="ca">català</a></li><li><a href="http://cs.m.wikipedia.org/wiki/Garbage_collector" lang="cs" hreflang="cs">česky</a></li><li><a href="http://de.m.wikipedia.org/wiki/Garbage_Collection" lang="de" hreflang="de">Deutsch</a></li><li><a href="http://el.m.wikipedia.org/wiki/%CE%A3%CF%85%CE%BB%CE%BB%CE%BF%CE%B3%CE%AE_%CF%83%CE%BA%CE%BF%CF%85%CF%80%CE%B9%CE%B4%CE%B9%CF%8E%CE%BD_(%CE%B5%CF%80%CE%B9%CF%83%CF%84%CE%AE%CE%BC%CE%B7_%CF%85%CF%80%CE%BF%CE%BB%CE%BF%CE%B3%CE%B9%CF%83%CF%84%CF%8E%CE%BD)" lang="el" hreflang="el">Ελληνικά</a></li><li><a href="http://es.m.wikipedia.org/wiki/Recolector_de_basura" lang="es" hreflang="es">español</a></li><li><a href="http://eo.m.wikipedia.org/wiki/Senrubigilo" lang="eo" hreflang="eo">Esperanto</a></li><li><a href="http://fa.m.wikipedia.org/wiki/%D8%B2%D8%A8%D8%A7%D9%84%D9%87_%D8%AC%D9%85%D8%B9%E2%80%8C%DA%A9%D9%86_(%D8%B9%D9%84%D9%88%D9%85_%D8%B1%D8%A7%DB%8C%D8%A7%D9%86%D9%87)" lang="fa" hreflang="fa">فارسی</a></li><li><a href="http://fr.m.wikipedia.org/wiki/Ramasse-miettes_(informatique)" lang="fr" hreflang="fr">français</a></li><li><a href="http://gl.m.wikipedia.org/wiki/Recolecci%C3%B3n_de_lixo" lang="gl" hreflang="gl">galego</a></li><li><a href="http://ko.m.wikipedia.org/wiki/%EC%93%B0%EB%A0%88%EA%B8%B0_%EC%88%98%EC%A7%91_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)" lang="ko" hreflang="ko">한국어</a></li><li><a href="http://hr.m.wikipedia.org/wiki/Sakupljanje_sme%C4%87a_(ra%C4%8Dunarstvo)" lang="hr" hreflang="hr">hrvatski</a></li><li><a href="http://id.m.wikipedia.org/wiki/Pengumpulan_sampah_(ilmu_komputer)" lang="id" hreflang="id">Bahasa Indonesia</a></li><li><a href="http://it.m.wikipedia.org/wiki/Garbage_collection" lang="it" hreflang="it">italiano</a></li><li><a href="http://he.m.wikipedia.org/wiki/%D7%90%D7%99%D7%A1%D7%95%D7%A3_%D7%96%D7%91%D7%9C" lang="he" hreflang="he">עברית</a></li><li><a href="http://lt.m.wikipedia.org/wiki/%C5%A0iuk%C5%A1li%C5%B3_surinktuvas" lang="lt" hreflang="lt">lietuvių</a></li><li><a href="http://hu.m.wikipedia.org/wiki/Garbage_collection" lang="hu" hreflang="hu">magyar</a></li><li><a href="http://ms.m.wikipedia.org/wiki/Pengutipan_sampah_(sains_komputer)" lang="ms" hreflang="ms">Bahasa Melayu</a></li><li><a href="http://nl.m.wikipedia.org/wiki/Geheugensanering" lang="nl" hreflang="nl">Nederlands</a></li><li><a href="http://ja.m.wikipedia.org/wiki/%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3" lang="ja" hreflang="ja">日本語</a></li><li><a href="http://pl.m.wikipedia.org/wiki/Od%C5%9Bmiecanie_pami%C4%99ci" lang="pl" hreflang="pl">polski</a></li><li><a href="http://pt.m.wikipedia.org/wiki/Coletor_de_lixo_(inform%C3%A1tica)" lang="pt" hreflang="pt">português</a></li><li><a href="http://ru.m.wikipedia.org/wiki/%D0%A1%D0%B1%D0%BE%D1%80%D0%BA%D0%B0_%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0" lang="ru" hreflang="ru">русский</a></li><li><a href="http://fi.m.wikipedia.org/wiki/Automaattinen_roskienker%C3%A4ys" lang="fi" hreflang="fi">suomi</a></li><li><a href="http://sv.m.wikipedia.org/wiki/Skr%C3%A4psamling" lang="sv" hreflang="sv">svenska</a></li><li><a href="http://tr.m.wikipedia.org/wiki/%C3%87%C3%B6p_toplama_(bilgisayar_bilimi)" lang="tr" hreflang="tr">Türkçe</a></li><li><a href="http://uk.m.wikipedia.org/wiki/%D0%97%D0%B1%D0%B8%D1%80%D0%B0%D0%BD%D0%BD%D1%8F_%D1%81%D0%BC%D1%96%D1%82%D1%82%D1%8F" lang="uk" hreflang="uk">українська</a></li><li><a href="http://zh.m.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)" lang="zh" hreflang="zh">中文</a></li></ul>
				</div>
			</div>			</div><!-- close #content_wrapper -->
			<div id="footer">
			<h2 class="section_heading" id="section_footer">
		<img src="http://bits.wikimedia.org/static-1.21wmf3/extensions/MobileFrontend/stylesheets/common/images/logo-copyright-en.png" class="license" alt="Wikipedia ®" />	</h2>
	<div class="content_block" id="content_footer">
		<ul class="settings">
			<li>
				<span class="left separator"><a id="mw-mf-display-toggle" href="http://en.wikipedia.org/w/index.php?title=Garbage_collection_(computer_science)&amp;mobileaction=toggle_view_desktop">Desktop</a></span><span class="right">Mobile</span>
			</li>
			<li class="notice">
				Article by <a href="http://en.m.wikipedia.org/w/index.php?title=Garbage_collection_(computer_science)&amp;action=history">contributors</a> like you<br>
				Content available under <a href="Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License?useformat=mobile">CC BY-SA 3.0</a>				<span>| <a href="http://wikimediafoundation.org/wiki/Terms_of_use?useformat=mobile">Terms of Use</a></span>
			</li>
		</ul>
		<ul class="links">
						<li>
			<a href='http://en.m.wikipedia.org/w/index.php?title=Special:MobileFeedback&amp;returnto=Garbage+collection+%28computer+science%29&amp;feedbacksource=MobileFrontend'>
				Contact Wikipedia			</a>
			</li><li>
						<a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy</a></li><li>
			<a href="Wikipedia:About" title="Wikipedia:About">About</a></li><li>
			<a href="Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
		</ul>
	</div><!-- close footer.div / #content_footer -->
	</div><!-- close #footer -->
					</div><!-- close #mw-mf-page-center -->
		</div><!-- close #mw-mf-viewport -->
		
					</body>
	</html>