<!doctype html>
	<html lang="en" dir="ltr" class="">
	<head>
		<title>Kernel (computing) - Wikipedia, the free encyclopedia</title>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<meta name="robots" content="noindex,nofollow"/>		<link rel="stylesheet" href="http://bits.wikimedia.org/en.wikipedia.org/load.php?debug=false&amp;lang=en&amp;modules=mobile%7Cmobile.production-only%2Cproduction-jquery%7Cmobile.device.default&amp;only=styles&amp;skin=mobile&amp;version=1352163471&amp;*" />
<link rel="stylesheet" href="http://bits.wikimedia.org/en.wikipedia.org/load.php?debug=false&amp;lang=en&amp;modules=mobile.site&amp;only=styles&amp;skin=mobile&amp;*" />		<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png" />		<script type="text/javascript">
			var _mwStart = +new Date;
			window._evq = window._evq || [];
			if ( typeof console === 'undefined' ) {
				console = { log: function() {} };
			}
			if( typeof mw === 'undefined' ) {
				mw = {};
			}
			var mwMobileFrontendConfig = {"messages":{"mobile-frontend-watchlist-add":"Added $1 to your watchlist","mobile-frontend-watchlist-removed":"Removed $1 from your watchlist","mobile-frontend-watchlist-view":"View your watchlist","mobile-frontend-ajax-random-heading":"Locating knowledge...","mobile-frontend-ajax-random-quote":"Intellectual growth should commence at birth and cease only at death","mobile-frontend-ajax-random-quote-author":"Albert Einstein","mobile-frontend-ajax-random-question":"Read this article?","mobile-frontend-ajax-random-yes":"Yes","mobile-frontend-ajax-random-retry":"Try again","mobile-frontend-ajax-page-loading":"Loading $1","mobile-frontend-page-saving":"Saving $1","mobile-frontend-ajax-page-error":"Whoops! Something went wrong there. Please try refreshing your browser window.","mobile-frontend-meta-data-issues":"This article has some issues","mobile-frontend-meta-data-issues-header":"Issues","expand-section":"Show","collapse-section":"Hide","remove-results":"Back...","mobile-frontend-search-noresults":"No article titles match your search. Change your search, or press the keyboard search button to search inside articles.","mobile-frontend-search-help":"Type search term above and matching article titles will appear here.","contents-heading":"Contents","language-heading":"Read this article in","mobile-frontend-close-section":"Close this section","mobile-frontend-language-footer":"<a href="http://en.m.wikipedia.org/wiki/\&quot;\/wiki\/Special:MobileOptions\/Language\&quot;">Note: This article may not be written in your preferred language. You can see which languages Wikipedia supports by clicking here.<\/a>","mobile-frontend-language-site-choose":"Search language","mobile-frontend-language-site-nomatches":"No matching languages"},"settings":{"action":"","authenticated":false,"scriptPath":"\/w","shim":"\/\/bits.wikimedia.org\/static-1.21wmf3\/extensions\/MobileFrontend\/stylesheets\/common\/images\/blank.gif","pageUrl":"\/wiki\/$1","beta":null,"title":"Kernel (computing)","useFormatCookieName":"mf_mobileFormat","useFormatCookieDuration":-1,"useFormatCookieDomain":"en.wikipedia.org","useFormatCookiePath":"\/","stopMobileRedirectCookieName":"stopMobileRedirect","stopMobileRedirectCookieDuration":15552000,"stopMobileRedirectCookieDomain":".wikipedia.org","hookOptions":""}};
			function _mwLogEvent( data, additionalInformation ) {
				var timestamp = + new Date;
				var ev = { event_id: 'mobile', delta: timestamp - _mwStart, data: data, beta: mwMobileFrontendConfig.settings.beta,
					session: _mwStart, page: mwMobileFrontendConfig.settings.title, info: additionalInformation || '' };
				_evq.push( ev );
				console.log( typeof JSON === 'undefined' ? ev : JSON.stringify( ev ) );
			}
		</script>
				<link rel="canonical" href="http://en.wikipedia.org/wiki/Kernel_(computing)" >
	</head>
	<body class="mobile live">
				<div id="mw-mf-viewport">
		<div id="mw-mf-page-left">
		<div id='mw-mf-content-left'>
		<ul id="mw-mf-menu-main">
			<li class='icon'><a href="Main_Page"
				title="Home">
				Home</a></li>
			<li class='icon2'><a href="Special:Random#mw-mf-page-left" id="randomButton"
				title="Random"
				class="button">Random</a></li>
						<li class='icon5'>
				<a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileOptions&amp;returnto=Kernel+%28computing%29"
					title="Settings">
				Settings				</a>
			</li>
					</ul>
		</div>
		</div>
		<div id='mw-mf-page-center'>
									<div id="mw-mf-header">
		<a title="Open main menu" href="Special:MobileMenu#mw-mf-page-left" id="mw-mf-main-menu-button">				<img alt="menu"
				src="http://bits.wikimedia.org/static-1.21wmf3/extensions/MobileFrontend/stylesheets/common/images/blank.gif">
		</a>			<form id="mw-mf-searchForm" action="http://en.m.wikipedia.org/w/index.php" class="search_bar" method="get">
			<input type="hidden" value="Special:Search" name="title" />
			<div id="mw-mf-sq" class="divclearable">
				<input type="search" name="search" id="mw-mf-search" size="22" value="" autocomplete="off" maxlength="1024" class="search"
					placeholder="Search Wikipedia"
					/>
				<img src="http://bits.wikimedia.org/static-1.21wmf3/extensions/MobileFrontend/stylesheets/common/images/blank.gif" alt="Clear" class="clearlink" id="mw-mf-clearsearch" title="Clear"/>
				<input class='searchSubmit' type="submit" value="Go">
			</div>
		</form>
	</div>
	<div id="results"></div>
		<div class='show ' id='content_wrapper'>
						<h1 id="firstHeading">Kernel (computing)</h1>			
<div class="thumb tright">
<div class="thumbinner" style="width:222px;">
<a href="http://en.m.wikipedia.org/wiki/File:Kernel_Layout.svg" class="image"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/8/8f/Kernel_Layout.svg/220px-Kernel_Layout.svg.png" width="220" height="174" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/8/8f/Kernel_Layout.svg/330px-Kernel_Layout.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/8/8f/Kernel_Layout.svg/440px-Kernel_Layout.svg.png 2x"></a>
<div class="thumbcaption">

A kernel connects the application software to the hardware of a computer</div>
</div>
</div>
<p>In <a href="Computing" title="Computing">computing</a>, the <b>kernel</b> is the main component of most computer <a href="Operating_system" title="Operating system">operating systems</a>; it is a bridge between <a href="http://en.m.wikipedia.org/wiki/Application_software" title="Application software">applications</a> and the actual <a href="http://en.m.wikipedia.org/wiki/Data_processing" title="Data processing" class="mw-redirect">data processing</a> done at the hardware level. The kernel's responsibilities include managing the system's resources (the communication between <a href="http://en.m.wikipedia.org/wiki/Computer_hardware" title="Computer hardware">hardware</a> and <a href="http://en.m.wikipedia.org/wiki/Computer_software" title="Computer software" class="mw-redirect">software</a> components).<sup id="cite_ref-Wulf74_1-0" class="reference"><a href="Kernel_(computer_science)#cite_note-Wulf74-1"><span>[</span>1<span>]</span></a></sup> Usually, as a basic component of an operating system, a kernel can provide the lowest-level <a href="http://en.m.wikipedia.org/wiki/Abstraction_layer" title="Abstraction layer">abstraction layer</a> for the resources (especially <a href="http://en.m.wikipedia.org/wiki/Central_processing_unit" title="Central processing unit">processors</a> and <a href="Input/output" title="Input/output">I/O devices</a>) that application software must control to perform its function. It typically makes these facilities available to <a href="http://en.m.wikipedia.org/wiki/Application_software" title="Application software">application</a> <a href="http://en.m.wikipedia.org/wiki/Process_(computing)" title="Process (computing)">processes</a> through <a href="http://en.m.wikipedia.org/wiki/Inter-process_communication" title="Inter-process communication">inter-process communication</a> mechanisms and <a href="http://en.m.wikipedia.org/wiki/System_call" title="System call">system calls</a>.</p>
<p>Operating system tasks are done differently by different kernels, depending on their design and implementation. While <a href="http://en.m.wikipedia.org/wiki/Monolithic_kernel" title="Monolithic kernel">monolithic kernels</a> execute all the operating system code in the same <a href="http://en.m.wikipedia.org/wiki/Address_space" title="Address space">address space</a> to increase the performance of the system, <a href="http://en.m.wikipedia.org/wiki/Microkernel" title="Microkernel">microkernels</a> run most of the operating system services in <a href="http://en.m.wikipedia.org/wiki/User_space" title="User space">user space</a> as servers, aiming to improve maintainability and modularity of the operating system.<sup id="cite_ref-mono-micro_2-0" class="reference"><a href="Kernel_(computer_science)#cite_note-mono-micro-2"><span>[</span>2<span>]</span></a></sup> A range of possibilities exists between these two extremes.</p>
<h2> <span class="mw-headline" id="Kernel_basic_facilities">Kernel basic facilities</span>
</h2>
<p>The kernel's primary function is to manage the computer's resources and allow other programs to run and use these resources.<sup id="cite_ref-Wulf74_1-1" class="reference"><a href="Kernel_(computer_science)#cite_note-Wulf74-1"><span>[</span>1<span>]</span></a></sup> Typically, the resources consist of:</p>
<ul>
<li>The <a href="http://en.m.wikipedia.org/wiki/Central_Processing_Unit" title="Central Processing Unit" class="mw-redirect">Central Processing Unit</a>. This is the most central part of a computer system, responsible for <i>running</i> or <i>executing</i> programs. The kernel takes responsibility for deciding at any time which of the many running programs should be allocated to the processor or processors (each of which can usually run only one program at a time)</li>
<li>The computer's <a href="http://en.m.wikipedia.org/wiki/Random-access_memory" title="Random-access memory">memory</a>. Memory is used to store both program instructions and data. Typically, both need to be present in memory in order for a program to execute. Often multiple programs will want access to memory, frequently demanding more memory than the computer has available. The kernel is responsible for deciding which memory each process can use, and determining what to do when not enough is available.</li>
<li>Any <a href="Input/output" title="Input/output">Input/Output (I/O)</a> devices present in the computer, such as keyboard, mouse, disk drives, USB devices, printers, displays, network adapters, etc. The kernel allocates requests from applications to perform I/O to an appropriate device (or subsection of a device, in the case of files on a disk or windows on a display) and provides convenient methods for using the device (typically abstracted to the point where the application does not need to know implementation details of the device).</li>
</ul>
<p>Key aspects necessary in resource managements are the definition of an execution domain (<a href="http://en.m.wikipedia.org/wiki/Address_space" title="Address space">address space</a>) and the protection mechanism used to mediate the accesses to the resources within a domain.<sup id="cite_ref-Wulf74_1-2" class="reference"><a href="Kernel_(computer_science)#cite_note-Wulf74-1"><span>[</span>1<span>]</span></a></sup></p>
<p>Kernels also usually provide methods for <a href="http://en.m.wikipedia.org/wiki/Synchronization_(computer_science)" title="Synchronization (computer science)">synchronization</a> and communication between processes called <a href="http://en.m.wikipedia.org/wiki/Inter-process_communication" title="Inter-process communication">inter-process communication</a> (IPC).</p>
<p>A kernel may implement these features itself, or rely on some of the processes it runs to provide the facilities to other processes, although in this case it must provide some means of IPC to allow processes to access the facilities provided by each other.</p>
<p>Finally, a kernel must provide running programs with a method to make requests to access these facilities.</p>
<h3> <span class="mw-headline" id="Process_management">Process management</span>
</h3>
<div class="rellink relarticle mainarticle">Main article: <a href="http://en.m.wikipedia.org/wiki/Process_management_(computing)" title="Process management (computing)">Process management (computing)</a>
</div>
<p>The main task of a kernel is to allow the <a href="http://en.m.wikipedia.org/wiki/Execution_(computing)" title="Execution (computing)">execution</a> of <a href="http://en.m.wikipedia.org/wiki/Application_software" title="Application software">applications</a> and support them with features such as <a href="http://en.m.wikipedia.org/wiki/Hardware_abstraction" title="Hardware abstraction">hardware abstractions</a>. A <a href="http://en.m.wikipedia.org/wiki/Process(computing)" title="Process(computing)" class="mw-redirect">process</a> defines which <a href="Computer_memory" title="Computer memory">memory</a> portions the application can <a href="http://en.m.wikipedia.org/wiki/Filesystem_permissions" title="Filesystem permissions">access</a>.<sup id="cite_ref-Levy84_3-0" class="reference"><a href="Kernel_(computer_science)#cite_note-Levy84-3"><span>[</span>3<span>]</span></a></sup> (For this introduction, process, application and program are used as synonyms.) Kernel <a href="http://en.m.wikipedia.org/wiki/Process_management" title="Process management">process management</a> must take into account the hardware built-in equipment for <a href="http://en.m.wikipedia.org/wiki/Memory_protection" title="Memory protection">memory protection</a>.<sup id="cite_ref-4" class="reference"><a href="Kernel_(computer_science)#cite_note-4"><span>[</span>4<span>]</span></a></sup></p>
<p>To run an application, a kernel typically sets up an <a href="http://en.m.wikipedia.org/wiki/Address_space" title="Address space">address space</a> for the application, loads the file containing the application's code into memory (perhaps via <a href="http://en.m.wikipedia.org/wiki/Demand_paging" title="Demand paging">demand paging</a>), sets up a <a href="Call_stack" title="Call stack">stack</a> for the program and branches to a given location inside the program, thus starting its execution.<sup id="cite_ref-OS-Concepts_5-0" class="reference"><a href="Kernel_(computer_science)#cite_note-OS-Concepts-5"><span>[</span>5<span>]</span></a></sup></p>
<p><a href="http://en.m.wikipedia.org/wiki/Computer_multitasking" title="Computer multitasking">Multi-tasking</a> kernels are able to give the user the illusion that the number of processes being run simultaneously on the computer is higher than the maximum number of processes the computer is physically able to run simultaneously. Typically, the number of processes a system may run simultaneously is equal to the number of CPUs installed (however this may not be the case if the processors support <a href="http://en.m.wikipedia.org/wiki/Simultaneous_multithreading" title="Simultaneous multithreading">simultaneous multithreading</a>).</p>
<p>In a <a href="http://en.m.wikipedia.org/wiki/Pre-emptive_multitasking" title="Pre-emptive multitasking" class="mw-redirect">pre-emptive multitasking</a> system, the kernel will give every program a slice of time and switch from process to process so quickly that it will appear to the user as if these processes were being executed simultaneously. The kernel uses <a href="http://en.m.wikipedia.org/wiki/Scheduling_algorithm" title="Scheduling algorithm" class="mw-redirect">scheduling algorithms</a> to determine which process is running next and how much time it will be given. The algorithm chosen may allow for some processes to have higher priority than others. The kernel generally also provides these processes a way to communicate; this is known as <a href="http://en.m.wikipedia.org/wiki/Inter-process_communication" title="Inter-process communication">inter-process communication</a> (IPC) and the main approaches are <a href="http://en.m.wikipedia.org/wiki/Shared_memory" title="Shared memory">shared memory</a>, <a href="http://en.m.wikipedia.org/wiki/Message_passing" title="Message passing">message passing</a> and <a href="http://en.m.wikipedia.org/wiki/Remote_procedure_call" title="Remote procedure call">remote procedure calls</a> (see <a href="http://en.m.wikipedia.org/wiki/Concurrent_computing" title="Concurrent computing">concurrent computing</a>).</p>
<p>Other systems (particularly on smaller, less powerful computers) may provide <a href="http://en.m.wikipedia.org/wiki/Co-operative_multitasking" title="Co-operative multitasking" class="mw-redirect">co-operative multitasking</a>, where each process is allowed to run uninterrupted until it makes a special request that tells the kernel it may switch to another process. Such requests are known as "yielding", and typically occur in response to requests for interprocess communication, or for waiting for an event to occur. Older versions of <a href="http://en.m.wikipedia.org/wiki/Microsoft_Windows" title="Microsoft Windows">Windows</a> and <a href="http://en.m.wikipedia.org/wiki/Mac_OS" title="Mac OS">Mac OS</a> both used <a href="http://en.m.wikipedia.org/wiki/Co-operative_multitasking" title="Co-operative multitasking" class="mw-redirect">co-operative multitasking</a> but switched to <a href="http://en.m.wikipedia.org/wiki/Pre-emptive" title="Pre-emptive" class="mw-redirect">pre-emptive</a> schemes as the power of the computers to which they were targeted grew.<sup id="cite_ref-6" class="reference"><a href="Kernel_(computer_science)#cite_note-6"><span>[</span>6<span>]</span></a></sup></p>
<p>The operating system might also support <a href="http://en.m.wikipedia.org/wiki/Multiprocessing" title="Multiprocessing">multiprocessing</a> (<a href="http://en.m.wikipedia.org/wiki/Symmetric_multiprocessing" title="Symmetric multiprocessing">SMP</a> or <a href="http://en.m.wikipedia.org/wiki/Non-Uniform_Memory_Access" title="Non-Uniform Memory Access">Non-Uniform Memory Access</a>); in that case, different programs and threads may run on different processors. A kernel for such a system must be designed to be re-entrant, meaning that it may safely run two different parts of its code simultaneously. This typically means providing <a href="http://en.m.wikipedia.org/wiki/Synchronization_(computer_science)" title="Synchronization (computer science)">synchronization</a> mechanisms (such as <a href="http://en.m.wikipedia.org/wiki/Spinlock" title="Spinlock">spinlocks</a>) to ensure that no two processors attempt to modify the same data at the same time.</p>
<h3> <span class="mw-headline" id="Memory_management">Memory management</span>
</h3>
<p>The kernel has full access to the system's memory and must allow processes to safely access this memory as they require it. Often the first step in doing this is <a href="http://en.m.wikipedia.org/wiki/Virtual_addressing" title="Virtual addressing" class="mw-redirect">virtual addressing</a>, usually achieved by <a href="http://en.m.wikipedia.org/wiki/Paging" title="Paging">paging</a> and/or <a href="http://en.m.wikipedia.org/wiki/Segmentation_(memory)" title="Segmentation (memory)" class="mw-redirect">segmentation</a>. Virtual addressing allows the kernel to make a given physical address appear to be another address, the virtual address. Virtual address spaces may be different for different processes; the memory that one process accesses at a particular (virtual) address may be different memory from what another process accesses at the same address. This allows every program to behave as if it is the only one (apart from the kernel) running and thus prevents applications from crashing each other.<sup id="cite_ref-OS-Concepts_5-1" class="reference"><a href="Kernel_(computer_science)#cite_note-OS-Concepts-5"><span>[</span>5<span>]</span></a></sup></p>
<p>On many systems, a program's virtual address may refer to data which is not currently in memory. The layer of indirection provided by virtual addressing allows the operating system to use other data stores, like a <a href="http://en.m.wikipedia.org/wiki/Hard_drive" title="Hard drive" class="mw-redirect">hard drive</a>, to store what would otherwise have to remain in main memory (<a href="http://en.m.wikipedia.org/wiki/Random-access_memory" title="Random-access memory">RAM</a>). As a result, operating systems can allow programs to use more memory than the system has physically available. When a program needs data which is not currently in RAM, the CPU signals to the kernel that this has happened, and the kernel responds by writing the contents of an inactive memory block to disk (if necessary) and replacing it with the data requested by the program. The program can then be resumed from the point where it was stopped. This scheme is generally known as <a href="http://en.m.wikipedia.org/wiki/Demand_paging" title="Demand paging">demand paging</a>.</p>
<p>Virtual addressing also allows creation of virtual partitions of memory in two disjointed areas, one being reserved for the kernel (<a href="http://en.m.wikipedia.org/wiki/Kernel_space" title="Kernel space" class="mw-redirect">kernel space</a>) and the other for the applications (<a href="http://en.m.wikipedia.org/wiki/User_space" title="User space">user space</a>). The applications are not permitted by the processor to address kernel memory, thus preventing an application from damaging the running kernel. This fundamental partition of memory space has contributed much to current designs of actual general-purpose kernels and is almost universal in such systems, although some research kernels (e.g. <a href="http://en.m.wikipedia.org/wiki/Singularity_(operating_system)" title="Singularity (operating system)">Singularity</a>) take other approaches.</p>
<h3> <span class="mw-headline" id="Device_management">Device management</span>
</h3>
<p>To perform useful functions, processes need access to the <a href="http://en.m.wikipedia.org/wiki/Peripheral" title="Peripheral">peripherals</a> connected to the computer, which are controlled by the kernel through <a href="http://en.m.wikipedia.org/wiki/Device_driver" title="Device driver">device drivers</a>. A device driver is a computer program that enables the operating system to interact with a hardware device. It provides the operating system with information of how to control and communicate with a certain piece of hardware. The driver is an important and vital piece to a program application. The design goal of a driver is abstraction; the function of the driver is to translate the OS-mandated function calls (programming calls) into device-specific calls. In theory, the device should work correctly with the suitable driver. Device drivers are used for such things as video cards, sound cards, printers, scanners, modems, and LAN cards. The common levels of abstraction of device drivers are:</p>
<p>1. On the hardware side:</p>
<ul>
<li>Interfacing directly.</li>
<li>Using a high level interface (Video <a href="http://en.m.wikipedia.org/wiki/BIOS" title="BIOS">BIOS</a>).</li>
<li>Using a lower-level device driver (file drivers using disk drivers).</li>
<li>Simulating work with hardware, while doing something entirely different.</li>
</ul>
<p>2. On the software side:</p>
<ul>
<li>Allowing the operating system direct access to hardware resources.</li>
<li>Implementing only primitives.</li>
<li>Implementing an interface for non-driver software (Example: <a href="http://en.m.wikipedia.org/wiki/TWAIN" title="TWAIN">TWAIN</a>).</li>
<li>Implementing a language, sometimes high-level (Example <a href="http://en.m.wikipedia.org/wiki/PostScript" title="PostScript">PostScript</a>).</li>
</ul>
<p>For example, to show the user something on the screen, an application would make a request to the kernel, which would forward the request to its display driver, which is then responsible for actually plotting the character/pixel.<sup id="cite_ref-OS-Concepts_5-2" class="reference"><a href="Kernel_(computer_science)#cite_note-OS-Concepts-5"><span>[</span>5<span>]</span></a></sup></p>
<p>A kernel must maintain a list of available devices. This list may be known in advance (e.g. on an embedded system where the kernel will be rewritten if the available hardware changes), configured by the user (typical on older PCs and on systems that are not designed for personal use) or detected by the operating system at run time (normally called <a href="http://en.m.wikipedia.org/wiki/Plug_and_play" title="Plug and play">plug and play</a>). In a plug and play system, a device manager first performs a scan on different <a href="http://en.m.wikipedia.org/wiki/Hardware_bus" title="Hardware bus" class="mw-redirect">hardware buses</a>, such as <a href="http://en.m.wikipedia.org/wiki/Peripheral_Component_Interconnect" title="Peripheral Component Interconnect" class="mw-redirect">Peripheral Component Interconnect</a> (PCI) or <a href="http://en.m.wikipedia.org/wiki/Universal_Serial_Bus" title="Universal Serial Bus">Universal Serial Bus</a> (USB), to detect installed devices, then searches for the appropriate drivers.</p>
<p>As device management is a very <a href="Operating_system" title="Operating system">OS</a>-specific topic, these drivers are handled differently by each kind of kernel design, but in every case, the kernel has to provide the <a href="http://en.m.wikipedia.org/wiki/Input/Output" title="Input/Output" class="mw-redirect">I/O</a> to allow drivers to physically access their devices through some <a href="http://en.m.wikipedia.org/wiki/Port_(computer_networking)" title="Port (computer networking)">port</a> or memory location. Very important decisions have to be made when designing the device management system, as in some designs accesses may involve <a href="http://en.m.wikipedia.org/wiki/Context_switch" title="Context switch">context switches</a>, making the operation very CPU-intensive and easily causing a significant performance overhead.<sup class="Template-Fact" style="white-space:nowrap;">[<i><a href="http://en.m.wikipedia.org/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources from July 2007">citation needed</span></a></i>]</sup></p>
<h3> <span class="mw-headline" id="System_calls">System calls</span>
</h3>
<p>A system call is a mechanism that is used by the application program to request a service from the operating system. They use a machine-code instruction that causes the processor to change mode. An example would be from supervisor mode to protected mode. This is where the operating system performs actions like accessing hardware devices or the memory management unit. Generally the operating system provides a library that sits between the operating system and normal programs. Usually it is a C library such as Glibc or Windows API. The library handles the low-level details of passing information to the kernel and switching to supervisor mode. System calls include close, open, read, wait and write.</p>
<p>To actually perform useful work, a process must be able to access the services provided by the kernel. This is implemented differently by each kernel, but most provide a <a href="http://en.m.wikipedia.org/wiki/C_library" title="C library" class="mw-redirect">C library</a> or an <a href="http://en.m.wikipedia.org/wiki/Application_Programming_Interface" title="Application Programming Interface" class="mw-redirect">API</a>, which in turn invokes the related kernel functions.<sup id="cite_ref-7" class="reference"><a href="Kernel_(computer_science)#cite_note-7"><span>[</span>7<span>]</span></a></sup></p>
<p>The method of invoking the kernel function varies from kernel to kernel. If memory isolation is in use, it is impossible for a user process to call the kernel directly, because that would be a violation of the processor's access control rules. A few possibilities are:</p>
<ul>
<li>Using a software-simulated <a href="http://en.m.wikipedia.org/wiki/Interrupt" title="Interrupt">interrupt</a>. This method is available on most hardware, and is therefore very common.</li>
<li>Using a <a href="http://en.m.wikipedia.org/wiki/Call_gate" title="Call gate">call gate</a>. A call gate is a special address stored by the kernel in a list in kernel memory at a location known to the processor. When the processor detects a call to that address, it instead redirects to the target location without causing an access violation. This requires hardware support, but the hardware for it is quite common.</li>
<li>Using a special <a href="http://en.m.wikipedia.org/wiki/System_call" title="System call">system call</a> instruction. This technique requires special hardware support, which common architectures (notably, <a href="http://en.m.wikipedia.org/wiki/X86" title="X86">x86</a>) may lack. System call instructions have been added to recent models of x86 processors, however, and some operating systems for PCs make use of them when available.</li>
<li>Using a memory-based queue. An application that makes large numbers of requests but does not need to wait for the result of each may add details of requests to an area of memory that the kernel periodically scans to find requests.</li>
</ul>
<h2> <span class="mw-headline" id="Kernel_design_decisions">Kernel design decisions</span>
</h2>
<h3> <span class="mw-headline" id="Issues_of_kernel_support_for_protection">Issues of kernel support for protection</span>
</h3>
<p>An important consideration in the design of a kernel is the support it provides for protection from faults (<a href="http://en.m.wikipedia.org/wiki/Fault_tolerance" title="Fault tolerance" class="mw-redirect">fault tolerance</a>) and from malicious behaviors (<a href="http://en.m.wikipedia.org/wiki/Computer_security" title="Computer security">security</a>). These two aspects are usually not clearly distinguished, and the <a href="http://en.m.wikipedia.org/wiki/Separation_of_protection_and_security" title="Separation of protection and security">adoption of this distinction</a> in the kernel design leads to the rejection of a <a href="http://en.m.wikipedia.org/wiki/Hierarchical_protection_domains" title="Hierarchical protection domains" class="mw-redirect">hierarchical structure for protection</a>.<sup id="cite_ref-Wulf74_1-3" class="reference"><a href="Kernel_(computer_science)#cite_note-Wulf74-1"><span>[</span>1<span>]</span></a></sup></p>
<p>The mechanisms or policies provided by the kernel can be classified according to several criteria, as: static (enforced at <a href="http://en.m.wikipedia.org/wiki/Compile_time" title="Compile time">compile time</a>) or dynamic (enforced at <a href="Run_time_(program_lifecycle_phase)" title="Run time (program lifecycle phase)">run time</a>); preemptive or post-detection; according to the protection principles they satisfy (i.e. <a href="http://en.m.wikipedia.org/wiki/Peter_J._Denning" title="Peter J. Denning">Denning</a><sup id="cite_ref-Denning76_8-0" class="reference"><a href="Kernel_(computer_science)#cite_note-Denning76-8"><span>[</span>8<span>]</span></a></sup><sup id="cite_ref-Swift05Denning76_9-0" class="reference"><a href="Kernel_(computer_science)#cite_note-Swift05Denning76-9"><span>[</span>9<span>]</span></a></sup>); whether they are hardware supported or language based; whether they are more an open mechanism or a binding policy; and many more.</p>
<p>Support for hierarchical protection domains<sup id="cite_ref-Schroeder72_10-0" class="reference"><a href="Kernel_(computer_science)#cite_note-Schroeder72-10"><span>[</span>10<span>]</span></a></sup> is typically that of "<a href="http://en.m.wikipedia.org/wiki/CPU_modes" title="CPU modes">CPU modes</a>." An efficient and simple way to provide hardware support of capabilities is to delegate the <a href="http://en.m.wikipedia.org/wiki/Memory_management_unit" title="Memory management unit">MMU</a> the responsibility of checking access-rights for every memory access, a mechanism called <a href="http://en.m.wikipedia.org/wiki/Capability-based_addressing" title="Capability-based addressing">capability-based addressing</a>.<sup id="cite_ref-LindenCapabilityAddressing_11-0" class="reference"><a href="Kernel_(computer_science)#cite_note-LindenCapabilityAddressing-11"><span>[</span>11<span>]</span></a></sup> Most commercial computer architectures lack MMU support for capabilities. An alternative approach is to simulate capabilities using commonly supported hierarchical domains; in this approach, each protected object must reside in an address space that the application does not have access to; the kernel also maintains a list of capabilities in such memory. When an application needs to access an object protected by a capability, it performs a system call and the kernel performs the access for it. The performance cost of address space switching limits the practicality of this approach in systems with complex interactions between objects, but it is used in current operating systems for objects that are not accessed frequently or which are not expected to perform quickly.<sup id="cite_ref-EranianMosberger_12-0" class="reference"><a href="Kernel_(computer_science)#cite_note-EranianMosberger-12"><span>[</span>12<span>]</span></a></sup><sup id="cite_ref-13" class="reference"><a href="Kernel_(computer_science)#cite_note-13"><span>[</span>13<span>]</span></a></sup> Approaches where protection mechanism are not firmware supported but are instead simulated at higher levels (e.g. simulating capabilities by manipulating page tables on hardware that does not have direct support), are possible, but there are performance implications.<sup id="cite_ref-HochBrowne_14-0" class="reference"><a href="Kernel_(computer_science)#cite_note-HochBrowne-14"><span>[</span>14<span>]</span></a></sup> Lack of hardware support may not be an issue, however, for systems that choose to use language-based protection.<sup id="cite_ref-Schneider_15-0" class="reference"><a href="Kernel_(computer_science)#cite_note-Schneider-15"><span>[</span>15<span>]</span></a></sup></p>
<p>An important kernel design decision is the choice of the abstraction levels where the security mechanisms and policies should be implemented. Kernel security mechanisms play a critical role in supporting security at higher levels.<sup id="cite_ref-LindenCapabilityAddressing_11-1" class="reference"><a href="Kernel_(computer_science)#cite_note-LindenCapabilityAddressing-11"><span>[</span>11<span>]</span></a></sup><sup id="cite_ref-Loscocco98_16-0" class="reference"><a href="Kernel_(computer_science)#cite_note-Loscocco98-16"><span>[</span>16<span>]</span></a></sup><sup id="cite_ref-17" class="reference"><a href="Kernel_(computer_science)#cite_note-17"><span>[</span>17<span>]</span></a></sup><sup id="cite_ref-18" class="reference"><a href="Kernel_(computer_science)#cite_note-18"><span>[</span>18<span>]</span></a></sup><sup id="cite_ref-19" class="reference"><a href="Kernel_(computer_science)#cite_note-19"><span>[</span>19<span>]</span></a></sup></p>
<p>One approach is to use firmware and kernel support for fault tolerance (see above), and build the security policy for malicious behavior on top of that (adding features such as <a href="http://en.m.wikipedia.org/wiki/Cryptography" title="Cryptography">cryptography</a> mechanisms where necessary), delegating some responsibility to the <a href="Compiler" title="Compiler">compiler</a>. Approaches that delegate enforcement of security policy to the compiler and/or the application level are often called <i>language-based security</i>.</p>
<p>The lack of many critical security mechanisms in current mainstream operating systems impedes the implementation of adequate security policies at the application <a href="http://en.m.wikipedia.org/wiki/Abstraction_level" title="Abstraction level" class="mw-redirect">abstraction level</a>.<sup id="cite_ref-Loscocco98_16-1" class="reference"><a href="Kernel_(computer_science)#cite_note-Loscocco98-16"><span>[</span>16<span>]</span></a></sup> In fact, a common misconception in computer security is that any security policy can be implemented in an application regardless of kernel support.<sup id="cite_ref-Loscocco98_16-2" class="reference"><a href="Kernel_(computer_science)#cite_note-Loscocco98-16"><span>[</span>16<span>]</span></a></sup></p>
<h4> <span class="mw-headline" id="Hardware-based_protection_or_language-based_protection">Hardware-based protection or language-based protection</span>
</h4>
<p>Typical computer systems today use hardware-enforced rules about what programs are allowed to access what data. The processor monitors the execution and stops a program that violates a rule (e.g., a user process that is about to read or write to kernel memory, and so on). In systems that lack support for capabilities, processes are isolated from each other by using separate address spaces.<sup id="cite_ref-20" class="reference"><a href="Kernel_(computer_science)#cite_note-20"><span>[</span>20<span>]</span></a></sup> Calls from user processes into the kernel are regulated by requiring them to use one of the above-described system call methods.</p>
<p>An alternative approach is to use language-based protection. In a <a href="http://en.m.wikipedia.org/wiki/Language-based_system" title="Language-based system">language-based protection system</a>, the kernel will only allow code to execute that has been produced by a trusted language <a href="Compiler" title="Compiler">compiler</a>. The language may then be designed such that it is impossible for the programmer to instruct it to do something that will violate a security requirement.<sup id="cite_ref-Schneider_15-1" class="reference"><a href="Kernel_(computer_science)#cite_note-Schneider-15"><span>[</span>15<span>]</span></a></sup></p>
<p>Advantages of this approach include:</p>
<ul>
<li>No need for separate address spaces. Switching between address spaces is a slow operation that causes a great deal of overhead, and a lot of optimization work is currently performed in order to prevent unnecessary switches in current operating systems. Switching is completely unnecessary in a language-based protection system, as all code can safely operate in the same address space.</li>
<li>Flexibility. Any protection scheme that can be designed to be expressed via a programming language can be implemented using this method. Changes to the protection scheme (e.g. from a hierarchical system to a capability-based one) do not require new hardware.</li>
</ul>
<p>Disadvantages include:</p>
<ul>
<li>Longer application start up time. Applications must be verified when they are started to ensure they have been compiled by the correct compiler, or may need recompiling either from source code or from <a href="http://en.m.wikipedia.org/wiki/Bytecode" title="Bytecode">bytecode</a>.</li>
<li>Inflexible <a href="Type_system" title="Type system">type systems</a>. On traditional systems, applications frequently perform operations that are not <a href="http://en.m.wikipedia.org/wiki/Type_safety" title="Type safety">type safe</a>. Such operations cannot be permitted in a language-based protection system, which means that applications may need to be rewritten and may, in some cases, lose performance.</li>
</ul>
<p>Examples of systems with language-based protection include <a href="http://en.m.wikipedia.org/wiki/JX_(operating_system)" title="JX (operating system)">JX</a> and <a href="http://en.m.wikipedia.org/wiki/Microsoft" title="Microsoft">Microsoft</a>'s <a href="http://en.m.wikipedia.org/wiki/Singularity_(operating_system)" title="Singularity (operating system)">Singularity</a>.</p>
<h3> <span class="mw-headline" id="Process_cooperation">Process cooperation</span>
</h3>
<p><a href="http://en.m.wikipedia.org/wiki/Edsger_Dijkstra" title="Edsger Dijkstra" class="mw-redirect">Edsger Dijkstra</a> proved that from a logical point of view, <a href="http://en.m.wikipedia.org/wiki/Atomicity_(programming)" title="Atomicity (programming)" class="mw-redirect">atomic</a> <a href="http://en.m.wikipedia.org/wiki/Lock_(computer_science)" title="Lock (computer science)">lock</a> and unlock operations operating on binary <a href="http://en.m.wikipedia.org/wiki/Semaphore_(programming)" title="Semaphore (programming)">semaphores</a> are sufficient primitives to express any functionality of process cooperation.<sup id="cite_ref-Dijkstra65_21-0" class="reference"><a href="Kernel_(computer_science)#cite_note-Dijkstra65-21"><span>[</span>21<span>]</span></a></sup> However this approach is generally held to be lacking in terms of safety and efficiency, whereas a <a href="http://en.m.wikipedia.org/wiki/Message_passing" title="Message passing">message passing</a> approach is more flexible.<sup id="cite_ref-Hansen70_22-0" class="reference"><a href="Kernel_(computer_science)#cite_note-Hansen70-22"><span>[</span>22<span>]</span></a></sup> A number of other approaches (either lower- or higher-level) are available as well, with many modern kernels providing support for systems such as <a href="http://en.m.wikipedia.org/wiki/Shared_memory" title="Shared memory">shared memory</a> and <a href="http://en.m.wikipedia.org/wiki/Remote_procedure_call" title="Remote procedure call">remote procedure calls</a>.</p>
<h3> <span class="mw-headline" id="I.2FO_devices_management">I/O devices management</span>
</h3>
<p>The idea of a kernel where I/O devices are handled uniformly with other processes, as parallel co-operating processes, was first proposed and implemented by <a href="http://en.m.wikipedia.org/wiki/Brinch_Hansen" title="Brinch Hansen" class="mw-redirect">Brinch Hansen</a> (although similar ideas were suggested in 1967<sup id="cite_ref-23" class="reference"><a href="Kernel_(computer_science)#cite_note-23"><span>[</span>23<span>]</span></a></sup><sup id="cite_ref-24" class="reference"><a href="Kernel_(computer_science)#cite_note-24"><span>[</span>24<span>]</span></a></sup>). In Hansen's description of this, the "common" processes are called <i>internal processes</i>, while the I/O devices are called <i>external processes</i>.<sup id="cite_ref-Hansen70_22-1" class="reference"><a href="Kernel_(computer_science)#cite_note-Hansen70-22"><span>[</span>22<span>]</span></a></sup></p>
<p>Similar to physical memory, allowing applications direct access to controller ports and registers can cause the controller to malfunction, or system to crash. With this, depending on the complexity of the device, some devices can get surprisingly complex to program, and use several different controllers. Because of this, providing a more abstract interface to manage the device is important. This interface is normally done by a Device Driver or Hardware Abstraction Layer. Frequently, applications will require access to these devices. The Kernel must maintain the list of these devices by querying the system for them in some way. This can be done through the BIOS, or through one of the various system buses (Such as PCI/PCIE, or USB.) When an application requests an operation on a device (Such as displaying a character), the kernel needs to send this request to the current active video driver. The video driver, in turn, needs to carry out this request. This is an example of Inter Process Communication (IPC).</p>
<h2> <span class="mw-headline" id="Kernel-wide_design_approaches">Kernel-wide design approaches</span>
</h2>
<p>Naturally, the above listed tasks and features can be provided in many ways that differ from each other in design and implementation.</p>
<p>The principle of <i><a href="http://en.m.wikipedia.org/wiki/Separation_of_mechanism_and_policy" title="Separation of mechanism and policy">separation of mechanism and policy</a></i> is the substantial difference between the philosophy of micro and monolithic kernels.<sup id="cite_ref-25" class="reference"><a href="Kernel_(computer_science)#cite_note-25"><span>[</span>25<span>]</span></a></sup><sup id="cite_ref-Levin75_26-0" class="reference"><a href="Kernel_(computer_science)#cite_note-Levin75-26"><span>[</span>26<span>]</span></a></sup> Here a <i>mechanism</i> is the support that allows the implementation of many different policies, while a policy is a particular "mode of operation". For instance, a mechanism may provide for user log-in attempts to call an authorization server to determine whether access should be granted; a policy may be for the authorization server to request a password and check it against an encrypted password stored in a database. Because the mechanism is generic, the policy could more easily be changed (e.g. by requiring the use of a <a href="http://en.m.wikipedia.org/wiki/Security_token" title="Security token">security token</a>) than if the mechanism and policy were integrated in the same module.</p>
<p>In minimal microkernel just some very basic policies are included,<sup id="cite_ref-Levin75_26-1" class="reference"><a href="Kernel_(computer_science)#cite_note-Levin75-26"><span>[</span>26<span>]</span></a></sup> and its mechanisms allows what is running on top of the kernel (the remaining part of the operating system and the other applications) to decide which policies to adopt (as memory management, high level process scheduling, file system management, etc.).<sup id="cite_ref-Wulf74_1-4" class="reference"><a href="Kernel_(computer_science)#cite_note-Wulf74-1"><span>[</span>1<span>]</span></a></sup><sup id="cite_ref-Hansen70_22-2" class="reference"><a href="Kernel_(computer_science)#cite_note-Hansen70-22"><span>[</span>22<span>]</span></a></sup> A monolithic kernel instead tends to include many policies, therefore restricting the rest of the system to rely on them.</p>
<p><a href="http://en.m.wikipedia.org/wiki/Per_Brinch_Hansen" title="Per Brinch Hansen">Per Brinch Hansen</a> presented arguments in favor of separation of mechanism and policy.<sup id="cite_ref-Wulf74_1-5" class="reference"><a href="Kernel_(computer_science)#cite_note-Wulf74-1"><span>[</span>1<span>]</span></a></sup><sup id="cite_ref-Hansen70_22-3" class="reference"><a href="Kernel_(computer_science)#cite_note-Hansen70-22"><span>[</span>22<span>]</span></a></sup> The failure to properly fulfill this separation, is one of the major causes of the lack of substantial innovation in existing operating systems,<sup id="cite_ref-Wulf74_1-6" class="reference"><a href="Kernel_(computer_science)#cite_note-Wulf74-1"><span>[</span>1<span>]</span></a></sup> a problem common in computer architecture.<sup id="cite_ref-Denning80_27-0" class="reference"><a href="Kernel_(computer_science)#cite_note-Denning80-27"><span>[</span>27<span>]</span></a></sup><sup id="cite_ref-Nehmer91_28-0" class="reference"><a href="Kernel_(computer_science)#cite_note-Nehmer91-28"><span>[</span>28<span>]</span></a></sup><sup id="cite_ref-29" class="reference"><a href="Kernel_(computer_science)#cite_note-29"><span>[</span>29<span>]</span></a></sup> The monolithic design is induced by the "kernel mode"/"user mode" architectural approach to protection (technically called <a href="http://en.m.wikipedia.org/wiki/Hierarchical_protection_domains" title="Hierarchical protection domains" class="mw-redirect">hierarchical protection domains</a>), which is common in conventional commercial systems;<sup id="cite_ref-Levy84privilegedmode_30-0" class="reference"><a href="Kernel_(computer_science)#cite_note-Levy84privilegedmode-30"><span>[</span>30<span>]</span></a></sup> in fact, every module needing protection is therefore preferably included into the kernel.<sup id="cite_ref-Levy84privilegedmode_30-1" class="reference"><a href="Kernel_(computer_science)#cite_note-Levy84privilegedmode-30"><span>[</span>30<span>]</span></a></sup> This link between monolithic design and "privileged mode" can be reconducted to the key issue of mechanism-policy separation;<sup id="cite_ref-Wulf74_1-7" class="reference"><a href="Kernel_(computer_science)#cite_note-Wulf74-1"><span>[</span>1<span>]</span></a></sup> in fact the "privileged mode" architectural approach melts together the protection mechanism with the security policies, while the major alternative architectural approach, <a href="http://en.m.wikipedia.org/wiki/Capability-based_addressing" title="Capability-based addressing">capability-based addressing</a>, clearly distinguishes between the two, leading naturally to a microkernel design<sup id="cite_ref-Wulf74_1-8" class="reference"><a href="Kernel_(computer_science)#cite_note-Wulf74-1"><span>[</span>1<span>]</span></a></sup> (see <a href="http://en.m.wikipedia.org/wiki/Separation_of_protection_and_security" title="Separation of protection and security">Separation of protection and security</a>).</p>
<p>While <a href="http://en.m.wikipedia.org/wiki/Monolithic_kernel" title="Monolithic kernel">monolithic kernels</a> execute all of their code in the same address space (<a href="http://en.m.wikipedia.org/wiki/Kernel_space" title="Kernel space" class="mw-redirect">kernel space</a>) <a href="http://en.m.wikipedia.org/wiki/Microkernel" title="Microkernel">microkernels</a> try to run most of their services in user space, aiming to improve maintainability and modularity of the codebase.<sup id="cite_ref-mono-micro_2-1" class="reference"><a href="Kernel_(computer_science)#cite_note-mono-micro-2"><span>[</span>2<span>]</span></a></sup> Most kernels do not fit exactly into one of these categories, but are rather found in between these two designs. These are called <a href="http://en.m.wikipedia.org/wiki/Hybrid_kernel" title="Hybrid kernel">hybrid kernels</a>. More exotic designs such as <a href="http://en.m.wikipedia.org/wiki/Nanokernel" title="Nanokernel" class="mw-redirect">nanokernels</a> and <a href="http://en.m.wikipedia.org/wiki/Exokernel" title="Exokernel">exokernels</a> are available, but are seldom used for production systems. The <a href="http://en.m.wikipedia.org/wiki/Xen" title="Xen">Xen</a> hypervisor, for example, is an exokernel.</p>
<h3> <span class="mw-headline" id="Monolithic_kernels">Monolithic kernels</span>
</h3>
<div class="rellink relarticle mainarticle">Main article: <a href="http://en.m.wikipedia.org/wiki/Monolithic_kernel" title="Monolithic kernel">Monolithic kernel</a>
</div>
<div class="thumb tright">
<div class="thumbinner" style="width:172px;">
<a href="http://en.m.wikipedia.org/wiki/File:Kernel-simple.png" class="image"><img alt="" src="http://upload.wikimedia.org/wikipedia/en/thumb/8/87/Kernel-simple.png/170px-Kernel-simple.png" width="170" height="208" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/en/thumb/8/87/Kernel-simple.png/255px-Kernel-simple.png 1.5x, //upload.wikimedia.org/wikipedia/en/8/87/Kernel-simple.png 2x"></a>
<div class="thumbcaption">

Diagram of a monolithic kernel</div>
</div>
</div>
<p>In a monolithic kernel, all OS services run along with the main kernel thread, thus also residing in the same memory area. This approach provides rich and powerful hardware access. Some developers, such as <a href="Unix" title="Unix">UNIX</a> developer <a href="Ken_Thompson" title="Ken Thompson">Ken Thompson</a>, maintain that it is "easier to implement a monolithic kernel"<sup id="cite_ref-Linuxisobsoletedebate_31-0" class="reference"><a href="Kernel_(computer_science)#cite_note-Linuxisobsoletedebate-31"><span>[</span>31<span>]</span></a></sup> than microkernels. The main disadvantages of monolithic kernels are the dependencies between system components — a bug in a device driver might crash the entire system — and the fact that large kernels can become very difficult to maintain.</p>
<p>Monolithic kernels, which have traditionally been used by Unix-like operating systems, contain all the operating system core functions and the device drivers (small programs that allow the operating system to interact with hardware devices, such as disk drives, video cards and printers). This is the traditional design of UNIX systems. A monolithic kernel is one single program that contains all of the code necessary to perform every kernel related task. Every part which is to be accessed by most programs which cannot be put in a library is in the kernel space: Device drivers, Scheduler, Memory handling, File systems, Network stacks. Many system calls are provided to applications, to allow them to access all those services. A monolithic kernel, while initially loaded with subsystems that may not be needed can be tuned to a point where it is as fast as or faster than the one that was specifically designed for the hardware, although more in a general sense. Modern monolithic kernels, such as those of <a href="http://en.m.wikipedia.org/wiki/Linux" title="Linux">Linux</a> and <a href="http://en.m.wikipedia.org/wiki/FreeBSD" title="FreeBSD">FreeBSD</a>, both of which fall into the category of Unix-like operating systems, feature the ability to load modules at runtime, thereby allowing easy extension of the kernel's capabilities as required, while helping to minimize the amount of code running in kernel space. In the monolithic kernel, some advantages hinge on these points:</p>
<ul>
<li>Since there is less software involved it is faster.</li>
<li>As it is one single piece of software it should be smaller both in source and compiled forms.</li>
<li>Less code generally means fewer bugs which can translate to fewer security problems.</li>
</ul>
<p>Most work in the monolithic kernel is done via system calls. These are interfaces, usually kept in a tabular structure, that access some subsystem within the kernel such as disk operations. Essentially calls are made within programs and a checked copy of the request is passed through the system call. Hence, not far to travel at all. The monolithic Linux kernel can be made extremely small not only because of its ability to dynamically load modules but also because of its ease of customization. In fact, there are some versions that are small enough to fit together with a large number of utilities and other programs on a single floppy disk and still provide a fully functional operating system (one of the most popular of which is <a href="http://en.m.wikipedia.org/wiki/MuLinux" title="MuLinux">muLinux</a>). This ability to miniaturize its kernel has also led to a rapid growth in the use of Linux in <a href="Embedded_systems" title="Embedded systems" class="mw-redirect">embedded systems</a>.</p>
<p>These types of kernels consist of the core functions of the operating system and the device drivers with the ability to load modules at runtime. They provide rich and powerful abstractions of the underlying hardware. They provide a small set of simple hardware abstractions and use applications called servers to provide more functionality. This particular approach defines a high-level virtual interface over the hardware, with a set of system calls to implement operating system services such as process management, concurrency and memory management in several modules that run in supervisor mode. This design has several flaws and limitations:</p>
<ul>
<li>Coding in kernel can be challenging, in part because you cannot use common libraries (like a full-featured <a href="C_standard_library" title="C standard library">libc</a>), and because you need to use a source-level debugger like <a href="http://en.m.wikipedia.org/wiki/GNU_Debugger" title="GNU Debugger">gdb</a>. Rebooting the computer is often needed. This is not just a problem of convenience to the developers. When debugging is harder, and as difficulties become stronger, it becomes more likely that code will be "buggier".</li>
<li>Bugs in one part of the kernel have strong side effects, since every function in the kernel has all the privileges, a bug in one function can corrupt data structure of another, totally unrelated part of the kernel, or of any running program.</li>
<li>Kernels often become very huge, and difficult to maintain.</li>
<li>Even if the modules servicing these operations are separate from the whole, the code integration is tight and difficult to do correctly.</li>
<li>Since the modules run in the same <a href="http://en.m.wikipedia.org/wiki/Address_space" title="Address space">address space</a>, a bug can bring down the entire system.</li>
<li>The disadvantage cited for monolithic kernels is that they are not portable; that is, they must be rewritten for each new architecture that the operating system is to be used on.</li>
</ul>
<div class="thumb tright">
<div class="thumbinner" style="width:262px;">
<a href="http://en.m.wikipedia.org/wiki/File:Kernel-microkernel.svg" class="image"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Kernel-microkernel.svg/260px-Kernel-microkernel.svg.png" width="260" height="195" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Kernel-microkernel.svg/390px-Kernel-microkernel.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Kernel-microkernel.svg/520px-Kernel-microkernel.svg.png 2x"></a>
<div class="thumbcaption">

In the <a href="http://en.m.wikipedia.org/wiki/Microkernel" title="Microkernel">microkernel</a> approach, the kernel itself only provides basic functionality that allows the execution of <a href="http://en.m.wikipedia.org/wiki/Server_(computing)" title="Server (computing)">servers</a>, separate programs that assume former kernel functions, such as device drivers, GUI servers, etc.</div>
</div>
</div>
<h3> <span class="mw-headline" id="Microkernels">Microkernels</span>
</h3>
<div class="rellink relarticle mainarticle">Main article: <a href="http://en.m.wikipedia.org/wiki/Microkernel" title="Microkernel">Microkernel</a>
</div>
<p>Microkernel (also abbreviated μK or uK) is the term describing an approach to Operating System design by which the functionality of the system is moved out of the traditional "kernel", into a set of "servers" that communicate through a "minimal" kernel, leaving as little as possible in "system space" and as much as possible in "user space". A microkernel that is designed for a specific platform or device is only ever going to have what it needs to operate. The microkernel approach consists of defining a simple abstraction over the hardware, with a set of primitives or <a href="http://en.m.wikipedia.org/wiki/System_call" title="System call">system calls</a> to implement minimal OS services such as <a href="http://en.m.wikipedia.org/wiki/Memory_management" title="Memory management">memory management</a>, <a href="http://en.m.wikipedia.org/wiki/Computer_multitasking" title="Computer multitasking">multitasking</a>, and <a href="http://en.m.wikipedia.org/wiki/Inter-process_communication" title="Inter-process communication">inter-process communication</a>. Other services, including those normally provided by the kernel, such as <a href="http://en.m.wikipedia.org/wiki/Computer_networking" title="Computer networking" class="mw-redirect">networking</a>, are implemented in user-space programs, referred to as <i>servers</i>. Microkernels are easier to maintain than monolithic kernels, but the large number of system calls and <a href="http://en.m.wikipedia.org/wiki/Context_switch" title="Context switch">context switches</a> might slow down the system because they typically generate more overhead than plain function calls.</p>
<p>Only parts which really require being in a privileged mode are in kernel space: IPC (Inter-Process Communication), Basic scheduler, or scheduling primitives, Basic memory handling, Basic I/O primitives. Many critical parts are now running in user space: The complete scheduler, Memory handling, File systems, and Network stacks. Micro kernels were invented as a reaction to traditional "monolithic" kernel design, whereby all system functionality was put in a one static program running in a special "system" mode of the processor. In the microkernel, only the most fundamental of tasks are performed such as being able to access some (not necessarily all) of the hardware, manage memory and coordinate message passing between the processes. Some systems that use micro kernels are QNX and the HURD. In the case of QNX and <a href="http://en.m.wikipedia.org/wiki/GNU_Hurd" title="GNU Hurd">Hurd</a> user sessions can be entire snapshots of the system itself or views as it is referred to. The very essence of the microkernel architecture illustrates some of its advantages:</p>
<ul>
<li>Maintenance is generally easier.</li>
<li>Patches can be tested in a separate instance, and then swapped in to take over a production instance.</li>
<li>Rapid development time and new software can be tested without having to reboot the kernel.</li>
<li>More persistence in general, if one instance goes hay-wire, it is often possible to substitute it with an operational mirror.</li>
</ul>
<p>Most micro kernels use a message passing system of some sort to handle requests from one server to another. The message passing system generally operates on a port basis with the microkernel. As an example, if a request for more memory is sent, a port is opened with the microkernel and the request sent through. Once within the microkernel, the steps are similar to system calls. The rationale was that it would bring modularity in the system architecture, which would entail a cleaner system, easier to debug or dynamically modify, customizable to users' needs, and more performing. They are part of the operating systems like AIX, BeOS, Hurd, Mach, Mac OS X, MINIX, QNX. Etc. Although micro kernels are very small by themselves, in combination with all their required auxiliary code they are, in fact, often larger than monolithic kernels. Advocates of monolithic kernels also point out that the two-tiered structure of microkernel systems, in which most of the operating system does not interact directly with the hardware, creates a not-insignificant cost in terms of system efficiency. These types of kernels normally provide only the minimal services such as defining memory address spaces, Inter-process communication (IPC) and the process management. The other functions such as running the hardware processes are not handled directly by micro kernels. Proponents of micro kernels point out those monolithic kernels have the disadvantage that an error in the kernel can cause the entire system to crash. However, with a microkernel, if a kernel process crashes, it is still possible to prevent a crash of the system as a whole by merely restarting the service that caused the error. Although this sounds sensible, it is questionable how important it is in reality, because operating systems with monolithic kernels such as Linux have become extremely stable and can run for years without crashing.</p>
<p>Other services provided by the kernel such as networking are implemented in user-space programs referred to as <i>servers</i>. Servers allow the operating system to be modified by simply starting and stopping programs. For a machine without networking support, for instance, the networking server is not started. The task of moving in and out of the kernel to move data between the various applications and servers creates overhead which is detrimental to the efficiency of micro kernels in comparison with monolithic kernels.</p>
<p>Disadvantages in the microkernel exist however. Some are:</p>
<ul>
<li>Larger running memory footprint</li>
<li>More software for interfacing is required, there is a potential for performance loss.</li>
<li>Messaging bugs can be harder to fix due to the longer trip they have to take versus the one off copy in a monolithic kernel.</li>
<li>Process management in general can be very complicated.</li>
<li>The disadvantages for micro kernels are extremely context based. As an example, they work well for small single purpose (and critical) systems because if not many processes need to run, then the complications of process management are effectively mitigated.</li>
</ul>
<p>A microkernel allows the implementation of the remaining part of the operating system as a normal application program written in a <a href="http://en.m.wikipedia.org/wiki/High-level_language" title="High-level language" class="mw-redirect">high-level language</a>, and the use of different operating systems on top of the same unchanged kernel.<sup id="cite_ref-Hansen70_22-4" class="reference"><a href="Kernel_(computer_science)#cite_note-Hansen70-22"><span>[</span>22<span>]</span></a></sup> It is also possible to dynamically switch among operating systems and to have more than one active simultaneously.<sup id="cite_ref-Hansen70_22-5" class="reference"><a href="Kernel_(computer_science)#cite_note-Hansen70-22"><span>[</span>22<span>]</span></a></sup></p>
<h3> <span class="mw-headline" id="Monolithic_kernels_vs._microkernels">Monolithic kernels vs. microkernels</span>
</h3>
<p>As the computer kernel grows, a number of problems become evident. One of the most obvious is that the <a href="http://en.m.wikipedia.org/wiki/Memory_footprint" title="Memory footprint">memory footprint</a> increases. This is mitigated to some degree by perfecting the <a href="http://en.m.wikipedia.org/wiki/Virtual_memory" title="Virtual memory">virtual memory</a> system, but not all <a href="Computer_architecture" title="Computer architecture">computer architectures</a> have virtual memory support.<sup id="cite_ref-32" class="reference"><a href="Kernel_(computer_science)#cite_note-32"><span>[</span>32<span>]</span></a></sup> To reduce the kernel's footprint, extensive editing has to be performed to carefully remove unneeded code, which can be very difficult with non-obvious interdependencies between parts of a kernel with millions of lines of code.</p>
<p>By the early 1990s, due to the various shortcomings of monolithic kernels versus microkernels, monolithic kernels were considered obsolete by virtually all operating system researchers. As a result, the design of <a href="http://en.m.wikipedia.org/wiki/Linux_(kernel)" title="Linux (kernel)" class="mw-redirect">Linux</a> as a monolithic kernel rather than a microkernel was the topic of a famous debate between <a href="http://en.m.wikipedia.org/wiki/Linus_Torvalds" title="Linus Torvalds">Linus Torvalds</a> and <a href="http://en.m.wikipedia.org/wiki/Andrew_S._Tanenbaum" title="Andrew S. Tanenbaum">Andrew Tanenbaum</a>.<sup id="cite_ref-TorvaldsTanenbaum_33-0" class="reference"><a href="Kernel_(computer_science)#cite_note-TorvaldsTanenbaum-33"><span>[</span>33<span>]</span></a></sup> There is merit on both sides of the argument presented in the <a href="http://en.m.wikipedia.org/wiki/Tanenbaum%E2%80%93Torvalds_debate" title="Tanenbaum–Torvalds debate">Tanenbaum–Torvalds debate</a>.</p>
<h4> <span class="mw-headline" id="Performances">Performances</span>
</h4>
<p><a href="http://en.m.wikipedia.org/wiki/Monolithic_kernel" title="Monolithic kernel">Monolithic kernels</a> are designed to have all of their code in the same address space (<a href="http://en.m.wikipedia.org/wiki/Kernel_space" title="Kernel space" class="mw-redirect">kernel space</a>), which some developers argue is necessary to increase the performance of the system.<sup id="cite_ref-MatthewRussell_34-0" class="reference"><a href="Kernel_(computer_science)#cite_note-MatthewRussell-34"><span>[</span>34<span>]</span></a></sup> Some developers also maintain that monolithic systems are extremely efficient if well-written.<sup id="cite_ref-MatthewRussell_34-1" class="reference"><a href="Kernel_(computer_science)#cite_note-MatthewRussell-34"><span>[</span>34<span>]</span></a></sup> The monolithic model tends to be more efficient<sup class="Template-Fact" style="white-space:nowrap;">[<i><a href="http://en.m.wikipedia.org/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources from July 2007">citation needed</span></a></i>]</sup> through the use of shared kernel memory, rather than the slower IPC system of microkernel designs, which is typically based on <a href="http://en.m.wikipedia.org/wiki/Message_passing" title="Message passing">message passing</a>.<sup class="Template-Fact" style="white-space:nowrap;">[<i><a href="http://en.m.wikipedia.org/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources from July 2007">citation needed</span></a></i>]</sup></p>
<p>The performance of microkernels constructed in the 1980s the year in which it started and early 1990s was poor.<sup id="cite_ref-Liedtke95_35-0" class="reference"><a href="Kernel_(computer_science)#cite_note-Liedtke95-35"><span>[</span>35<span>]</span></a></sup><sup id="cite_ref-Hartig97_36-0" class="reference"><a href="Kernel_(computer_science)#cite_note-Hartig97-36"><span>[</span>36<span>]</span></a></sup> Studies that empirically measured the performance of these microkernels did not analyze the reasons of such inefficiency.<sup id="cite_ref-Liedtke95_35-1" class="reference"><a href="Kernel_(computer_science)#cite_note-Liedtke95-35"><span>[</span>35<span>]</span></a></sup> The explanations of this data were left to "folklore", with the assumption that they were due to the increased frequency of switches from "kernel-mode" to "user-mode",<sup id="cite_ref-Liedtke95_35-2" class="reference"><a href="Kernel_(computer_science)#cite_note-Liedtke95-35"><span>[</span>35<span>]</span></a></sup> to the increased frequency of <a href="http://en.m.wikipedia.org/wiki/Inter-process_communication" title="Inter-process communication">inter-process communication</a><sup id="cite_ref-Liedtke95_35-3" class="reference"><a href="Kernel_(computer_science)#cite_note-Liedtke95-35"><span>[</span>35<span>]</span></a></sup> and to the increased frequency of <a href="http://en.m.wikipedia.org/wiki/Context_switch" title="Context switch">context switches</a>.<sup id="cite_ref-Liedtke95_35-4" class="reference"><a href="Kernel_(computer_science)#cite_note-Liedtke95-35"><span>[</span>35<span>]</span></a></sup></p>
<p>In fact, as guessed in 1995, the reasons for the poor performance of microkernels might as well have been: (1) an actual inefficiency of the whole microkernel <i>approach</i>, (2) the particular <i>concepts</i> implemented in those microkernels, and (3) the particular <i>implementation</i> of those concepts.<sup id="cite_ref-Liedtke95_35-5" class="reference"><a href="Kernel_(computer_science)#cite_note-Liedtke95-35"><span>[</span>35<span>]</span></a></sup> Therefore it remained to be studied if the solution to build an efficient microkernel was, unlike previous attempts, to apply the correct construction techniques.<sup id="cite_ref-Liedtke95_35-6" class="reference"><a href="Kernel_(computer_science)#cite_note-Liedtke95-35"><span>[</span>35<span>]</span></a></sup></p>
<p>On the other end, the <a href="http://en.m.wikipedia.org/wiki/Hierarchical_protection_domains" title="Hierarchical protection domains" class="mw-redirect">hierarchical protection domains</a> architecture that leads to the design of a monolithic kernel<sup id="cite_ref-Levy84privilegedmode_30-2" class="reference"><a href="Kernel_(computer_science)#cite_note-Levy84privilegedmode-30"><span>[</span>30<span>]</span></a></sup> has a significant performance drawback each time there's an interaction between different levels of protection (i.e. when a process has to manipulate a data structure both in 'user mode' and 'supervisor mode'), since this requires message copying <a href="Call-by-value" title="Call-by-value" class="mw-redirect">by value</a>.<sup id="cite_ref-Hansen73SupervisorMode_37-0" class="reference"><a href="Kernel_(computer_science)#cite_note-Hansen73SupervisorMode-37"><span>[</span>37<span>]</span></a></sup></p>
<p>By the mid-1990s, most researchers had abandoned the belief that careful tuning could reduce this overhead dramatically,<sup class="Template-Fact" style="white-space:nowrap;">[<i><a href="http://en.m.wikipedia.org/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources from July 2007">citation needed</span></a></i>]</sup> but recently, newer microkernels, optimized for performance, such as <a href="http://en.m.wikipedia.org/wiki/L4_microkernel_family" title="L4 microkernel family">L4</a><sup id="cite_ref-l4_38-0" class="reference"><a href="Kernel_(computer_science)#cite_note-l4-38"><span>[</span>38<span>]</span></a></sup> and <a href="http://en.m.wikipedia.org/wiki/K42" title="K42">K42</a> have addressed these problems.<sup class="noprint Inline-Template" style="white-space:nowrap;">[<i><a href="Wikipedia:Verifiability" title="Wikipedia:Verifiability"><span title="The material in the vicinity of this tag needs to be fact-checked with the cited source(s) from July 2007">verification needed</span></a></i>]</sup></p>
<div class="thumb tright">
<div class="thumbinner" style="width:262px;">
<a href="http://en.m.wikipedia.org/wiki/File:Kernel-hybrid.svg" class="image"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/39/Kernel-hybrid.svg/260px-Kernel-hybrid.svg.png" width="260" height="195" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/3/39/Kernel-hybrid.svg/390px-Kernel-hybrid.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/3/39/Kernel-hybrid.svg/520px-Kernel-hybrid.svg.png 2x"></a>
<div class="thumbcaption">

The <a href="http://en.m.wikipedia.org/wiki/Hybrid_kernel" title="Hybrid kernel">hybrid kernel</a> approach combines the speed and simpler design of a monolithic kernel with the modularity and execution safety of a microkernel.</div>
</div>
</div>
<h3> <span class="mw-headline" id="Hybrid_.28or.29_Modular_kernels">Hybrid (or) Modular kernels</span>
</h3>
<div class="rellink relarticle mainarticle">Main article: <a href="http://en.m.wikipedia.org/wiki/Hybrid_kernel" title="Hybrid kernel">Hybrid kernel</a>
</div>
<p>Hybrid kernels are used in most commercial operating systems such as <a href="http://en.m.wikipedia.org/wiki/Microsoft_Windows" title="Microsoft Windows">Microsoft Windows</a> NT, 2000, XP, Vista, and 7. <a href="http://en.m.wikipedia.org/wiki/Apple_Inc" title="Apple Inc" class="mw-redirect">Apple Inc</a>'s own <a href="http://en.m.wikipedia.org/wiki/Mac_OS_X" title="Mac OS X" class="mw-redirect">Mac OS X</a> uses a hybrid kernel called <a href="http://en.m.wikipedia.org/wiki/XNU" title="XNU">XNU</a> which is based upon code from <a href="http://en.m.wikipedia.org/wiki/Carnegie_Mellon" title="Carnegie Mellon" class="mw-redirect">Carnegie Mellon</a>'s <a href="http://en.m.wikipedia.org/wiki/Mach_kernel" title="Mach kernel" class="mw-redirect">Mach kernel</a> and <a href="http://en.m.wikipedia.org/wiki/FreeBSD" title="FreeBSD">FreeBSD</a>'s <a href="http://en.m.wikipedia.org/wiki/Monolithic_kernel" title="Monolithic kernel">monolithic kernel</a>. They are similar to micro kernels, except they include some additional code in kernel-space to increase performance. These kernels represent a compromise that was implemented by some developers before it was demonstrated that pure micro kernels can provide high performance. These types of kernels are extensions of micro kernels with some properties of monolithic kernels. Unlike monolithic kernels, these types of kernels are unable to load modules at runtime on their own. Hybrid kernels are micro kernels that have some "non-essential" code in kernel-space in order for the code to run more quickly than it would were it to be in user-space. Hybrid kernels are a compromise between the monolithic and microkernel designs. This implies running some services (such as the <a href="http://en.m.wikipedia.org/wiki/Network_stack" title="Network stack" class="mw-redirect">network stack</a> or the <a href="http://en.m.wikipedia.org/wiki/Filesystem" title="Filesystem" class="mw-redirect">filesystem</a>) in kernel space to reduce the performance overhead of a traditional microkernel, but still running kernel code (such as device drivers) as servers in user space.</p>
<p>Many traditionally monolithic kernels are now at least adding (if not actively exploiting) the module capability. The most well known of these kernels is the Linux kernel. The modular kernel essentially can have parts of it that are built into the core kernel binary or binaries that load into memory on demand. It is important to note that a code tainted module has the potential to destabilize a running kernel. Many people become confused on this point when discussing micro kernels. It is possible to write a driver for a microkernel in a completely separate memory space and test it before "going" live. When a kernel module is loaded, it accesses the monolithic portion's memory space by adding to it what it needs, therefore, opening the doorway to possible pollution. A few advantages to the modular (or) Hybrid kernel are:</p>
<ul>
<li>Faster development time for drivers that can operate from within modules. No reboot required for testing (provided the kernel is not destabilized).</li>
<li>On demand capability versus spending time recompiling a whole kernel for things like new drivers or subsystems.</li>
<li>Faster integration of third party technology (related to development but pertinent unto itself nonetheless).</li>
</ul>
<p>Modules, generally, communicate with the kernel using a module interface of some sort. The interface is generalized (although particular to a given operating system) so it is not always possible to use modules. Often the device drivers may need more flexibility than the module interface affords. Essentially, it is two system calls and often the safety checks that only have to be done once in the monolithic kernel now may be done twice. Some of the disadvantages of the modular approach are:</p>
<ul>
<li>With more interfaces to pass through, the possibility of increased bugs exists (which implies more security holes).</li>
<li>Maintaining modules can be confusing for some administrators when dealing with problems like symbol differences.</li>
</ul>
<h3> <span class="mw-headline" id="Nanokernels">Nanokernels</span>
</h3>
<div class="rellink relarticle mainarticle">Main article: <a href="http://en.m.wikipedia.org/wiki/Nanokernel" title="Nanokernel" class="mw-redirect">Nanokernel</a>
</div>
<p>A nanokernel delegates virtually all services — including even the most basic ones like <a href="http://en.m.wikipedia.org/wiki/Programmable_Interrupt_Controller" title="Programmable Interrupt Controller">interrupt controllers</a> or the <a href="http://en.m.wikipedia.org/wiki/Timer" title="Timer">timer</a> — to <a href="http://en.m.wikipedia.org/wiki/Device_driver" title="Device driver">device drivers</a> to make the kernel memory requirement even smaller than a traditional microkernel.<sup id="cite_ref-39" class="reference"><a href="Kernel_(computer_science)#cite_note-39"><span>[</span>39<span>]</span></a></sup></p>
<h3> <span class="mw-headline" id="Exokernels">Exokernels</span>
</h3>
<div class="rellink relarticle mainarticle">Main article: <a href="http://en.m.wikipedia.org/wiki/Exokernel" title="Exokernel">Exokernel</a>
</div>
<p>Exokernels are a still experimental approach to operating system design. They differ from the other types of kernels in that their functionality is limited to the protection and multiplexing of the raw hardware, providing no hardware abstractions on top of which to develop applications. This separation of hardware protection from hardware management enables application developers to determine how to make the most efficient use of the available hardware for each specific program.</p>
<p>Exokernels in themselves are extremely small. However, they are accompanied by library operating systems, providing application developers with the functionalities of a conventional operating system. A major advantage of exokernel-based systems is that they can incorporate multiple library operating systems, each exporting a different <a href="http://en.m.wikipedia.org/wiki/API" title="API" class="mw-redirect">API</a>, for example one for high level <a href="http://en.m.wikipedia.org/wiki/User_Interface" title="User Interface" class="mw-redirect">UI</a> development and one for <a href="http://en.m.wikipedia.org/wiki/Real-time_computing" title="Real-time computing">real-time</a> control.</p>
<h2> <span class="mw-headline" id="History_of_kernel_development">History of kernel development</span>
</h2>
<h3> <span class="mw-headline" id="Early_operating_system_kernels">Early operating system kernels</span>
</h3>
<div class="rellink relarticle mainarticle">Main article: <a href="http://en.m.wikipedia.org/wiki/History_of_operating_systems" title="History of operating systems">History of operating systems</a>
</div>
<p>Strictly speaking, an operating system (and thus, a kernel) is not <i>required</i> to run a computer. Programs can be directly loaded and executed on the "bare metal" machine, provided that the authors of those programs are willing to work without any hardware abstraction or operating system support. Most early computers operated this way during the 1950s and early 1960s, which were reset and reloaded between the execution of different programs. Eventually, small ancillary programs such as <a href="http://en.m.wikipedia.org/wiki/Program_loader" title="Program loader" class="mw-redirect">program loaders</a> and <a href="http://en.m.wikipedia.org/wiki/Debugger" title="Debugger">debuggers</a> were left in memory between runs, or loaded from <a href="http://en.m.wikipedia.org/wiki/Read-only_memory" title="Read-only memory">ROM</a>. As these were developed, they formed the basis of what became early operating system kernels. The <a href="http://en.m.wikipedia.org/wiki/Bare_metal" title="Bare metal" class="mw-redirect">"bare metal"</a> approach is still used today on some <a href="http://en.m.wikipedia.org/wiki/Video_game_console" title="Video game console">video game consoles</a> and <a href="Embedded_system" title="Embedded system">embedded systems</a>,<sup id="cite_ref-Ball2002_40-0" class="reference"><a href="Kernel_(computer_science)#cite_note-Ball2002-40"><span>[</span>40<span>]</span></a></sup> but in general, newer computers use modern operating systems and kernels.</p>
<p>In 1969 the <a href="http://en.m.wikipedia.org/wiki/RC_4000_Multiprogramming_System" title="RC 4000 Multiprogramming System">RC 4000 Multiprogramming System</a> introduced the system design philosophy of a small nucleus "upon which operating systems for different purposes could be built in an orderly manner",<sup id="cite_ref-Hansen2001RC4k_41-0" class="reference"><a href="Kernel_(computer_science)#cite_note-Hansen2001RC4k-41"><span>[</span>41<span>]</span></a></sup> what would be called the microkernel approach.</p>
<h3> <span class="mw-headline" id="Time-sharing_operating_systems">Time-sharing operating systems</span>
</h3>
<div class="rellink relarticle mainarticle">Main article: <a href="http://en.m.wikipedia.org/wiki/Time-sharing" title="Time-sharing">Time-sharing</a>
</div>
<p>In the decade preceding <a href="Unix" title="Unix">Unix</a>, computers had grown enormously in power — to the point where computer operators were looking for new ways to get people to use the spare time on their machines. One of the major developments during this era was <a href="http://en.m.wikipedia.org/wiki/Time-sharing" title="Time-sharing">time-sharing</a>, whereby a number of users would get small slices of computer time, at a rate at which it appeared they were each connected to their own, slower, machine.<sup id="cite_ref-42" class="reference"><a href="Kernel_(computer_science)#cite_note-42"><span>[</span>42<span>]</span></a></sup></p>
<p>The development of time-sharing systems led to a number of problems. One was that users, particularly at universities where the systems were being developed, seemed to want to <a href="http://en.m.wikipedia.org/wiki/Hacker_(computer_security)" title="Hacker (computer security)">hack</a> the system to get more <a href="http://en.m.wikipedia.org/wiki/Central_processing_unit" title="Central processing unit">CPU</a> time. For this reason, <a href="http://en.m.wikipedia.org/wiki/Computer_security" title="Computer security">security</a> and <a href="http://en.m.wikipedia.org/wiki/Access_control" title="Access control">access control</a> became a major focus of the <a href="Multics" title="Multics">Multics</a> project in 1965.<sup id="cite_ref-43" class="reference"><a href="Kernel_(computer_science)#cite_note-43"><span>[</span>43<span>]</span></a></sup> Another ongoing issue was properly handling computing resources: users spent most of their time staring at the screen and thinking instead of actually using the resources of the computer, and a time-sharing system should give the CPU time to an active user during these periods. Finally, the systems typically offered a <a href="http://en.m.wikipedia.org/wiki/Memory_hierarchy" title="Memory hierarchy">memory hierarchy</a> several layers deep, and partitioning this expensive resource led to major developments in <a href="http://en.m.wikipedia.org/wiki/Virtual_memory" title="Virtual memory">virtual memory</a> systems.</p>
<h3> <span class="mw-headline" id="Amiga">Amiga</span>
</h3>
<div class="rellink relarticle mainarticle">Main article: <a href="http://en.m.wikipedia.org/wiki/AmigaOS" title="AmigaOS">AmigaOS</a>
</div>
<p>The <a href="http://en.m.wikipedia.org/wiki/Commodore_International" title="Commodore International">Commodore</a> <a href="http://en.m.wikipedia.org/wiki/Amiga" title="Amiga">Amiga</a> was released in 1985, and was among the first (and certainly most successful) home computers to feature a hybrid architecture.<sup class="Template-Fact" style="white-space:nowrap;">[<i><a href="http://en.m.wikipedia.org/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources from July 2011">citation needed</span></a></i>]</sup> The Amiga's kernel executive component, <i>exec.library</i>, uses microkernel message passing design but there are other kernel components, like <i>graphics.library</i>, that had a direct access to the hardware. There is no memory protection and the kernel is almost always running in a user mode. Only special actions are executed in kernel mode and user mode applications can ask operating system to execute their code in kernel mode.</p>
<h3> <span class="mw-headline" id="Unix">Unix</span>
</h3>
<div class="rellink relarticle mainarticle">Main article: <a href="Unix" title="Unix">Unix</a>
</div>
<div class="thumb tright">
<div class="thumbinner" style="width:302px;">
<a href="http://en.m.wikipedia.org/wiki/File:Unix-history.svg" class="image"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/1/11/Unix-history.svg/300px-Unix-history.svg.png" width="300" height="496" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/1/11/Unix-history.svg/450px-Unix-history.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/1/11/Unix-history.svg/600px-Unix-history.svg.png 2x"></a>
<div class="thumbcaption">

A diagram of the predecessor/successor family relationship for <a href="Unix-like" title="Unix-like">Unix-like</a> systems.</div>
</div>
</div>
<p>During the design phase of <a href="Unix" title="Unix">Unix</a>, programmers decided to model every high-level <a href="http://en.m.wikipedia.org/wiki/Device_file" title="Device file">device as a file</a>, because they believed the purpose of <a href="http://en.m.wikipedia.org/wiki/Computation" title="Computation">computation</a> was <a href="http://en.m.wikipedia.org/wiki/Data_transformation" title="Data transformation">data transformation</a>.<sup id="cite_ref-unix_44-0" class="reference"><a href="Kernel_(computer_science)#cite_note-unix-44"><span>[</span>44<span>]</span></a></sup></p>
<p>For instance, <a href="http://en.m.wikipedia.org/wiki/Printer_(computing)" title="Printer (computing)">printers</a> were represented as a "file" at a known location — when data was copied to the file, it printed out. Other systems, to provide a similar functionality, tended to virtualize devices at a lower level — that is, both devices <i>and</i> files would be instances of some <a href="http://en.m.wikipedia.org/wiki/Loadable_kernel_module" title="Loadable kernel module">lower level</a> concept. <a href="http://en.m.wikipedia.org/wiki/Virtualizing" title="Virtualizing" class="mw-redirect">Virtualizing</a> the system at the file level allowed users to manipulate the entire system using their existing <a href="http://en.m.wikipedia.org/wiki/File_management" title="File management" class="mw-redirect">file management</a> utilities and concepts, dramatically simplifying operation. As an extension of the same paradigm, Unix allows programmers to manipulate files using a series of small programs, using the concept of <a href="http://en.m.wikipedia.org/wiki/Pipeline_(Unix)" title="Pipeline (Unix)">pipes</a>, which allowed users to complete operations in stages, feeding a file through a chain of single-purpose tools. Although the end result was the same, using smaller programs in this way dramatically increased flexibility as well as ease of development and use, allowing the user to modify their workflow by adding or removing a program from the chain.</p>
<p>In the Unix model, the <i>Operating System</i> consists of two parts; first, the huge collection of utility programs that drive most operations, the other the kernel that runs the programs.<sup id="cite_ref-unix_44-1" class="reference"><a href="Kernel_(computer_science)#cite_note-unix-44"><span>[</span>44<span>]</span></a></sup> Under Unix, from a programming standpoint, the distinction between the two is fairly thin; the kernel is a program, running in supervisor mode,<sup id="cite_ref-supervisor_45-0" class="reference"><a href="Kernel_(computer_science)#cite_note-supervisor-45"><span>[</span>45<span>]</span></a></sup> that acts as a program loader and supervisor for the small utility programs making up the rest of the system, and to provide <a href="http://en.m.wikipedia.org/wiki/Lock_(software_engineering)" title="Lock (software engineering)" class="mw-redirect">locking</a> and <a href="Input/output" title="Input/output">I/O</a> services for these programs; beyond that, the kernel didn't intervene at all in <a href="http://en.m.wikipedia.org/wiki/User_space" title="User space">user space</a>.</p>
<p>Over the years the computing model changed, and Unix's treatment of <a href="http://en.m.wikipedia.org/wiki/Everything_is_a_file" title="Everything is a file">everything as a file</a> or byte stream no longer was as universally applicable as it was before. Although a <a href="http://en.m.wikipedia.org/wiki/Computer_terminal" title="Computer terminal">terminal</a> could be treated as a file or a byte stream, which is printed to or read from, the same did not seem to be true for a <a href="Graphical_user_interface" title="Graphical user interface">graphical user interface</a>. <a href="http://en.m.wikipedia.org/wiki/Computer_networking" title="Computer networking" class="mw-redirect">Networking</a> posed another problem. Even if network communication can be compared to file access, the low-level packet-oriented architecture dealt with discrete chunks of data and not with whole files. As the capability of computers grew, Unix became increasingly cluttered with code. It is also because the modularity of the Unix kernel is extensively scalable.<sup id="cite_ref-46" class="reference"><a href="Kernel_(computer_science)#cite_note-46"><span>[</span>46<span>]</span></a></sup> While kernels might have had 100,000 <a href="http://en.m.wikipedia.org/wiki/Source_lines_of_code" title="Source lines of code">lines of code</a> in the seventies and eighties, kernels of modern Unix successors like <a href="http://en.m.wikipedia.org/wiki/Linux_kernel" title="Linux kernel">Linux</a> have more than 13 million lines.<sup id="cite_ref-47" class="reference"><a href="Kernel_(computer_science)#cite_note-47"><span>[</span>47<span>]</span></a></sup></p>
<p>Modern Unix-derivatives are generally based on module-loading monolithic kernels. Examples of this are the <a href="http://en.m.wikipedia.org/wiki/Linux_kernel" title="Linux kernel">Linux kernel</a> in its many <a href="http://en.m.wikipedia.org/wiki/Linux_distributions" title="Linux distributions" class="mw-redirect">distributions</a> as well as the <a href="http://en.m.wikipedia.org/wiki/Berkeley_software_distribution" title="Berkeley software distribution" class="mw-redirect">Berkeley software distribution</a> variant kernels such as <a href="http://en.m.wikipedia.org/wiki/FreeBSD" title="FreeBSD">FreeBSD</a>, <a href="http://en.m.wikipedia.org/wiki/DragonflyBSD" title="DragonflyBSD" class="mw-redirect">DragonflyBSD</a>, <a href="http://en.m.wikipedia.org/wiki/OpenBSD" title="OpenBSD">OpenBSD</a>, <a href="http://en.m.wikipedia.org/wiki/NetBSD" title="NetBSD">NetBSD</a>, and <a href="http://en.m.wikipedia.org/wiki/Mac_OS_X" title="Mac OS X" class="mw-redirect">Mac OS X</a>. Apart from these alternatives, amateur developers maintain an active <a href="http://en.m.wikipedia.org/wiki/Operating_system_development" title="Operating system development" class="mw-redirect">operating system development community</a>, populated by self-written hobby kernels which mostly end up sharing many features with Linux, FreeBSD, DragonflyBSD, OpenBSD or NetBSD kernels and/or being compatible with them.<sup id="cite_ref-48" class="reference"><a href="Kernel_(computer_science)#cite_note-48"><span>[</span>48<span>]</span></a></sup></p>
<h3> <span class="mw-headline" id="Mac_OS">Mac OS</span>
</h3>
<div class="rellink relarticle mainarticle">Main article: <a href="http://en.m.wikipedia.org/wiki/History_of_Mac_OS" title="History of Mac OS">History of Mac OS</a>
</div>
<p><a href="http://en.m.wikipedia.org/wiki/Apple_Computer" title="Apple Computer" class="mw-redirect">Apple Computer</a> first launched <a href="http://en.m.wikipedia.org/wiki/Mac_OS" title="Mac OS">Mac OS</a> in 1984, bundled with its <a href="http://en.m.wikipedia.org/wiki/Apple_Macintosh" title="Apple Macintosh" class="mw-redirect">Apple Macintosh</a> <a href="http://en.m.wikipedia.org/wiki/Personal_computer" title="Personal computer">personal computer</a>. Apple moved to a nanokernel design in Mac OS 8.6. Against this, <a href="http://en.m.wikipedia.org/wiki/Mac_OS_X" title="Mac OS X" class="mw-redirect">Mac OS X</a> is based on <a href="http://en.m.wikipedia.org/wiki/Darwin_(operating_system)" title="Darwin (operating system)">Darwin</a>, which uses a hybrid kernel called <a href="http://en.m.wikipedia.org/wiki/XNU" title="XNU">XNU</a>, which was created combining the <a href="http://en.m.wikipedia.org/wiki/BSD#4.3BSD" title="BSD" class="mw-redirect">4.3BSD</a> kernel and the <a href="http://en.m.wikipedia.org/wiki/Mach_(kernel)" title="Mach (kernel)">Mach kernel</a>.<sup id="cite_ref-49" class="reference"><a href="Kernel_(computer_science)#cite_note-49"><span>[</span>49<span>]</span></a></sup></p>
<h3> <span class="mw-headline" id="Microsoft_Windows">Microsoft Windows</span>
</h3>
<div class="rellink relarticle mainarticle">Main article: <a href="http://en.m.wikipedia.org/wiki/History_of_Microsoft_Windows" title="History of Microsoft Windows">History of Microsoft Windows</a>
</div>
<p><a href="http://en.m.wikipedia.org/wiki/Microsoft_Windows" title="Microsoft Windows">Microsoft Windows</a> was first released in 1985 as an add-on to <a href="http://en.m.wikipedia.org/wiki/MS-DOS" title="MS-DOS">MS-DOS</a>. Because of its dependence on another operating system, initial releases of Windows, prior to Windows 95, were considered an <a href="http://en.m.wikipedia.org/wiki/Operating_environment" title="Operating environment">operating environment</a> (not to be confused with an <a href="Operating_system" title="Operating system">operating system</a>). This product line continued to evolve through the 1980s and 1990s, culminating with release of the <a href="http://en.m.wikipedia.org/wiki/Windows_9x" title="Windows 9x">Windows 9x</a> series (upgrading the system's capabilities to 32-bit addressing and pre-emptive multitasking) through the mid 1990s and ending with the release of <a href="http://en.m.wikipedia.org/wiki/Windows_Me" title="Windows Me">Windows Me</a> in 2000. Microsoft also developed <a href="http://en.m.wikipedia.org/wiki/Windows_NT" title="Windows NT">Windows NT</a>, an operating system intended for high-end and business users. This line started with the release of <a href="http://en.m.wikipedia.org/wiki/Windows_NT_3.1" title="Windows NT 3.1">Windows NT 3.1</a> in 1993, and has continued through the years of 2000 with <a href="http://en.m.wikipedia.org/wiki/Windows_7" title="Windows 7">Windows 7</a> and <a href="http://en.m.wikipedia.org/wiki/Windows_Server_2008" title="Windows Server 2008">Windows Server 2008</a>.</p>
<p>The release of <a href="http://en.m.wikipedia.org/wiki/Windows_XP" title="Windows XP">Windows XP</a> in October 2001 brought the NT kernel version of Windows to general users, replacing <a href="http://en.m.wikipedia.org/wiki/Windows_9x" title="Windows 9x">Windows 9x</a> with a completely different operating system. The <a href="http://en.m.wikipedia.org/wiki/Architecture_of_Windows_NT" title="Architecture of Windows NT">architecture of Windows NT</a>'s kernel is considered a hybrid kernel because the kernel itself contains tasks such as the Window Manager and the IPC Managers, with a client/server layered subsystem model.<sup id="cite_ref-50" class="reference"><a href="Kernel_(computer_science)#cite_note-50"><span>[</span>50<span>]</span></a></sup></p>
<h3> <span class="mw-headline" id="Development_of_microkernels">Development of microkernels</span>
</h3>
<p>Although <a href="http://en.m.wikipedia.org/wiki/Mach_(kernel)" title="Mach (kernel)">Mach</a>, developed at <a href="http://en.m.wikipedia.org/wiki/Carnegie_Mellon_University" title="Carnegie Mellon University">Carnegie Mellon University</a> from 1985 to 1994, is the best-known general-purpose microkernel, other microkernels have been developed with more specific aims. The <a href="http://en.m.wikipedia.org/wiki/L4_microkernel_family" title="L4 microkernel family">L4 microkernel family</a> (mainly the L3 and the L4 kernel) was created to demonstrate that microkernels are not necessarily slow.<sup id="cite_ref-l4_38-1" class="reference"><a href="Kernel_(computer_science)#cite_note-l4-38"><span>[</span>38<span>]</span></a></sup> Newer implementations such as <a href="http://en.m.wikipedia.org/wiki/Fiasco_(L4_clone)" title="Fiasco (L4 clone)" class="mw-redirect">Fiasco</a> and <span class="new" title="Pistachio (L4 clone) (page does not exist)">Pistachio</span> are able to run <a href="http://en.m.wikipedia.org/wiki/Linux" title="Linux">Linux</a> next to other L4 processes in separate address spaces.<sup id="cite_ref-51" class="reference"><a href="Kernel_(computer_science)#cite_note-51"><span>[</span>51<span>]</span></a></sup><sup id="cite_ref-52" class="reference"><a href="Kernel_(computer_science)#cite_note-52"><span>[</span>52<span>]</span></a></sup></p>
<p><a href="http://en.m.wikipedia.org/wiki/QNX" title="QNX">QNX</a> is a <a href="http://en.m.wikipedia.org/wiki/Real-time_operating_system" title="Real-time operating system">real-time operating system</a> with a minimalistic microkernel design that has been developed since 1982, having been far more successful than Mach in achieving the goals of the microkernel paradigm.<sup id="cite_ref-53" class="reference"><a href="Kernel_(computer_science)#cite_note-53"><span>[</span>53<span>]</span></a></sup> It is principally used in <a href="Embedded_system" title="Embedded system">embedded systems</a> and in situations where software is not allowed to fail, such as the robotic arms on the <a href="http://en.m.wikipedia.org/wiki/Space_shuttle" title="Space shuttle" class="mw-redirect">space shuttle</a> and machines that control grinding of glass to extremely fine tolerances, where a tiny mistake may cost hundreds of thousands of dollars.</p>
<h2> <span class="mw-headline" id="See_also">See also</span>
</h2>
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Comparison_of_operating_system_kernels" title="Comparison of operating system kernels">Comparison of operating system kernels</a></li>
</ul>
<h2> <span class="mw-headline" id="Notes">Notes</span>
</h2>
<div class="reflist references-column-width" style="-moz-column-width: 30em; -webkit-column-width: 30em; column-width: 30em; list-style-type: decimal;">
<ol class="references">
<li id="cite_note-Wulf74-1">
<span class="mw-cite-backlink">^ <a href="Kernel_(computer_science)#cite_ref-Wulf74_1-0"><sup><i><b>a</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Wulf74_1-1"><sup><i><b>b</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Wulf74_1-2"><sup><i><b>c</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Wulf74_1-3"><sup><i><b>d</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Wulf74_1-4"><sup><i><b>e</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Wulf74_1-5"><sup><i><b>f</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Wulf74_1-6"><sup><i><b>g</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Wulf74_1-7"><sup><i><b>h</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Wulf74_1-8"><sup><i><b>i</b></i></sup></a></span> <span class="reference-text">Wulf 74 pp.337–345</span>
</li>
<li id="cite_note-mono-micro-2">
<span class="mw-cite-backlink">^ <a href="Kernel_(computer_science)#cite_ref-mono-micro_2-0"><sup><i><b>a</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-mono-micro_2-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text">Roch 2004</span>
</li>
<li id="cite_note-Levy84-3">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-Levy84_3-0">^</a></b></span> <span class="reference-text">Levy 1984, p.5</span>
</li>
<li id="cite_note-4">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-4">^</a></b></span> <span class="reference-text">Needham, R.M., Wilkes, M. V. <i><a rel="nofollow" class="external text" href="http://comjnl.oxfordjournals.org/cgi/content/abstract/17/2/117">Domains of protection and the management of processes</a></i>, Computer Journal, vol. 17, no. 2, May 1974, pp 117–120.</span>
</li>
<li id="cite_note-OS-Concepts-5">
<span class="mw-cite-backlink">^ <a href="Kernel_(computer_science)#cite_ref-OS-Concepts_5-0"><sup><i><b>a</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-OS-Concepts_5-1"><sup><i><b>b</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-OS-Concepts_5-2"><sup><i><b>c</b></i></sup></a></span> <span class="reference-text">Silberschatz 1990</span>
</li>
<li id="cite_note-6">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-6">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external free" href="http://www.answers.com/topic/operating-system">http://www.answers.com/topic/operating-system</a></span>
</li>
<li id="cite_note-7">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-7">^</a></b></span> <span class="reference-text"><span class="citation book"><a href="http://en.m.wikipedia.org/wiki/Andrew_S._Tanenbaum" title="Andrew S. Tanenbaum">Tanenbaum, Andrew S.</a> (2008). <i>Modern Operating Systems</i> (3rd ed.). Prentice Hall. pp. 50–51. <a href="International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="http://en.m.wikipedia.org/wiki/Special:BookSources/0-13-600663-9" title="Special:BookSources/0-13-600663-9">0-13-600663-9</a>. ". . . nearly all system calls [are] invoked from C programs by calling a library procedure . . . The library procedure . . . executes a TRAP instruction to switch from user mode to kernel mode and start execution . . ."</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Modern+Operating+Systems&amp;rft.aulast=Tanenbaum&amp;rft.aufirst=Andrew+S.&amp;rft.au=Tanenbaum%2C%26%2332%3BAndrew+S.&amp;rft.date=2008&amp;rft.pages=pp.%26nbsp%3B50%E2%80%9351&amp;rft.edition=3rd&amp;rft.pub=Prentice+Hall&amp;rft.isbn=0-13-600663-9&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span></span>
</li>
<li id="cite_note-Denning76-8">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-Denning76_8-0">^</a></b></span> <span class="reference-text">Denning 1976</span>
</li>
<li id="cite_note-Swift05Denning76-9">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-Swift05Denning76_9-0">^</a></b></span> <span class="reference-text">Swift 2005, p.29 quote: "isolation, resource control, decision verification (checking), and error recovery."</span>
</li>
<li id="cite_note-Schroeder72-10">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-Schroeder72_10-0">^</a></b></span> <span class="reference-text">Schroeder 72</span>
</li>
<li id="cite_note-LindenCapabilityAddressing-11">
<span class="mw-cite-backlink">^ <a href="Kernel_(computer_science)#cite_ref-LindenCapabilityAddressing_11-0"><sup><i><b>a</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-LindenCapabilityAddressing_11-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text">Linden 76</span>
</li>
<li id="cite_note-EranianMosberger-12">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-EranianMosberger_12-0">^</a></b></span> <span class="reference-text">Stephane Eranian and David Mosberger, <a rel="nofollow" class="external text" href="http://www.informit.com/articles/article.aspx?p=29961">Virtual Memory in the IA-64 Linux Kernel</a>, Prentice Hall PTR, 2002</span>
</li>
<li id="cite_note-13">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-13">^</a></b></span> <span class="reference-text">Silberschatz &amp; Galvin, Operating System Concepts, 4th ed, pp445 &amp; 446</span>
</li>
<li id="cite_note-HochBrowne-14">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-HochBrowne_14-0">^</a></b></span> <span class="reference-text"><span class="citation Journal">Hoch, Charles; J. C. Browne (University of Texas, Austin) (July 1980). <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=850701&amp;dl=acm&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618">"An implementation of capabilities on the PDP-11/45"</a> (PDF). <i>ACM SIGOPS Operating Systems Review</i> <b>14</b> (3): 22–32. <a href="Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F850697.850701">10.1145/850697.850701</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://portal.acm.org/citation.cfm?id=850701&amp;dl=acm&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618">http://portal.acm.org/citation.cfm?id=850701&amp;dl=acm&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618</a></span><span class="reference-accessdate">. Retrieved 2007-01-07</span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=An+implementation+of+capabilities+on+the+PDP-11%2F45&amp;rft.jtitle=ACM+SIGOPS+Operating+Systems+Review&amp;rft.aulast=Hoch&amp;rft.aufirst=Charles&amp;rft.au=Hoch%2C%26%2332%3BCharles&amp;rft.date=July+1980&amp;rft.volume=14&amp;rft.issue=3&amp;rft.pages=22%E2%80%9332&amp;rft_id=info:doi/10.1145%2F850697.850701&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D850701%26dl%3Dacm%26coll%3D%26CFID%3D15151515%26CFTOKEN%3D6184618&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span></span>
</li>
<li id="cite_note-Schneider-15">
<span class="mw-cite-backlink">^ <a href="Kernel_(computer_science)#cite_ref-Schneider_15-0"><sup><i><b>a</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Schneider_15-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.cs.cmu.edu/~rwh/papers/langsec/dagstuhl.pdf">A Language-Based Approach to Security</a>, Schneider F., Morrissett G. (Cornell University) and Harper R. (Carnegie Mellon University)</span>
</li>
<li id="cite_note-Loscocco98-16">
<span class="mw-cite-backlink">^ <a href="Kernel_(computer_science)#cite_ref-Loscocco98_16-0"><sup><i><b>a</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Loscocco98_16-1"><sup><i><b>b</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Loscocco98_16-2"><sup><i><b>c</b></i></sup></a></span> <span class="reference-text">P. A. Loscocco, S. D. Smalley, P. A. Muckelbauer, R. C. Taylor, S. J. Turner, and J. F. Farrell. <i><a rel="nofollow" class="external text" href="http://www.jya.com/paperF1.htm">The Inevitability of Failure: The Flawed Assumption of Security in Modern Computing Environments</a></i>. In Proceedings of the 21st National Information Systems Security Conference, pages 303–314, Oct. 1998. <a rel="nofollow" class="external autonumber" href="http://csrc.nist.gov/nissc/1998/proceedings/paperF1.pdf">[1]</a>.</span>
</li>
<li id="cite_note-17">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-17">^</a></b></span> <span class="reference-text">J. Lepreau et al. <i><a rel="nofollow" class="external text" href="http://doi.acm.org/10.1145/504450.504477">The Persistent Relevance of the Local Operating System to Global Applications</a></i>. Proceedings of the 7th ACM SIGOPS Eurcshelf/book001/book001.html Information Security: An Integrated Collection of Essays], IEEE Comp. 1995.</span>
</li>
<li id="cite_note-18">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-18">^</a></b></span> <span class="reference-text">J. Anderson, <i><a rel="nofollow" class="external text" href="http://csrc.nist.gov/publications/history/ande72.pdf">Computer Security Technology Planning Study</a>, Air Force Elect. Systems Div., ESD-TR-73-51, October 1972.</i></span>
</li>
<li id="cite_note-19">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-19">^</a></b></span> <span class="reference-text">* <span class="citation Journal">Jerry H. Saltzer, Mike D. Schroeder (September 1975). <a rel="nofollow" class="external text" href="http://web.mit.edu/Saltzer/www/publications/protection/">"The protection of information in computer systems"</a>. <i>Proceedings of the IEEE</i> <b>63</b> (9): 1278–1308. <a href="Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1109%2FPROC.1975.9939">10.1109/PROC.1975.9939</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://web.mit.edu/Saltzer/www/publications/protection/">http://web.mit.edu/Saltzer/www/publications/protection/</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=The+protection+of+information+in+computer+systems&amp;rft.jtitle=Proceedings+of+the+IEEE&amp;rft.aulast=Jerry+H.+Saltzer%2C+Mike+D.+Schroeder&amp;rft.au=Jerry+H.+Saltzer%2C+Mike+D.+Schroeder&amp;rft.date=September+1975&amp;rft.volume=63&amp;rft.issue=9&amp;rft.pages=1278%E2%80%931308&amp;rft_id=info:doi/10.1109%2FPROC.1975.9939&amp;rft_id=http%3A%2F%2Fweb.mit.edu%2FSaltzer%2Fwww%2Fpublications%2Fprotection%2F&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span></span>
</li>
<li id="cite_note-20">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-20">^</a></b></span> <span class="reference-text"><span class="citation Journal">Jonathan S. Shapiro; Jonathan M. Smith; David J. Farber (1999). <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?doid=319151.319163">"EROS: a fast capability system"</a>. <i>Proceedings of the seventeenth ACM symposium on Operating systems principles</i> <b>33</b> (5): 170–185. <a href="Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F319344.319163">10.1145/319344.319163</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://portal.acm.org/citation.cfm?doid=319151.319163">http://portal.acm.org/citation.cfm?doid=319151.319163</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=EROS%3A+a+fast+capability+system&amp;rft.jtitle=Proceedings+of+the+seventeenth+ACM+symposium+on+Operating+systems+principles&amp;rft.aulast=Jonathan+S.+Shapiro%3B+Jonathan+M.+Smith%3B+David+J.+Farber&amp;rft.au=Jonathan+S.+Shapiro%3B+Jonathan+M.+Smith%3B+David+J.+Farber&amp;rft.date=1999&amp;rft.volume=33&amp;rft.issue=5&amp;rft.pages=170%E2%80%93185&amp;rft_id=info:doi/10.1145%2F319344.319163&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fdoid%3D319151.319163&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span></span>
</li>
<li id="cite_note-Dijkstra65-21">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-Dijkstra65_21-0">^</a></b></span> <span class="reference-text">Dijkstra, E. W. <i>Cooperating Sequential Processes</i>. Math. Dep., Technological U., Eindhoven, Sept. 1965.</span>
</li>
<li id="cite_note-Hansen70-22">
<span class="mw-cite-backlink">^ <a href="Kernel_(computer_science)#cite_ref-Hansen70_22-0"><sup><i><b>a</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Hansen70_22-1"><sup><i><b>b</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Hansen70_22-2"><sup><i><b>c</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Hansen70_22-3"><sup><i><b>d</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Hansen70_22-4"><sup><i><b>e</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Hansen70_22-5"><sup><i><b>f</b></i></sup></a></span> <span class="reference-text">Brinch Hansen 70 pp.238–241</span>
</li>
<li id="cite_note-23">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-23">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=363778&amp;dl=ACM&amp;coll=GUIDE&amp;CFID=11111111&amp;CFTOKEN=2222222">"SHARER, a time sharing system for the CDC 6600"</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://portal.acm.org/citation.cfm?id=363778&amp;dl=ACM&amp;coll=GUIDE&amp;CFID=11111111&amp;CFTOKEN=2222222">http://portal.acm.org/citation.cfm?id=363778&amp;dl=ACM&amp;coll=GUIDE&amp;CFID=11111111&amp;CFTOKEN=2222222</a></span><span class="reference-accessdate">. Retrieved 2007-01-07</span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=SHARER%2C+a+time+sharing+system+for+the+CDC+6600&amp;rft.atitle=&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D363778%26dl%3DACM%26coll%3DGUIDE%26CFID%3D11111111%26CFTOKEN%3D2222222&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span></span>
</li>
<li id="cite_note-24">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-24">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=811675&amp;dl=ACM&amp;coll=GUIDE&amp;CFID=11111111&amp;CFTOKEN=2222222">"Dynamic Supervisors – their design and construction"</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://portal.acm.org/citation.cfm?id=811675&amp;dl=ACM&amp;coll=GUIDE&amp;CFID=11111111&amp;CFTOKEN=2222222">http://portal.acm.org/citation.cfm?id=811675&amp;dl=ACM&amp;coll=GUIDE&amp;CFID=11111111&amp;CFTOKEN=2222222</a></span><span class="reference-accessdate">. Retrieved 2007-01-07</span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Dynamic+Supervisors+%E2%80%93+their+design+and+construction&amp;rft.atitle=&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D811675%26dl%3DACM%26coll%3DGUIDE%26CFID%3D11111111%26CFTOKEN%3D2222222&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span></span>
</li>
<li id="cite_note-25">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-25">^</a></b></span> <span class="reference-text">Baiardi 1988</span>
</li>
<li id="cite_note-Levin75-26">
<span class="mw-cite-backlink">^ <a href="Kernel_(computer_science)#cite_ref-Levin75_26-0"><sup><i><b>a</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Levin75_26-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text">Levin 75</span>
</li>
<li id="cite_note-Denning80-27">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-Denning80_27-0">^</a></b></span> <span class="reference-text">Denning 1980</span>
</li>
<li id="cite_note-Nehmer91-28">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-Nehmer91_28-0">^</a></b></span> <span class="reference-text">Jürgen Nehmer <i><a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=723612">The Immortality of Operating Systems, or: Is Research in Operating Systems still Justified?</a></i> Lecture Notes In Computer Science; Vol. 563. Proceedings of the International Workshop on Operating Systems of the 90s and Beyond. pp. 77–83 (1991) <a href="http://en.m.wikipedia.org/wiki/Special:BookSources/3540549870" class="internal mw-magiclink-isbn">ISBN 3-540-54987-0</a> <a rel="nofollow" class="external autonumber" href="http://www.sigmod.org/dblp/db/conf/dagstuhl/os1991.html">[2]</a> quote: "The past 25 years have shown that research on operating system architecture had a minor effect on existing main stream systems." <a rel="nofollow" class="external autonumber" href="http://www.soe.ucsc.edu/~brucem/soft_ins/dissert.html">[3]</a></span>
</li>
<li id="cite_note-29">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-29">^</a></b></span> <span class="reference-text">Levy 84, p.1 quote: "Although the complexity of computer applications increases yearly, the underlying hardware architecture for applications has remained unchanged for decades."</span>
</li>
<li id="cite_note-Levy84privilegedmode-30">
<span class="mw-cite-backlink">^ <a href="Kernel_(computer_science)#cite_ref-Levy84privilegedmode_30-0"><sup><i><b>a</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Levy84privilegedmode_30-1"><sup><i><b>b</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Levy84privilegedmode_30-2"><sup><i><b>c</b></i></sup></a></span> <span class="reference-text">Levy 84, p.1 quote: "Conventional architectures support a single privileged mode of operation. This structure leads to monolithic design; any module needing protection must be part of the single operating system kernel. If, instead, any module could execute within a protected domain, systems could be built as a collection of independent modules extensible by any user."</span>
</li>
<li id="cite_note-Linuxisobsoletedebate-31">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-Linuxisobsoletedebate_31-0">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://oreilly.com/catalog/opensources/book/appa.html">Open Sources: Voices from the Open Source Revolution</a></span>
</li>
<li id="cite_note-32">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-32">^</a></b></span> <span class="reference-text">Virtual addressing is most commonly achieved through a built-in <a href="http://en.m.wikipedia.org/wiki/Memory_management_unit" title="Memory management unit">memory management unit</a>.</span>
</li>
<li id="cite_note-TorvaldsTanenbaum-33">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-TorvaldsTanenbaum_33-0">^</a></b></span> <span class="reference-text">Recordings of the debate between Torvalds and Tanenbaum can be found at <a rel="nofollow" class="external text" href="http://www.dina.dk/~abraham/Linus_vs_Tanenbaum.html">dina.dk</a>, <a rel="nofollow" class="external text" href="http://groups.google.com/group/comp.os.minix/browse_thread/thread/c25870d7a41696d2/f447530d082cd95d?tvc=2#f447530d082cd95d">groups.google.com</a>, <a rel="nofollow" class="external text" href="http://www.oreilly.com/catalog/opensources/book/appa.html">oreilly.com</a> and <a rel="nofollow" class="external text" href="http://www.cs.vu.nl/~ast/reliable-os/">Andrew Tanenbaum's website</a></span>
</li>
<li id="cite_note-MatthewRussell-34">
<span class="mw-cite-backlink">^ <a href="Kernel_(computer_science)#cite_ref-MatthewRussell_34-0"><sup><i><b>a</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-MatthewRussell_34-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation web"><span class="new" title="Matthew Russell (page does not exist)">Matthew Russell</span>. <a rel="nofollow" class="external text" href="http://oreilly.com/pub/a/mac/2005/09/27/what-is-darwin.html?page=2">"What Is Darwin (and How It Powers Mac OS X)"</a>. <a href="http://en.m.wikipedia.org/wiki/O%27Reilly_Media" title="O'Reilly Media">O'Reilly Media</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://oreilly.com/pub/a/mac/2005/09/27/what-is-darwin.html?page=2">http://oreilly.com/pub/a/mac/2005/09/27/what-is-darwin.html?page=2</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=What+Is+Darwin+%28and+How+It+Powers+Mac+OS+X%29&amp;rft.atitle=&amp;rft.aulast=%5B%5BMatthew+Russell%5D%5D&amp;rft.au=%5B%5BMatthew+Russell%5D%5D&amp;rft.pub=%5B%5BO%27Reilly+Media%5D%5D&amp;rft_id=http%3A%2F%2Foreilly.com%2Fpub%2Fa%2Fmac%2F2005%2F09%2F27%2Fwhat-is-darwin.html%3Fpage%3D2&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span> quote: "The tightly coupled nature of a monolithic kernel allows it to make very efficient use of the underlying hardware [...] Microkernels, on the other hand, run a lot more of the core processes in userland. [...] Unfortunately, these benefits come at the cost of the microkernel having to pass a lot of information in and out of the kernel space through a process known as a context switch. Context switches introduce considerable overhead and therefore result in a performance penalty."</span>
</li>
<li id="cite_note-Liedtke95-35">
<span class="mw-cite-backlink">^ <a href="Kernel_(computer_science)#cite_ref-Liedtke95_35-0"><sup><i><b>a</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Liedtke95_35-1"><sup><i><b>b</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Liedtke95_35-2"><sup><i><b>c</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Liedtke95_35-3"><sup><i><b>d</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Liedtke95_35-4"><sup><i><b>e</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Liedtke95_35-5"><sup><i><b>f</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-Liedtke95_35-6"><sup><i><b>g</b></i></sup></a></span> <span class="reference-text">Liedtke 95</span>
</li>
<li id="cite_note-Hartig97-36">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-Hartig97_36-0">^</a></b></span> <span class="reference-text">Härtig 97</span>
</li>
<li id="cite_note-Hansen73SupervisorMode-37">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-Hansen73SupervisorMode_37-0">^</a></b></span> <span class="reference-text">Hansen 73, section 7.3 p.233 "<i>interactions between different levels of protection require transmission of messages by value</i>"</span>
</li>
<li id="cite_note-l4-38">
<span class="mw-cite-backlink">^ <a href="Kernel_(computer_science)#cite_ref-l4_38-0"><sup><i><b>a</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-l4_38-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://os.inf.tu-dresden.de/L4/overview.html">The L4 microkernel family – Overview</a></span>
</li>
<li id="cite_note-39">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-39">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.cis.upenn.edu/~KeyKOS/NanoKernel/NanoKernel.html">KeyKOS Nanokernel Architecture</a></span>
</li>
<li id="cite_note-Ball2002-40">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-Ball2002_40-0">^</a></b></span> <span class="reference-text">Ball: Embedded Microprocessor Designs, p. 129</span>
</li>
<li id="cite_note-Hansen2001RC4k-41">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-Hansen2001RC4k_41-0">^</a></b></span> <span class="reference-text">Hansen 2001 (os), pp.17–18</span>
</li>
<li id="cite_note-42">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-42">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://cm.bell-labs.com/cm/cs/who/dmr/cacm.html">BSTJ version of C.ACM Unix paper</a></span>
</li>
<li id="cite_note-43">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-43">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.multicians.org/fjcc1.html">Introduction and Overview of the Multics System</a>, by F. J. Corbató and V. A. Vissotsky.</span>
</li>
<li id="cite_note-unix-44">
<span class="mw-cite-backlink">^ <a href="Kernel_(computer_science)#cite_ref-unix_44-0"><sup><i><b>a</b></i></sup></a> <a href="Kernel_(computer_science)#cite_ref-unix_44-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.unix.org/what_is_unix/single_unix_specification.html">The UNIX System — The Single Unix Specification</a></span>
</li>
<li id="cite_note-supervisor-45">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-supervisor_45-0">^</a></b></span> <span class="reference-text">The highest privilege level has various names throughout different architectures, such as supervisor mode, kernel mode, CPL0, DPL0, Ring 0, etc. See <a href="http://en.m.wikipedia.org/wiki/Ring_(computer_security)" title="Ring (computer security)">Ring (computer security)</a> for more information.</span>
</li>
<li id="cite_note-46">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-46">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.asymco.com/2010/09/29/unixs-revenge/">Unix’s Revenge by Horace Dediu</a></span>
</li>
<li id="cite_note-47">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-47">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.dwheeler.com/essays/linux-kernel-cost.html">Linux Kernel 2.6: It's Worth More!</a>, by David A. Wheeler, October 12, 2004</span>
</li>
<li id="cite_note-48">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-48">^</a></b></span> <span class="reference-text">This community mostly gathers at <a rel="nofollow" class="external text" href="http://www.osdever.net">Bona Fide OS Development</a>, <a rel="nofollow" class="external text" href="http://www.mega-tokyo.com/forum">The Mega-Tokyo Message Board</a> and other operating system enthusiast web sites.</span>
</li>
<li id="cite_note-49">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-49">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.kernelthread.com/mac/osx/arch_xnu.html">XNU: The Kernel</a></span>
</li>
<li id="cite_note-50">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-50">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.microsoft.com/windows/WinHistoryDesktop.mspx">Windows History: Windows Desktop Products History</a></span>
</li>
<li id="cite_note-51">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-51">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://os.inf.tu-dresden.de/fiasco/overview.html">The Fiasco microkernel – Overview</a></span>
</li>
<li id="cite_note-52">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-52">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.l4ka.org">L4Ka – The L4 microkernel family and friends</a></span>
</li>
<li id="cite_note-53">
<span class="mw-cite-backlink"><b><a href="Kernel_(computer_science)#cite_ref-53">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.qnx.com/products/rtos/microkernel.html">QNX Realtime Operating System Overview</a></span>
</li>
</ol>
</div>
<h2> <span class="mw-headline" id="References">References</span>
</h2>
<div class="refbegin references-column-width" style="-moz-column-width: 30em; -webkit-column-width: 30em; column-width: 30em;">
<ul>
<li>
<span class="citation web">Roch, Benjamin (2004). <a rel="nofollow" class="external text" href="http://www.vmars.tuwien.ac.at/courses/akti12/journal/04ss/article_04ss_Roch.pdf">"Monolithic kernel vs. Microkernel"</a> (PDF)<span class="printonly">. <a rel="nofollow" class="external free" href="http://www.vmars.tuwien.ac.at/courses/akti12/journal/04ss/article_04ss_Roch.pdf">http://www.vmars.tuwien.ac.at/courses/akti12/journal/04ss/article_04ss_Roch.pdf</a></span><span class="reference-accessdate">. Retrieved 2006-10-12</span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Monolithic+kernel+vs.+Microkernel&amp;rft.atitle=&amp;rft.aulast=Roch&amp;rft.aufirst=Benjamin&amp;rft.au=Roch%2C%26%2332%3BBenjamin&amp;rft.date=2004&amp;rft_id=http%3A%2F%2Fwww.vmars.tuwien.ac.at%2Fcourses%2Fakti12%2Fjournal%2F04ss%2Farticle_04ss_Roch.pdf&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span>
</li>
<li>
<span class="citation book"><a href="http://en.m.wikipedia.org/wiki/Abraham_Silberschatz" title="Abraham Silberschatz">Silberschatz, Abraham</a>; James L. Peterson, Peter B. Galvin (1991). <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=95329&amp;dl=acm&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618"><i>Operating system concepts</i></a>. <a href="http://en.m.wikipedia.org/wiki/Boston,_Massachusetts" title="Boston, Massachusetts" class="mw-redirect">Boston, Massachusetts</a>: Addison-Wesley. p. 696. <a href="International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="http://en.m.wikipedia.org/wiki/Special:BookSources/0-201-51379-X" title="Special:BookSources/0-201-51379-X">0-201-51379-X</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://portal.acm.org/citation.cfm?id=95329&amp;dl=acm&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618">http://portal.acm.org/citation.cfm?id=95329&amp;dl=acm&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Operating+system+concepts&amp;rft.aulast=Silberschatz&amp;rft.aufirst=Abraham&amp;rft.au=Silberschatz%2C%26%2332%3BAbraham&amp;rft.date=1991&amp;rft.pages=p.%26nbsp%3B696&amp;rft.place=%5B%5BBoston%2C+Massachusetts%5D%5D&amp;rft.pub=Addison-Wesley&amp;rft.isbn=0-201-51379-X&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D95329%26dl%3Dacm%26coll%3D%26CFID%3D15151515%26CFTOKEN%3D6184618&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span>
</li>
<li>
<span class="citation book">Ball, Stuart R. (2002) [2002]. <i>Embedded Microprocessor Systems: Real World Designs</i> (first ed.). Elsevier Science. <a href="International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="http://en.m.wikipedia.org/wiki/Special:BookSources/0-7506-7534-9" title="Special:BookSources/0-7506-7534-9">0-7506-7534-9</a>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Embedded+Microprocessor+Systems%3A+Real+World+Designs&amp;rft.aulast=Ball&amp;rft.aufirst=Stuart+R.&amp;rft.au=Ball%2C%26%2332%3BStuart+R.&amp;rft.date=2002&amp;rft.edition=first&amp;rft.pub=Elsevier+Science&amp;rft.isbn=0-7506-7534-9&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span>
</li>
<li>
<span class="citation book">Deitel, Harvey M. (1984) [1982]. <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=79046&amp;dl=GUIDE&amp;coll=GUIDE"><i>An introduction to operating systems</i></a> (revisited first ed.). Addison-Wesley. p. 673. <a href="International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="http://en.m.wikipedia.org/wiki/Special:BookSources/0-201-14502-2" title="Special:BookSources/0-201-14502-2">0-201-14502-2</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://portal.acm.org/citation.cfm?id=79046&amp;dl=GUIDE&amp;coll=GUIDE">http://portal.acm.org/citation.cfm?id=79046&amp;dl=GUIDE&amp;coll=GUIDE</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=An+introduction+to+operating+systems&amp;rft.aulast=Deitel&amp;rft.aufirst=Harvey+M.&amp;rft.au=Deitel%2C%26%2332%3BHarvey+M.&amp;rft.date=1984&amp;rft.pages=p.%26nbsp%3B673&amp;rft.edition=revisited+first&amp;rft.pub=Addison-Wesley&amp;rft.isbn=0-201-14502-2&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D79046%26dl%3DGUIDE%26coll%3DGUIDE&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span>
</li>
<li>
<span class="citation Journal"><a href="http://en.m.wikipedia.org/wiki/P._J._Denning" title="P. J. Denning" class="mw-redirect">Denning, Peter J.</a> (December 1976). <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=356680&amp;dl=ACM&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618">"Fault tolerant operating systems"</a>. <i><a href="http://en.m.wikipedia.org/wiki/ACM_Computing_Surveys" title="ACM Computing Surveys">ACM Computing Surveys</a></i> <b>8</b> (4): 359–389. <a href="Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F356678.356680">10.1145/356678.356680</a>. <a href="http://en.m.wikipedia.org/wiki/International_Standard_Serial_Number" title="International Standard Serial Number">ISSN</a> <a rel="nofollow" class="external text" href="http://www.worldcat.org/search?fq=x0:jrnl&amp;q=n2:0360-0300">0360-0300</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://portal.acm.org/citation.cfm?id=356680&amp;dl=ACM&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618">http://portal.acm.org/citation.cfm?id=356680&amp;dl=ACM&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Fault+tolerant+operating+systems&amp;rft.jtitle=%5B%5BACM+Computing+Surveys%5D%5D&amp;rft.aulast=%5B%5BP.+J.+Denning%7CDenning%2C+Peter+J.%5D%5D&amp;rft.au=%5B%5BP.+J.+Denning%7CDenning%2C+Peter+J.%5D%5D&amp;rft.date=December+1976&amp;rft.volume=8&amp;rft.issue=4&amp;rft.pages=359%E2%80%93389&amp;rft_id=info:doi/10.1145%2F356678.356680&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D356680%26dl%3DACM%26coll%3D%26CFID%3D15151515%26CFTOKEN%3D6184618&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span>
</li>
<li>
<span class="citation Journal"><a href="http://en.m.wikipedia.org/wiki/Peter_J._Denning" title="Peter J. Denning">Denning, Peter J.</a> (April 1980). <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=859506&amp;coll=&amp;dl=ACM&amp;CFID=15151515&amp;CFTOKEN=6184618">"Why not innovations in computer architecture?"</a>. <i>ACM SIGARCH Computer Architecture News</i> <b>8</b> (2): 4–7. <a href="Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F859504.859506">10.1145/859504.859506</a>. ISSN 0163-5964<span class="printonly">. <a rel="nofollow" class="external free" href="http://portal.acm.org/citation.cfm?id=859506&amp;coll=&amp;dl=ACM&amp;CFID=15151515&amp;CFTOKEN=6184618">http://portal.acm.org/citation.cfm?id=859506&amp;coll=&amp;dl=ACM&amp;CFID=15151515&amp;CFTOKEN=6184618</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Why+not+innovations+in+computer+architecture%3F&amp;rft.jtitle=ACM+SIGARCH+Computer+Architecture+News&amp;rft.aulast=Denning&amp;rft.aufirst=Peter+J.&amp;rft.au=Denning%2C%26%2332%3BPeter+J.&amp;rft.date=April+1980&amp;rft.volume=8&amp;rft.issue=2&amp;rft.pages=4%E2%80%937&amp;rft_id=info:doi/10.1145%2F859504.859506&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D859506%26coll%3D%26dl%3DACM%26CFID%3D15151515%26CFTOKEN%3D6184618&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span>
</li>
<li>
<span class="citation Journal"><a href="http://en.m.wikipedia.org/wiki/Per_Brinch_Hansen" title="Per Brinch Hansen">Hansen, Per Brinch</a> (April 1970). <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=362278&amp;dl=ACM&amp;coll=GUIDE&amp;CFID=11111111&amp;CFTOKEN=2222222">"The nucleus of a Multiprogramming System"</a>. <i><a href="http://en.m.wikipedia.org/wiki/Communications_of_the_ACM" title="Communications of the ACM">Communications of the ACM</a></i> <b>13</b> (4): 238–241. <a href="Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F362258.362278">10.1145/362258.362278</a>. ISSN 0001-0782<span class="printonly">. <a rel="nofollow" class="external free" href="http://portal.acm.org/citation.cfm?id=362278&amp;dl=ACM&amp;coll=GUIDE&amp;CFID=11111111&amp;CFTOKEN=2222222">http://portal.acm.org/citation.cfm?id=362278&amp;dl=ACM&amp;coll=GUIDE&amp;CFID=11111111&amp;CFTOKEN=2222222</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=The+nucleus+of+a+Multiprogramming+System&amp;rft.jtitle=%5B%5BCommunications+of+the+ACM%5D%5D&amp;rft.aulast=Hansen&amp;rft.aufirst=Per+Brinch&amp;rft.au=Hansen%2C%26%2332%3BPer+Brinch&amp;rft.date=April+1970&amp;rft.volume=13&amp;rft.issue=4&amp;rft.pages=238%E2%80%93241&amp;rft_id=info:doi/10.1145%2F362258.362278&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D362278%26dl%3DACM%26coll%3DGUIDE%26CFID%3D11111111%26CFTOKEN%3D2222222&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span>
</li>
<li>
<span class="citation book"><a href="http://en.m.wikipedia.org/wiki/Per_Brinch_Hansen" title="Per Brinch Hansen">Hansen, Per Brinch</a> (1973). <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=540365"><i>Operating System Principles</i></a>. <a href="http://en.m.wikipedia.org/wiki/Englewood_Cliffs" title="Englewood Cliffs" class="mw-redirect">Englewood Cliffs</a>: Prentice Hall. p. 496. <a href="International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="http://en.m.wikipedia.org/wiki/Special:BookSources/0-13-637843-9" title="Special:BookSources/0-13-637843-9">0-13-637843-9</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://portal.acm.org/citation.cfm?id=540365">http://portal.acm.org/citation.cfm?id=540365</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Operating+System+Principles&amp;rft.aulast=Hansen&amp;rft.aufirst=Per+Brinch&amp;rft.au=Hansen%2C%26%2332%3BPer+Brinch&amp;rft.date=1973&amp;rft.pages=p.%26nbsp%3B496&amp;rft.place=%5B%5BEnglewood+Cliffs%5D%5D&amp;rft.pub=Prentice+Hall&amp;rft.isbn=0-13-637843-9&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D540365&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span>
</li>
<li>
<span class="citation Journal"><a href="http://en.m.wikipedia.org/wiki/Per_Brinch_Hansen" title="Per Brinch Hansen">Hansen, Per Brinch</a> (2001) (PDF). <a rel="nofollow" class="external text" href="http://brinch-hansen.net/papers/2001b.pdf"><i>The evolution of operating systems</i></a><span class="printonly">. <a rel="nofollow" class="external free" href="http://brinch-hansen.net/papers/2001b.pdf">http://brinch-hansen.net/papers/2001b.pdf</a></span><span class="reference-accessdate">. Retrieved 2006-10-24</span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=The+evolution+of+operating+systems&amp;rft.aulast=%5B%5BPer+Brinch+Hansen%7CHansen%2C+Per+Brinch%5D%5D&amp;rft.au=%5B%5BPer+Brinch+Hansen%7CHansen%2C+Per+Brinch%5D%5D&amp;rft.date=2001&amp;rft_id=http%3A%2F%2Fbrinch-hansen.net%2Fpapers%2F2001b.pdf&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span> included in book: <span class="citation book">Per Brinch Hansen, ed. (2001). <a rel="nofollow" class="external text" href="http://brinch-hansen.net/papers/2001b.pdf">"1"</a>. <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=360596&amp;dl=ACM&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618"><i>Classic operating systems: from batch processing to distributed systems</i></a>. New York,: Springer-Verlag. pp. 1–36. <a href="International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="http://en.m.wikipedia.org/wiki/Special:BookSources/0-387-95113-X" title="Special:BookSources/0-387-95113-X">0-387-95113-X</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://brinch-hansen.net/papers/2001b.pdf">http://brinch-hansen.net/papers/2001b.pdf</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=1&amp;rft.atitle=Classic+operating+systems%3A+from+batch+processing+to+distributed+systems&amp;rft.date=2001&amp;rft.pages=pp.%26nbsp%3B1%E2%80%9336&amp;rft.place=New+York%2C&amp;rft.pub=Springer-Verlag&amp;rft.isbn=0-387-95113-X&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D360596%26dl%3DACM%26coll%3D%26CFID%3D15151515%26CFTOKEN%3D6184618&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span>
</li>
<li>
<span class="new" title="Hermann Härtig (page does not exist)">Hermann Härtig</span>, Michael Hohmuth, <a href="http://en.m.wikipedia.org/wiki/Jochen_Liedtke" title="Jochen Liedtke">Jochen Liedtke</a>, Sebastian Schönberg, Jean Wolter <i><a rel="nofollow" class="external text" href="http://os.inf.tu-dresden.de/pubs/sosp97/#Karshmer:1991:OSA">The performance of μ-kernel-based systems</a></i>, <span class="citation web"><a rel="nofollow" class="external text" href="http://doi.acm.org/10.1145/268998.266660">"The performance of μ-kernel-based systems"</a>. Doi.acm.org<span class="printonly">. <a rel="nofollow" class="external free" href="http://doi.acm.org/10.1145/268998.266660">http://doi.acm.org/10.1145/268998.266660</a></span><span class="reference-accessdate">. Retrieved 2010-06-19</span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=The+performance+of+%CE%BC-kernel-based+systems&amp;rft.atitle=&amp;rft.pub=Doi.acm.org&amp;rft_id=http%3A%2F%2Fdoi.acm.org%2F10.1145%2F268998.266660&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span> ACM SIGOPS Operating Systems Review, v.31 n.5, p. 66–77, Dec. 1997</li>
<li>Houdek, M. E., Soltis, F. G., and Hoffman, R. L. 1981. <i><a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=800052.801885">IBM System/38 support for capability-based addressing</a></i>. In Proceedings of the 8th ACM International Symposium on Computer Architecture. ACM/IEEE, pp. 341–348.</li>
<li>
<a href="http://en.m.wikipedia.org/wiki/Intel_Corporation" title="Intel Corporation" class="mw-redirect">Intel Corporation</a> (2002) <i><a rel="nofollow" class="external text" href="http://www.intel.com/design/pentium4/manuals/24547010.pdf">The IA-32 Architecture Software Developer’s Manual, Volume 1: Basic Architecture</a></i>
</li>
<li>
<span class="citation Journal">Levin, R.; E. Cohen, W. Corwin, F. Pollack, <a href="http://en.m.wikipedia.org/wiki/William_Wulf" title="William Wulf">William Wulf</a> (1975). <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=806531&amp;dl=ACM&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618">"Policy/mechanism separation in Hydra"</a>. <i>ACM Symposium on Operating Systems Principles / Proceedings of the fifth ACM symposium on Operating systems principles</i> <b>9</b> (5): 132–140. <a href="Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F1067629.806531">10.1145/1067629.806531</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://portal.acm.org/citation.cfm?id=806531&amp;dl=ACM&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618">http://portal.acm.org/citation.cfm?id=806531&amp;dl=ACM&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Policy%2Fmechanism+separation+in+Hydra&amp;rft.jtitle=ACM+Symposium+on+Operating+Systems+Principles+%2F+Proceedings+of+the+fifth+ACM+symposium+on+Operating+systems+principles&amp;rft.aulast=Levin&amp;rft.aufirst=R.&amp;rft.au=Levin%2C%26%2332%3BR.&amp;rft.date=1975&amp;rft.volume=9&amp;rft.issue=5&amp;rft.pages=132%E2%80%93140&amp;rft_id=info:doi/10.1145%2F1067629.806531&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D806531%26dl%3DACM%26coll%3D%26CFID%3D15151515%26CFTOKEN%3D6184618&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span>
</li>
<li>
<span class="citation book">Levy, Henry M. (1984). <a rel="nofollow" class="external text" href="http://www.cs.washington.edu/homes/levy/capabook/index.html"><i>Capability-based computer systems</i></a>. Maynard, Mass: Digital Press. <a href="International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="http://en.m.wikipedia.org/wiki/Special:BookSources/0-932376-22-3" title="Special:BookSources/0-932376-22-3">0-932376-22-3</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://www.cs.washington.edu/homes/levy/capabook/index.html">http://www.cs.washington.edu/homes/levy/capabook/index.html</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Capability-based+computer+systems&amp;rft.aulast=Levy%2C+Henry+M.&amp;rft.au=Levy%2C+Henry+M.&amp;rft.date=1984&amp;rft.place=Maynard%2C+Mass&amp;rft.pub=Digital+Press&amp;rft.isbn=0-932376-22-3&amp;rft_id=http%3A%2F%2Fwww.cs.washington.edu%2Fhomes%2Flevy%2Fcapabook%2Findex.html&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span>
</li>
<li>
<a href="http://en.m.wikipedia.org/wiki/Jochen_Liedtke" title="Jochen Liedtke">Liedtke, Jochen</a>. <i><a rel="nofollow" class="external text" href="http://i30www.ira.uka.de/research/publications/papers/index.php?lid=en&amp;docid=642">On µ-Kernel Construction</a></i>, <i>Proc. 15th ACM Symposium on Operating System Principles (SOSP)</i>, December 1995</li>
<li>
<span class="citation Journal">Linden, Theodore A. (December 1976). <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=356682&amp;coll=&amp;dl=ACM&amp;CFID=15151515&amp;CFTOKEN=6184618">"Operating System Structures to Support Security and Reliable Software"</a>. <i><a href="http://en.m.wikipedia.org/wiki/ACM_Computing_Surveys" title="ACM Computing Surveys">ACM Computing Surveys</a></i> <b>8</b> (4): 409–445. <a href="Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F356678.356682">10.1145/356678.356682</a>. ISSN 0360-0300<span class="printonly">. <a rel="nofollow" class="external free" href="http://portal.acm.org/citation.cfm?id=356682&amp;coll=&amp;dl=ACM&amp;CFID=15151515&amp;CFTOKEN=6184618">http://portal.acm.org/citation.cfm?id=356682&amp;coll=&amp;dl=ACM&amp;CFID=15151515&amp;CFTOKEN=6184618</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Operating+System+Structures+to+Support+Security+and+Reliable+Software&amp;rft.jtitle=%5B%5BACM+Computing+Surveys%5D%5D&amp;rft.aulast=Linden&amp;rft.aufirst=Theodore+A.&amp;rft.au=Linden%2C%26%2332%3BTheodore+A.&amp;rft.date=December+1976&amp;rft.volume=8&amp;rft.issue=4&amp;rft.pages=409%E2%80%93445&amp;rft_id=info:doi/10.1145%2F356678.356682&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D356682%26coll%3D%26dl%3DACM%26CFID%3D15151515%26CFTOKEN%3D6184618&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span>, <span class="citation web"><a rel="nofollow" class="external text" href="http://csrc.nist.gov/publications/history/lind76.pdf">"Operating System Structures to Support Security and Reliable Software"</a> (PDF)<span class="printonly">. <a rel="nofollow" class="external free" href="http://csrc.nist.gov/publications/history/lind76.pdf">http://csrc.nist.gov/publications/history/lind76.pdf</a></span><span class="reference-accessdate">. Retrieved 2010-06-19</span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Operating+System+Structures+to+Support+Security+and+Reliable+Software&amp;rft.atitle=&amp;rft_id=http%3A%2F%2Fcsrc.nist.gov%2Fpublications%2Fhistory%2Flind76.pdf&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span>
</li>
<li>
<span class="citation book">Lorin, Harold (1981). <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=578308&amp;coll=GUIDE&amp;dl=GUIDE&amp;CFID=2651732&amp;CFTOKEN=19681373"><i>Operating systems</i></a>. <a href="http://en.m.wikipedia.org/wiki/Boston,_Massachusetts" title="Boston, Massachusetts" class="mw-redirect">Boston, Massachusetts</a>: Addison-Wesley. pp. 161–186. <a href="International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="http://en.m.wikipedia.org/wiki/Special:BookSources/0-201-14464-6" title="Special:BookSources/0-201-14464-6">0-201-14464-6</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://portal.acm.org/citation.cfm?id=578308&amp;coll=GUIDE&amp;dl=GUIDE&amp;CFID=2651732&amp;CFTOKEN=19681373">http://portal.acm.org/citation.cfm?id=578308&amp;coll=GUIDE&amp;dl=GUIDE&amp;CFID=2651732&amp;CFTOKEN=19681373</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Operating+systems&amp;rft.aulast=Lorin&amp;rft.aufirst=Harold&amp;rft.au=Lorin%2C%26%2332%3BHarold&amp;rft.date=1981&amp;rft.pages=pp.%26nbsp%3B161%E2%80%93186&amp;rft.place=%5B%5BBoston%2C+Massachusetts%5D%5D&amp;rft.pub=Addison-Wesley&amp;rft.isbn=0-201-14464-6&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D578308%26coll%3DGUIDE%26dl%3DGUIDE%26CFID%3D2651732%26CFTOKEN%3D19681373&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span>
</li>
<li>
<span class="citation Journal"><a href="http://en.m.wikipedia.org/wiki/Michael_Schroeder" title="Michael Schroeder">Schroeder, Michael D.</a>; Jerome H. Saltzer (March 1972). <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=361275&amp;dl=ACM&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618">"A hardware architecture for implementing protection rings"</a>. <i><a href="http://en.m.wikipedia.org/wiki/Communications_of_the_ACM" title="Communications of the ACM">Communications of the ACM</a></i> <b>15</b> (3): 157–170. <a href="Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F361268.361275">10.1145/361268.361275</a>. ISSN 0001-0782<span class="printonly">. <a rel="nofollow" class="external free" href="http://portal.acm.org/citation.cfm?id=361275&amp;dl=ACM&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618">http://portal.acm.org/citation.cfm?id=361275&amp;dl=ACM&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=A+hardware+architecture+for+implementing+protection+rings&amp;rft.jtitle=%5B%5BCommunications+of+the+ACM%5D%5D&amp;rft.aulast=Schroeder&amp;rft.aufirst=Michael+D.&amp;rft.au=Schroeder%2C%26%2332%3BMichael+D.&amp;rft.date=March+1972&amp;rft.volume=15&amp;rft.issue=3&amp;rft.pages=157%E2%80%93170&amp;rft_id=info:doi/10.1145%2F361268.361275&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D361275%26dl%3DACM%26coll%3D%26CFID%3D15151515%26CFTOKEN%3D6184618&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span>
</li>
<li>
<span class="citation book">Shaw, Alan C. (1974). <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=540329"><i>The logical design of Operating systems</i></a>. Prentice-Hall. p. 304. <a href="International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="http://en.m.wikipedia.org/wiki/Special:BookSources/0-13-540112-7" title="Special:BookSources/0-13-540112-7">0-13-540112-7</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://portal.acm.org/citation.cfm?id=540329">http://portal.acm.org/citation.cfm?id=540329</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=The+logical+design+of+Operating+systems&amp;rft.aulast=Shaw&amp;rft.aufirst=Alan+C.&amp;rft.au=Shaw%2C%26%2332%3BAlan+C.&amp;rft.date=1974&amp;rft.pages=p.%26nbsp%3B304&amp;rft.pub=Prentice-Hall&amp;rft.isbn=0-13-540112-7&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D540329&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span>
</li>
<li>
<span class="citation book"><a href="http://en.m.wikipedia.org/wiki/Andrew_S._Tanenbaum" title="Andrew S. Tanenbaum">Tanenbaum, Andrew S.</a> (1979). <i>Structured Computer Organization</i>. <a href="http://en.m.wikipedia.org/wiki/Englewood_Cliffs,_New_Jersey" title="Englewood Cliffs, New Jersey">Englewood Cliffs, New Jersey</a>: Prentice-Hall. <a href="International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="http://en.m.wikipedia.org/wiki/Special:BookSources/0-13-148521-0" title="Special:BookSources/0-13-148521-0">0-13-148521-0</a>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Structured+Computer+Organization&amp;rft.aulast=Tanenbaum&amp;rft.aufirst=Andrew+S.&amp;rft.au=Tanenbaum%2C%26%2332%3BAndrew+S.&amp;rft.date=1979&amp;rft.place=%5B%5BEnglewood+Cliffs%2C+New+Jersey%5D%5D&amp;rft.pub=Prentice-Hall&amp;rft.isbn=0-13-148521-0&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span>
</li>
<li>
<span class="citation Journal"><a href="http://en.m.wikipedia.org/wiki/William_Wulf" title="William Wulf">Wulf, W.</a>; E. Cohen, W. Corwin, A. Jones, R. Levin, C. Pierson, F. Pollack (June 1974). <a rel="nofollow" class="external text" href="http://www.cs.virginia.edu/papers/p337-wulf.pdf">"HYDRA: the kernel of a multiprocessor operating system"</a>. <i>Communications of the ACM</i> <b>17</b> (6): 337–345. <a href="Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F355616.364017">10.1145/355616.364017</a>. ISSN 0001-0782<span class="printonly">. <a rel="nofollow" class="external free" href="http://www.cs.virginia.edu/papers/p337-wulf.pdf">http://www.cs.virginia.edu/papers/p337-wulf.pdf</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=HYDRA%3A+the+kernel+of+a+multiprocessor+operating+system&amp;rft.jtitle=Communications+of+the+ACM&amp;rft.aulast=Wulf&amp;rft.aufirst=W.&amp;rft.au=Wulf%2C%26%2332%3BW.&amp;rft.date=June+1974&amp;rft.volume=17&amp;rft.issue=6&amp;rft.pages=337%E2%80%93345&amp;rft_id=info:doi/10.1145%2F355616.364017&amp;rft_id=http%3A%2F%2Fwww.cs.virginia.edu%2Fpapers%2Fp337-wulf.pdf&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span>
</li>
<li>
<span class="citation book">Baiardi, F.; A. Tomasi, <a rel="nofollow" class="external text" href="http://www.di.unipi.it/~vannesch/">M. Vanneschi</a> (1988) (in Italian). <a rel="nofollow" class="external text" href="http://www.pangloss.it/libro.php?isbn=882042746X&amp;id=4357&amp;PHPSESSID=9da1895b18ed1cda115cf1c7ace9bdf0"><i>Architettura dei Sistemi di Elaborazione, volume 1</i></a>. Franco Angeli. <a href="International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="http://en.m.wikipedia.org/wiki/Special:BookSources/88-204-2746-X" title="Special:BookSources/88-204-2746-X">88-204-2746-X</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://www.pangloss.it/libro.php?isbn=882042746X&amp;id=4357&amp;PHPSESSID=9da1895b18ed1cda115cf1c7ace9bdf0">http://www.pangloss.it/libro.php?isbn=882042746X&amp;id=4357&amp;PHPSESSID=9da1895b18ed1cda115cf1c7ace9bdf0</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Architettura+dei+Sistemi+di+Elaborazione%2C+volume+1&amp;rft.aulast=Baiardi&amp;rft.aufirst=F.&amp;rft.au=Baiardi%2C%26%2332%3BF.&amp;rft.date=1988&amp;rft.pub=Franco+Angeli&amp;rft.isbn=88-204-2746-X&amp;rft_id=http%3A%2F%2Fwww.pangloss.it%2Flibro.php%3Fisbn%3D882042746X%26id%3D4357%26PHPSESSID%3D9da1895b18ed1cda115cf1c7ace9bdf0&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span>
</li>
<li>
<span class="citation book">Swift, Michael M.; Brian N. Bershad, Henry M. Levy. <a rel="nofollow" class="external text" href="http://nooks.cs.washington.edu/nooks-tocs.pdf"><i>Improving the reliability of commodity operating systems</i></a><span class="printonly">. <a rel="nofollow" class="external free" href="http://nooks.cs.washington.edu/nooks-tocs.pdf">http://nooks.cs.washington.edu/nooks-tocs.pdf</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Improving+the+reliability+of+commodity+operating+systems&amp;rft.aulast=Swift&amp;rft.aufirst=Michael+M.&amp;rft.au=Swift%2C%26%2332%3BMichael+M.&amp;rft_id=http%3A%2F%2Fnooks.cs.washington.edu%2Fnooks-tocs.pdf&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span>
</li>
<li>
<span class="citation web"><a rel="nofollow" class="external text" href="http://doi.acm.org/10.1145/1047915.1047919">"Improving the reliability of commodity operating systems"</a>. Doi.acm.org. <a href="Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1002%2Fspe.4380201404">10.1002/spe.4380201404</a><span class="printonly">. <a rel="nofollow" class="external free" href="http://doi.acm.org/10.1145/1047915.1047919">http://doi.acm.org/10.1145/1047915.1047919</a></span><span class="reference-accessdate">. Retrieved 2010-06-19</span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Improving+the+reliability+of+commodity+operating+systems&amp;rft.atitle=&amp;rft.pub=Doi.acm.org&amp;rft_id=info:doi/10.1002%2Fspe.4380201404&amp;rft_id=http%3A%2F%2Fdoi.acm.org%2F10.1145%2F1047915.1047919&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span>
</li>
<li>
<span class="citation web">"ACM Transactions on Computer Systems (TOCS), v.23 n.1, p. 77–110, February 2005".</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=ACM+Transactions+on+Computer+Systems+%28TOCS%29%2C+v.23+n.1%2C+p.%26nbsp%3B77%E2%80%93110%2C+February+2005&amp;rft.atitle=&amp;rfr_id=info:sid/en.wikipedia.org:Kernel_(computing)"><span style="display: none;"> </span></span>
</li>
</ul>
</div>
<h2> <span class="mw-headline" id="Further_reading">Further reading</span>
</h2>
<ul>
<li>
<a href="http://en.m.wikipedia.org/wiki/Andrew_Tanenbaum" title="Andrew Tanenbaum" class="mw-redirect">Andrew Tanenbaum</a>, <i>Operating Systems – Design and Implementation (Third edition)</i>;</li>
<li>Andrew Tanenbaum, <i>Modern Operating Systems (Second edition)</i>;</li>
<li>
<span class="new" title="Daniel P. Bovet (page does not exist)">Daniel P. Bovet</span>, <span class="new" title="Marco Cesati (page does not exist)">Marco Cesati</span>, <i>The Linux Kernel</i>;</li>
<li>
<span class="new" title="David A. Peterson (page does not exist)">David A. Peterson</span>, <span class="new" title="Nitin Indurkhya (page does not exist)">Nitin Indurkhya</span>, Patterson, <i>Computer Organization and Design</i>, <span class="new" title="Morgan Koffman (page does not exist)">Morgan Koffman</span> <small>(<a href="http://en.m.wikipedia.org/wiki/Special:BookSources/1558604286" class="internal mw-magiclink-isbn">ISBN 1-55860-428-6</a>)</small>;</li>
<li>
<span class="new" title="B.S. Chalk (page does not exist)">B.S. Chalk</span>, <i>Computer Organisation and Architecture</i>, Macmillan P.(<a href="http://en.m.wikipedia.org/wiki/Special:BookSources/0333645510" class="internal mw-magiclink-isbn">ISBN 0-333-64551-0</a>).</li>
</ul>
<h2> <span class="mw-headline" id="External_links">External links</span>
</h2>
<table class="metadata mbox-small plainlinks" style="border:1px solid #aaa; background-color:#f9f9f9;"><tr>
<td class="mbox-image"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/9/91/Wikiversity-logo.svg/40px-Wikiversity-logo.svg.png" width="40" height="32" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/9/91/Wikiversity-logo.svg/60px-Wikiversity-logo.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/9/91/Wikiversity-logo.svg/80px-Wikiversity-logo.svg.png 2x"></td>
<td class="mbox-text plainlist" style="">Wikiversity has learning materials about <i><b><a href="http://en.wikiversity.org/wiki/Kernel_Models" class="extiw" title="v:Kernel Models">Kernel Models</a></b></i> at
<div style="margin-left: 10px;"><a href="http://en.wikiversity.org/wiki/Operating_Systems/Kernel_Models" class="extiw" title="v:Operating Systems/Kernel Models">Operating Systems/Kernel Models</a></div>
</td>
</tr></table>
<ul>
<li><a rel="nofollow" class="external text" href="http://widefox.pbwiki.com/Kernel%20Comparison%20Linux%20vs%20Windows">Detailed comparison between most popular operating system kernels</a></li>
</ul>

						<div class="section" id="mw-mf-language-section">
				<h2 id="section_language" class="section_heading">Read in another language</h2>
				<div id="content_language" class="content_block">
					<p>This article is available in 64 languages</p>
					<ul id="mw-mf-language-selection"><li><a href="http://af.m.wikipedia.org/wiki/Bedryfstelselkern" lang="af" hreflang="af">Afrikaans</a></li><li><a href="http://als.m.wikipedia.org/wiki/Kernel" lang="als" hreflang="als">Alemannisch</a></li><li><a href="http://ar.m.wikipedia.org/wiki/%D9%86%D9%88%D8%A7%D8%A9_(%D9%86%D8%B8%D9%85_%D8%AA%D8%B4%D8%BA%D9%8A%D9%84)" lang="ar" hreflang="ar">العربية</a></li><li><a href="http://as.m.wikipedia.org/wiki/%E0%A6%95%E0%A6%BE%E0%A7%B0%E0%A7%8D%E0%A6%A3%E0%A7%87%E0%A6%B2" lang="as" hreflang="as">অসমীয়া</a></li><li><a href="http://ast.m.wikipedia.org/wiki/Nucleu_(inform%C3%A1tica)" lang="ast" hreflang="ast">asturianu</a></li><li><a href="http://az.m.wikipedia.org/wiki/N%C3%BCv%C9%99_(kompyuter)" lang="az" hreflang="az">azərbaycanca</a></li><li><a href="http://bn.m.wikipedia.org/wiki/%E0%A6%95%E0%A6%BE%E0%A6%B0%E0%A7%8D%E0%A6%A8%E0%A7%87%E0%A6%B2_(%E0%A6%95%E0%A6%AE%E0%A7%8D%E0%A6%AA%E0%A6%BF%E0%A6%89%E0%A6%9F%E0%A6%BE%E0%A6%B0_%E0%A6%AC%E0%A6%BF%E0%A6%9C%E0%A7%8D%E0%A6%9E%E0%A6%BE%E0%A6%A8)" lang="bn" hreflang="bn">বাংলা</a></li><li><a href="http://be.m.wikipedia.org/wiki/%D0%AF%D0%B4%D1%80%D0%BE_%D0%B0%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D1%8B%D0%B9%D0%BD%D0%B0%D0%B9_%D1%81%D1%96%D1%81%D1%82%D1%8D%D0%BC%D1%8B" lang="be" hreflang="be">беларуская</a></li><li><a href="http://bs.m.wikipedia.org/wiki/Kernel" lang="bs" hreflang="bs">bosanski</a></li><li><a href="http://ca.m.wikipedia.org/wiki/Nucli_del_sistema_operatiu" lang="ca" hreflang="ca">català</a></li><li><a href="http://cs.m.wikipedia.org/wiki/Kernel" lang="cs" hreflang="cs">česky</a></li><li><a href="http://da.m.wikipedia.org/wiki/Kerne_(styresystem)" lang="da" hreflang="da">dansk</a></li><li><a href="http://de.m.wikipedia.org/wiki/Betriebssystemkern" lang="de" hreflang="de">Deutsch</a></li><li><a href="http://et.m.wikipedia.org/wiki/Tuum_(informaatika)" lang="et" hreflang="et">eesti</a></li><li><a href="http://el.m.wikipedia.org/wiki/%CE%A0%CF%85%CF%81%CE%AE%CE%BD%CE%B1%CF%82_(%CF%85%CF%80%CE%BF%CE%BB%CE%BF%CE%B3%CE%B9%CF%83%CF%84%CE%AD%CF%82)" lang="el" hreflang="el">Ελληνικά</a></li><li><a href="http://es.m.wikipedia.org/wiki/N%C3%BAcleo_(inform%C3%A1tica)" lang="es" hreflang="es">español</a></li><li><a href="http://eo.m.wikipedia.org/wiki/Kerno_(operaciumo)" lang="eo" hreflang="eo">Esperanto</a></li><li><a href="http://fa.m.wikipedia.org/wiki/%D9%87%D8%B3%D8%AA%D9%87_%D8%B3%DB%8C%D8%B3%D8%AA%D9%85%E2%80%8C%D8%B9%D8%A7%D9%85%D9%84" lang="fa" hreflang="fa">فارسی</a></li><li><a href="http://fr.m.wikipedia.org/wiki/Noyau_de_syst%C3%A8me_d%27exploitation" lang="fr" hreflang="fr">français</a></li><li><a href="http://gl.m.wikipedia.org/wiki/Kernel" lang="gl" hreflang="gl">galego</a></li><li><a href="http://ko.m.wikipedia.org/wiki/%EC%BB%A4%EB%84%90_(%EC%BB%B4%ED%93%A8%ED%8C%85)" lang="ko" hreflang="ko">한국어</a></li><li><a href="http://hr.m.wikipedia.org/wiki/Jezgra_(ra%C4%8Dunarstvo)" lang="hr" hreflang="hr">hrvatski</a></li><li><a href="http://id.m.wikipedia.org/wiki/Kernel_(ilmu_komputer)" lang="id" hreflang="id">Bahasa Indonesia</a></li><li><a href="http://ia.m.wikipedia.org/wiki/Nucleo_(informatica)" lang="ia" hreflang="ia">interlingua</a></li><li><a href="http://is.m.wikipedia.org/wiki/St%C3%BDrikerfiskjarni" lang="is" hreflang="is">íslenska</a></li><li><a href="http://it.m.wikipedia.org/wiki/Kernel" lang="it" hreflang="it">italiano</a></li><li><a href="http://he.m.wikipedia.org/wiki/%D7%9C%D7%99%D7%91%D7%94_(%D7%9E%D7%A2%D7%A8%D7%9B%D7%95%D7%AA_%D7%94%D7%A4%D7%A2%D7%9C%D7%94)" lang="he" hreflang="he">עברית</a></li><li><a href="http://ku.m.wikipedia.org/wiki/Kernel" lang="ku" hreflang="ku">Kurdî</a></li><li><a href="http://lo.m.wikipedia.org/wiki/%E0%BB%81%E0%BA%81%E0%BA%99%E0%BA%81%E0%BA%B2%E0%BA%87" lang="lo" hreflang="lo">ລາວ</a></li><li><a href="http://la.m.wikipedia.org/wiki/Nucleus_(informatica)" lang="la" hreflang="la">Latina</a></li><li><a href="http://lv.m.wikipedia.org/wiki/Kodols_(oper%C4%93t%C4%81jsist%C4%93ma)" lang="lv" hreflang="lv">latviešu</a></li><li><a href="http://lt.m.wikipedia.org/wiki/Branduolys_(OS)" lang="lt" hreflang="lt">lietuvių</a></li><li><a href="http://hu.m.wikipedia.org/wiki/Rendszermag" lang="hu" hreflang="hu">magyar</a></li><li><a href="http://mk.m.wikipedia.org/wiki/%D0%88%D0%B0%D0%B4%D1%80%D0%BE_%D0%BD%D0%B0_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%B5%D0%BD_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC" lang="mk" hreflang="mk">македонски</a></li><li><a href="http://ml.m.wikipedia.org/wiki/%E0%B4%95%E0%B5%86%E0%B5%BC%E0%B4%A3%E0%B5%BD_(%E0%B4%95%E0%B4%AE%E0%B5%8D%E0%B4%AA%E0%B5%8D%E0%B4%AF%E0%B5%82%E0%B4%9F%E0%B5%8D%E0%B4%9F%E0%B4%BF%E0%B4%99%E0%B5%8D)" lang="ml" hreflang="ml">മലയാളം</a></li><li><a href="http://mr.m.wikipedia.org/wiki/%E0%A4%95%E0%A5%87%E0%A4%B0%E0%A5%8D%E0%A4%A8%E0%A5%87%E0%A4%B2" lang="mr" hreflang="mr">मराठी</a></li><li><a href="http://ms.m.wikipedia.org/wiki/Inti_(sains_komputer)" lang="ms" hreflang="ms">Bahasa Melayu</a></li><li><a href="http://my.m.wikipedia.org/wiki/%E1%80%80%E1%80%AC%E1%80%94%E1%80%B2%E1%80%9C%E1%80%BA_(%E1%80%80%E1%80%BD%E1%80%94%E1%80%BA%E1%80%95%E1%80%BB%E1%80%B0%E1%80%90%E1%80%AC)" lang="my" hreflang="my">မြန်မာဘာသာ</a></li><li><a href="http://nl.m.wikipedia.org/wiki/Kernel" lang="nl" hreflang="nl">Nederlands</a></li><li><a href="http://ja.m.wikipedia.org/wiki/%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB" lang="ja" hreflang="ja">日本語</a></li><li><a href="http://no.m.wikipedia.org/wiki/Kjerne_(operativsystem)" lang="no" hreflang="no">norsk (bokmål)‎</a></li><li><a href="http://nn.m.wikipedia.org/wiki/Operativsystemkjerne" lang="nn" hreflang="nn">norsk (nynorsk)‎</a></li><li><a href="http://or.m.wikipedia.org/wiki/%E0%AC%95%E0%AC%B0%E0%AD%8D%E0%AC%A8%E0%AD%87%E0%AC%B2_(%E0%AC%95%E0%AC%AE%E0%AD%8D%E0%AC%AA%E0%AD%8D%E0%AD%9F%E0%AD%81%E0%AC%9F%E0%AC%BF%E0%AC%99%E0%AD%8D%E0%AC%97)" lang="or" hreflang="or">ଓଡ଼ିଆ</a></li><li><a href="http://pa.m.wikipedia.org/wiki/%E0%A8%95%E0%A8%B0%E0%A8%A8%E0%A8%B2" lang="pa" hreflang="pa">ਪੰਜਾਬੀ</a></li><li><a href="http://pl.m.wikipedia.org/wiki/J%C4%85dro_systemu_operacyjnego" lang="pl" hreflang="pl">polski</a></li><li><a href="http://pt.m.wikipedia.org/wiki/N%C3%BAcleo_(inform%C3%A1tica)" lang="pt" hreflang="pt">português</a></li><li><a href="http://ro.m.wikipedia.org/wiki/Nucleu_(sistem_de_operare)" lang="ro" hreflang="ro">română</a></li><li><a href="http://ru.m.wikipedia.org/wiki/%D0%AF%D0%B4%D1%80%D0%BE_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%BE%D0%B9_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B" lang="ru" hreflang="ru">русский</a></li><li><a href="http://scn.m.wikipedia.org/wiki/Kernel" lang="scn" hreflang="scn">sicilianu</a></li><li><a href="http://si.m.wikipedia.org/wiki/%E0%B6%9A%E0%B6%BB%E0%B7%8A%E0%B6%B1%E0%B6%BD%E0%B6%BA_(%E0%B6%B4%E0%B6%BB%E0%B7%92%E0%B6%9C%E0%B6%AB%E0%B6%9A)" lang="si" hreflang="si">සිංහල</a></li><li><a href="http://simple.m.wikipedia.org/wiki/Kernel_(computer_science)" lang="simple" hreflang="simple">Simple English</a></li><li><a href="http://sk.m.wikipedia.org/wiki/Jadro_(informatika)" lang="sk" hreflang="sk">slovenčina</a></li><li><a href="http://sl.m.wikipedia.org/wiki/Jedro_(ra%C4%8Dunalni%C5%A1tvo)" lang="sl" hreflang="sl">slovenščina</a></li><li><a href="http://sr.m.wikipedia.org/wiki/Jezgro_operativnog_sistema" lang="sr" hreflang="sr">српски / srpski</a></li><li><a href="http://sh.m.wikipedia.org/wiki/Kernel" lang="sh" hreflang="sh">srpskohrvatski / српскохрватски</a></li><li><a href="http://fi.m.wikipedia.org/wiki/K%C3%A4ytt%C3%B6j%C3%A4rjestelm%C3%A4n_ydin" lang="fi" hreflang="fi">suomi</a></li><li><a href="http://sv.m.wikipedia.org/wiki/Operativsystemk%C3%A4rna" lang="sv" hreflang="sv">svenska</a></li><li><a href="http://ta.m.wikipedia.org/wiki/%E0%AE%95%E0%AE%B0%E0%AF%81%E0%AE%B5%E0%AE%95%E0%AE%AE%E0%AF%8D" lang="ta" hreflang="ta">தமிழ்</a></li><li><a href="http://th.m.wikipedia.org/wiki/%E0%B9%80%E0%B8%84%E0%B8%AD%E0%B8%A3%E0%B9%8C%E0%B9%80%E0%B8%99%E0%B8%A5" lang="th" hreflang="th">ไทย</a></li><li><a href="http://tr.m.wikipedia.org/wiki/%C3%87ekirdek_(bilgisayar_bilimi)" lang="tr" hreflang="tr">Türkçe</a></li><li><a href="http://uk.m.wikipedia.org/wiki/%D0%AF%D0%B4%D1%80%D0%BE_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D1%96%D0%B9%D0%BD%D0%BE%D1%97_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B8" lang="uk" hreflang="uk">українська</a></li><li><a href="http://ur.m.wikipedia.org/wiki/Kernel" lang="ur" hreflang="ur">اردو</a></li><li><a href="http://vi.m.wikipedia.org/wiki/Nh%C3%A2n_h%E1%BB%87_%C4%91i%E1%BB%81u_h%C3%A0nh" lang="vi" hreflang="vi">Tiếng Việt</a></li><li><a href="http://zh.m.wikipedia.org/wiki/%E5%86%85%E6%A0%B8" lang="zh" hreflang="zh">中文</a></li></ul>
				</div>
			</div>			</div><!-- close #content_wrapper -->
			<div id="footer">
			<h2 class="section_heading" id="section_footer">
		<img src="http://bits.wikimedia.org/static-1.21wmf3/extensions/MobileFrontend/stylesheets/common/images/logo-copyright-en.png" class="license" alt="Wikipedia ®" />	</h2>
	<div class="content_block" id="content_footer">
		<ul class="settings">
			<li>
				<span class="left separator"><a id="mw-mf-display-toggle" href="http://en.wikipedia.org/w/index.php?title=Kernel_(computer_science)&amp;mobileaction=toggle_view_desktop">Desktop</a></span><span class="right">Mobile</span>
			</li>
			<li class="notice">
				Article by <a href="http://en.m.wikipedia.org/w/index.php?title=Kernel_(computer_science)&amp;action=history">contributors</a> like you<br>
				Content available under <a href="Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License?useformat=mobile">CC BY-SA 3.0</a>				<span>| <a href="http://wikimediafoundation.org/wiki/Terms_of_use?useformat=mobile">Terms of Use</a></span>
			</li>
		</ul>
		<ul class="links">
						<li>
			<a href='http://en.m.wikipedia.org/w/index.php?title=Special:MobileFeedback&amp;returnto=Kernel+%28computing%29&amp;feedbacksource=MobileFrontend'>
				Contact Wikipedia			</a>
			</li><li>
						<a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy</a></li><li>
			<a href="Wikipedia:About" title="Wikipedia:About">About</a></li><li>
			<a href="Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
		</ul>
	</div><!-- close footer.div / #content_footer -->
	</div><!-- close #footer -->
					</div><!-- close #mw-mf-page-center -->
		</div><!-- close #mw-mf-viewport -->
		
					</body>
	</html>