<!doctype html>
	<html lang="en" dir="ltr" class="">
	<head>
		<title>Quicksort - Wikipedia, the free encyclopedia</title>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<meta name="robots" content="noindex,nofollow"/>		<link rel="stylesheet" href="http://bits.wikimedia.org/en.wikipedia.org/load.php?debug=false&amp;lang=en&amp;modules=mobile%7Cmobile.production-only%2Cproduction-jquery%7Cmobile.device.default&amp;only=styles&amp;skin=mobile&amp;version=1352163471&amp;*" />
<link rel="stylesheet" href="http://bits.wikimedia.org/en.wikipedia.org/load.php?debug=false&amp;lang=en&amp;modules=mobile.site&amp;only=styles&amp;skin=mobile&amp;*" />		<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png" />		<script type="text/javascript">
			var _mwStart = +new Date;
			window._evq = window._evq || [];
			if ( typeof console === 'undefined' ) {
				console = { log: function() {} };
			}
			if( typeof mw === 'undefined' ) {
				mw = {};
			}
			var mwMobileFrontendConfig = {"messages":{"mobile-frontend-watchlist-add":"Added $1 to your watchlist","mobile-frontend-watchlist-removed":"Removed $1 from your watchlist","mobile-frontend-watchlist-view":"View your watchlist","mobile-frontend-ajax-random-heading":"Locating knowledge...","mobile-frontend-ajax-random-quote":"Intellectual growth should commence at birth and cease only at death","mobile-frontend-ajax-random-quote-author":"Albert Einstein","mobile-frontend-ajax-random-question":"Read this article?","mobile-frontend-ajax-random-yes":"Yes","mobile-frontend-ajax-random-retry":"Try again","mobile-frontend-ajax-page-loading":"Loading $1","mobile-frontend-page-saving":"Saving $1","mobile-frontend-ajax-page-error":"Whoops! Something went wrong there. Please try refreshing your browser window.","mobile-frontend-meta-data-issues":"This article has some issues","mobile-frontend-meta-data-issues-header":"Issues","expand-section":"Show","collapse-section":"Hide","remove-results":"Back...","mobile-frontend-search-noresults":"No article titles match your search. Change your search, or press the keyboard search button to search inside articles.","mobile-frontend-search-help":"Type search term above and matching article titles will appear here.","contents-heading":"Contents","language-heading":"Read this article in","mobile-frontend-close-section":"Close this section","mobile-frontend-language-footer":"<a href="http://en.m.wikipedia.org/wiki/\&quot;\/wiki\/Special:MobileOptions\/Language\&quot;">Note: This article may not be written in your preferred language. You can see which languages Wikipedia supports by clicking here.<\/a>","mobile-frontend-language-site-choose":"Search language","mobile-frontend-language-site-nomatches":"No matching languages"},"settings":{"action":"","authenticated":false,"scriptPath":"\/w","shim":"\/\/bits.wikimedia.org\/static-1.21wmf3\/extensions\/MobileFrontend\/stylesheets\/common\/images\/blank.gif","pageUrl":"\/wiki\/$1","beta":null,"title":"Quicksort","useFormatCookieName":"mf_mobileFormat","useFormatCookieDuration":-1,"useFormatCookieDomain":"en.wikipedia.org","useFormatCookiePath":"\/","stopMobileRedirectCookieName":"stopMobileRedirect","stopMobileRedirectCookieDuration":15552000,"stopMobileRedirectCookieDomain":".wikipedia.org","hookOptions":""}};
			function _mwLogEvent( data, additionalInformation ) {
				var timestamp = + new Date;
				var ev = { event_id: 'mobile', delta: timestamp - _mwStart, data: data, beta: mwMobileFrontendConfig.settings.beta,
					session: _mwStart, page: mwMobileFrontendConfig.settings.title, info: additionalInformation || '' };
				_evq.push( ev );
				console.log( typeof JSON === 'undefined' ? ev : JSON.stringify( ev ) );
			}
		</script>
				<link rel="canonical" href="http://en.wikipedia.org/wiki/Quicksort" >
	</head>
	<body class="mobile live">
				<div id="mw-mf-viewport">
		<div id="mw-mf-page-left">
		<div id='mw-mf-content-left'>
		<ul id="mw-mf-menu-main">
			<li class='icon'><a href="Main_Page"
				title="Home">
				Home</a></li>
			<li class='icon2'><a href="Special:Random#mw-mf-page-left" id="randomButton"
				title="Random"
				class="button">Random</a></li>
						<li class='icon5'>
				<a href="http://en.m.wikipedia.org/w/index.php?title=Special:MobileOptions&amp;returnto=Quicksort"
					title="Settings">
				Settings				</a>
			</li>
					</ul>
		</div>
		</div>
		<div id='mw-mf-page-center'>
									<div id="mw-mf-header">
		<a title="Open main menu" href="Special:MobileMenu#mw-mf-page-left" id="mw-mf-main-menu-button">				<img alt="menu"
				src="http://bits.wikimedia.org/static-1.21wmf3/extensions/MobileFrontend/stylesheets/common/images/blank.gif">
		</a>			<form id="mw-mf-searchForm" action="http://en.m.wikipedia.org/w/index.php" class="search_bar" method="get">
			<input type="hidden" value="Special:Search" name="title" />
			<div id="mw-mf-sq" class="divclearable">
				<input type="search" name="search" id="mw-mf-search" size="22" value="" autocomplete="off" maxlength="1024" class="search"
					placeholder="Search Wikipedia"
					/>
				<img src="http://bits.wikimedia.org/static-1.21wmf3/extensions/MobileFrontend/stylesheets/common/images/blank.gif" alt="Clear" class="clearlink" id="mw-mf-clearsearch" title="Clear"/>
				<input class='searchSubmit' type="submit" value="Go">
			</div>
		</form>
	</div>
	<div id="results"></div>
		<div class='show ' id='content_wrapper'>
						<h1 id="firstHeading">Quicksort</h1>			
<table class="infobox" cellspacing="3" style="border-spacing: 3px; width:22em;">
<caption class="" style="">Quicksort</caption>
<tr class="">
<td colspan="2" class="" style="text-align:center;">
<a href="http://en.m.wikipedia.org/wiki/File:Sorting_quicksort_anim.gif" class="image" title="Quicksort in action on a list of numbers. The horizontal lines are pivot values."><img alt="Quicksort in action on a list of numbers. The horizontal lines are pivot values." src="http://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" width="280" height="214"></a><br><span style="">Visualization of the quicksort algorithm. The horizontal lines are pivot values.</span>
</td>
</tr>
<tr class="">
<th scope="row" style="text-align:left;">Class</th>
<td class="" style=""><a href="http://en.m.wikipedia.org/wiki/Sorting_algorithm" title="Sorting algorithm">Sorting algorithm</a></td>
</tr>
<tr class="">
<th scope="row" style="text-align:left;"><a href="http://en.m.wikipedia.org/wiki/Best,_worst_and_average_case" title="Best, worst and average case">Worst case performance</a></th>
<td class="" style="">O(<i>n</i><sup>2</sup>)</td>
</tr>
<tr class="">
<th scope="row" style="text-align:left;"><a href="http://en.m.wikipedia.org/wiki/Best,_worst_and_average_case" title="Best, worst and average case">Best case performance</a></th>
<td class="" style="">O(<i>n</i> log <i>n)</i>
</td>
</tr>
<tr class="">
<th scope="row" style="text-align:left;"><a href="http://en.m.wikipedia.org/wiki/Best,_worst_and_average_case" title="Best, worst and average case">Average case performance</a></th>
<td class="" style="">O(<i>n</i> log <i>n</i>)</td>
</tr>
<tr class="">
<th scope="row" style="text-align:left;"><a href="http://en.m.wikipedia.org/wiki/Best,_worst_and_average_case" title="Best, worst and average case">Worst case space complexity</a></th>
<td class="" style="">O(<i>n</i>) auxiliary (naive)<br>
O(log <i>n</i>) auxiliary (Sedgewick 1978)</td>
</tr>
</table>
<p><b>Quicksort</b> is a <a href="http://en.m.wikipedia.org/wiki/Sorting_algorithm" title="Sorting algorithm">sorting algorithm</a> developed by <a href="http://en.m.wikipedia.org/wiki/Tony_Hoare" title="Tony Hoare">Tony Hoare</a> that, <a href="http://en.m.wikipedia.org/wiki/Best,_worst_and_average_case" title="Best, worst and average case">on average</a>, makes O(<i>n</i> log <i>n</i>) comparisons to sort <i>n</i> items. It is also known as <b>partition-exchange sort</b>. In the <a href="http://en.m.wikipedia.org/wiki/Best,_worst_and_average_case" title="Best, worst and average case">worst case</a>, it makes O(<i>n</i><sup>2</sup>) comparisons, though this behavior is rare. Quicksort is often faster in practice than other O(<i>n</i> log <i>n</i>) algorithms.<sup id="cite_ref-0" class="reference"><a href="Qsort#cite_note-0"><span>[</span>1<span>]</span></a></sup> Additionally, quicksort's sequential and localized memory references work well with a <a href="http://en.m.wikipedia.org/wiki/CPU_cache" title="CPU cache">cache</a>. Quicksort can be implemented with an <a href="http://en.m.wikipedia.org/wiki/In-place_algorithm" title="In-place algorithm">in-place partitioning algorithm</a>, so the entire sort can be done with only O(log <i>n</i>) additional space.<sup id="cite_ref-1" class="reference"><a href="Qsort#cite_note-1"><span>[</span>2<span>]</span></a></sup></p>
<p>Quicksort is a <a href="http://en.m.wikipedia.org/wiki/Comparison_sort" title="Comparison sort">comparison sort</a> and, in efficient implementations, is not a <a href="http://en.m.wikipedia.org/wiki/Stable_sort" title="Stable sort" class="mw-redirect">stable sort</a>.</p>
<h2> <span class="mw-headline" id="History">History</span>
</h2>
<p>The quicksort algorithm was developed in 1960 by <a href="http://en.m.wikipedia.org/wiki/Tony_Hoare" title="Tony Hoare">Tony Hoare</a> while in the <a href="http://en.m.wikipedia.org/wiki/Soviet_Union" title="Soviet Union">Soviet Union</a>, as a visiting student at <a href="http://en.m.wikipedia.org/wiki/Moscow_State_University" title="Moscow State University">Moscow State University</a>. At that time, Hoare worked in a project on <a href="http://en.m.wikipedia.org/wiki/Machine_translation" title="Machine translation">machine translation</a> for the <a href="http://en.m.wikipedia.org/wiki/National_Physical_Laboratory,_UK" title="National Physical Laboratory, UK" class="mw-redirect">National Physical Laboratory</a>. He developed the algorithm in order to sort the words to be translated, to make them more easily matched to an already-sorted Russian-to-English dictionary that was stored on magnetic tape.<sup id="cite_ref-2" class="reference"><a href="Qsort#cite_note-2"><span>[</span>3<span>]</span></a></sup></p>
<h2> <span class="mw-headline" id="Algorithm">Algorithm</span>
</h2>
<p>Quicksort is a <a href="http://en.m.wikipedia.org/wiki/Divide_and_conquer_algorithm" title="Divide and conquer algorithm">divide and conquer algorithm</a>. Quicksort first divides a large <a href="http://en.m.wikipedia.org/wiki/List_(computing)" title="List (computing)" class="mw-redirect">list</a> into two smaller sub-lists: the low elements and the high elements. Quicksort can then recursively sort the sub-lists.</p>
<p>The steps are:</p>
<ol>
<li>Pick an element, called a <a href="http://en.m.wikipedia.org/wiki/Pivot_element" title="Pivot element"><i>pivot</i></a>, from the list.</li>
<li>Reorder the list so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position. This is called the <b>partition</b> operation.</li>
<li>
<a href="http://en.m.wikipedia.org/wiki/Recursion_(computer_science)" title="Recursion (computer science)">Recursively</a> sort the sub-list of lesser elements and the sub-list of greater elements.</li>
</ol>
<p>The <a href="http://en.m.wikipedia.org/wiki/Base_case#Recursive_programming" title="Base case">base case</a> of the recursion are lists of size zero or one, which never need to be sorted.</p>
<h3> <span class="mw-headline" id="Simple_version">Simple version</span>
</h3>
<p>In simple <a href="http://en.m.wikipedia.org/wiki/Pseudocode" title="Pseudocode">pseudocode</a>, the algorithm might be expressed as this:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="javascript source-javascript">
<pre class="de1">
  <span class="kw1">function</span> quicksort<span class="br0">(</span><span class="st0">'array'</span><span class="br0">)</span>
      <span class="kw1">if</span> length<span class="br0">(</span><span class="st0">'array'</span><span class="br0">)</span> ≤ <span class="nu0">1</span>
          <span class="kw1">return</span> <span class="st0">'array'</span>  <span class="co1">// an array of zero or one elements is already sorted</span>
      select and remove a pivot value <span class="st0">'pivot'</span> from <span class="st0">'array'</span>
      create empty lists <span class="st0">'less'</span> and <span class="st0">'greater'</span>
      <span class="kw1">for</span> each <span class="st0">'x'</span> <span class="kw1">in</span> <span class="st0">'array'</span>
          <span class="kw1">if</span> <span class="st0">'x'</span> ≤ <span class="st0">'pivot'</span> then append <span class="st0">'x'</span> to <span class="st0">'less'</span>
          <span class="kw1">else</span> append <span class="st0">'x'</span> to <span class="st0">'greater'</span>
      <span class="kw1">return</span> concatenate<span class="br0">(</span>quicksort<span class="br0">(</span><span class="st0">'less'</span><span class="br0">)</span><span class="sy0">,</span> <span class="st0">'pivot'</span><span class="sy0">,</span> quicksort<span class="br0">(</span><span class="st0">'greater'</span><span class="br0">)</span><span class="br0">)</span> <span class="co1">// two recursive calls</span>
</pre>
</div>
</div>
<div class="thumb tright">
<div class="thumbinner" style="width:202px;">
<a href="http://en.m.wikipedia.org/w/index.php?title=File:Quicksort-diagram.svg&amp;page=1" class="image"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/a/af/Quicksort-diagram.svg/200px-Quicksort-diagram.svg.png" width="200" height="400" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/a/af/Quicksort-diagram.svg/300px-Quicksort-diagram.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/a/af/Quicksort-diagram.svg/400px-Quicksort-diagram.svg.png 2x"></a>
<div class="thumbcaption">

Full example of quicksort on a random set of numbers. The shaded element is the pivot. It is always chosen as the last element of the partition. However, always choosing the last element in the partition as the pivot in this way results in poor performance (<img class="tex" alt="O(n^2)" src="http://upload.wikimedia.org/math/1/8/9/189317b4b935a745fcfaf95940d2b4f0.png">) on <i>already sorted</i> lists, or lists of identical elements. Since sub-lists of sorted / identical elements crop up a lot towards the end of a sorting procedure on a large set, versions of the quicksort algorithm which choose the pivot as the middle element run much more quickly than the algorithm described in this diagram on large sets of numbers.</div>
</div>
</div>
<p>Notice that we only examine elements by comparing them to other elements. This makes quicksort a <a href="http://en.m.wikipedia.org/wiki/Comparison_sort" title="Comparison sort">comparison sort</a>. This version is also a <a href="http://en.m.wikipedia.org/wiki/Stable_sort" title="Stable sort" class="mw-redirect">stable sort</a> (assuming that the "for each" method retrieves elements in original order, and the pivot selected is the last among those of equal value).</p>
<p>The correctness of the partition algorithm is based on the following two arguments:</p>
<ul>
<li>At each iteration, all the elements processed so far are in the desired position: before the pivot if less than the pivot's value, after the pivot if greater than the pivot's value (<a href="http://en.m.wikipedia.org/wiki/Loop_invariant" title="Loop invariant">loop invariant</a>).</li>
<li>Each iteration leaves one fewer element to be processed (<a href="http://en.m.wikipedia.org/wiki/Loop_variant" title="Loop variant">loop variant</a>).</li>
</ul>
<p>The correctness of the overall algorithm can be proven via induction: for zero or one element, the algorithm leaves the data unchanged; for a larger data set it produces the concatenation of two parts, elements less than the pivot and elements greater than it, themselves sorted by the recursive hypothesis.</p>
<div class="thumb tleft">
<div class="thumbinner" style="width:302px;">
<a href="http://en.m.wikipedia.org/wiki/File:Quicksort-example.gif" class="image"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/9/9c/Quicksort-example.gif" width="300" height="180" class="thumbimage"></a>
<div class="thumbcaption">

An example of quicksort.</div>
</div>
</div>
<div class="thumb tleft">
<div class="thumbinner" style="width:202px;">
<a href="http://en.m.wikipedia.org/w/index.php?title=File:Partition_example.svg&amp;page=1" class="image"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/8/84/Partition_example.svg/200px-Partition_example.svg.png" width="200" height="244" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/8/84/Partition_example.svg/300px-Partition_example.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/8/84/Partition_example.svg/400px-Partition_example.svg.png 2x"></a>
<div class="thumbcaption">

In-place partition in action on a small list. The boxed element is the pivot element, blue elements are less or equal, and red elements are larger.</div>
</div>
</div>
<table style="clear:both;"><tr>
<td></td>
</tr></table>
<h3> <span class="mw-headline" id="In-place_version">In-place version</span>
</h3>
<p>The disadvantage of the simple version above is that it requires O(<i>n</i>) extra storage space, which is as bad as <a href="http://en.m.wikipedia.org/wiki/Merge_sort" title="Merge sort">merge sort</a>. The additional memory allocations required can also drastically impact speed and cache performance in practical implementations. There is a more complex version which uses an <a href="http://en.m.wikipedia.org/wiki/In-place_algorithm" title="In-place algorithm">in-place</a> partition algorithm and can achieve the complete sort using O(log <i>n</i>) space (not counting the input) on average (for the <a href="Call_stack" title="Call stack">call stack</a>). We start with a partition function:</p>
<table><tr>
<td>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="javascript source-javascript">
<pre class="de1">
   <span class="co1">// left is the index of the leftmost element of the array</span>
   <span class="co1">// right is the index of the rightmost element of the array (inclusive)</span>
   <span class="co1">//   number of elements in subarray = right-left+1</span>
   <span class="kw1">function</span> partition<span class="br0">(</span>array<span class="sy0">,</span> <span class="st0">'left'</span><span class="sy0">,</span> <span class="st0">'right'</span><span class="sy0">,</span> <span class="st0">'pivotIndex'</span><span class="br0">)</span>
      <span class="st0">'pivotValue'</span> <span class="sy0">:=</span> array<span class="br0">[</span><span class="st0">'pivotIndex'</span><span class="br0">]</span>
      swap array<span class="br0">[</span><span class="st0">'pivotIndex'</span><span class="br0">]</span> and array<span class="br0">[</span><span class="st0">'right'</span><span class="br0">]</span>  <span class="co1">// Move pivot to end</span>
      <span class="st0">'storeIndex'</span> <span class="sy0">:=</span> <span class="st0">'left'</span>
      <span class="kw1">for</span> <span class="st0">'i'</span> from <span class="st0">'left'</span> to <span class="st0">'right'</span> <span class="sy0">-</span> <span class="nu0">1</span>  <span class="co1">// left ≤ i &lt; right</span>
          <span class="kw1">if</span> array<span class="br0">[</span><span class="st0">'i'</span><span class="br0">]</span> <span class="sy0">&lt;</span> <span class="st0">'pivotValue'</span>
              swap array<span class="br0">[</span><span class="st0">'i'</span><span class="br0">]</span> and array<span class="br0">[</span><span class="st0">'storeIndex'</span><span class="br0">]</span>
              <span class="st0">'storeIndex'</span> <span class="sy0">:=</span> <span class="st0">'storeIndex'</span> <span class="sy0">+</span> <span class="nu0">1</span>
      swap array<span class="br0">[</span><span class="st0">'storeIndex'</span><span class="br0">]</span> and array<span class="br0">[</span><span class="st0">'right'</span><span class="br0">]</span>  <span class="co1">// Move pivot to its final place</span>
      <span class="kw1">return</span> <span class="st0">'storeIndex'</span>
</pre>
</div>
</div>
</td>
</tr></table>
<p>This is the in-place partition algorithm. It partitions the portion of the array between indexes <i>left</i> and <i>right</i>, inclusively, by moving all elements less than <code>array[pivotIndex]</code> before the pivot, and the equal or greater elements after it. In the process it also finds the final position for the pivot element, which it returns. It temporarily moves the pivot element to the end of the subarray, so that it doesn't get in the way. Because it only uses exchanges, the final list has the same elements as the original list. Notice that an element may be exchanged multiple times before reaching its final place. Also, in case of pivot duplicates in the input array, they can be spread across the right subarray, in any order. This doesn't represent a partitioning failure, as further sorting will reposition and finally "glue" them together.</p>
<p>This form of the partition algorithm is not the original form; multiple variations can be found in various textbooks, such as versions not having the storeIndex. However, this form is probably the easiest to understand.</p>
<p>Once we have this, writing quicksort itself is easy:</p>
<table><tr>
<td>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="javascript source-javascript">
<pre class="de1">
  <span class="kw1">function</span> quicksort<span class="br0">(</span>array<span class="sy0">,</span> <span class="st0">'left'</span><span class="sy0">,</span> <span class="st0">'right'</span><span class="br0">)</span>
 
      <span class="co1">// If the list has 2 or more items</span>
      <span class="kw1">if</span> <span class="st0">'left'</span> <span class="sy0">&lt;</span> <span class="st0">'right'</span>
 
          <span class="co1">// See "Choice of pivot" section below for possible choices</span>
          choose any <span class="st0">'pivotIndex'</span> such that <span class="st0">'left'</span> ≤ <span class="st0">'pivotIndex'</span> ≤ <span class="st0">'right'</span>
 
          <span class="co1">// Get lists of bigger and smaller items and final position of pivot</span>
          <span class="st0">'pivotNewIndex'</span> <span class="sy0">:=</span> partition<span class="br0">(</span>array<span class="sy0">,</span> <span class="st0">'left'</span><span class="sy0">,</span> <span class="st0">'right'</span><span class="sy0">,</span> <span class="st0">'pivotIndex'</span><span class="br0">)</span>
 
          <span class="co1">// Recursively sort elements smaller than the pivot</span>
          quicksort<span class="br0">(</span>array<span class="sy0">,</span> <span class="st0">'left'</span><span class="sy0">,</span> <span class="st0">'pivotNewIndex'</span> <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span>
 
          <span class="co1">// Recursively sort elements at least as big as the pivot</span>
          quicksort<span class="br0">(</span>array<span class="sy0">,</span> <span class="st0">'pivotNewIndex'</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="st0">'right'</span><span class="br0">)</span>
</pre>
</div>
</div>
</td>
</tr></table>
<p>Each recursive call to this <i>quicksort</i> function reduces the size of the array being sorted by at least one element, since in each invocation the element at <i>pivotNewIndex</i> is placed in its final position. Therefore, this algorithm is guaranteed to terminate after at most <i>n</i> recursive calls. However, since <i>partition</i> reorders elements within a partition, this version of quicksort is not a stable sort.</p>
<h3> <span class="mw-headline" id="Implementation_issues">Implementation issues</span>
</h3>
<h4> <span class="mw-headline" id="Choice_of_pivot">Choice of pivot</span>
</h4>
<p>In very early versions of quicksort, the leftmost element of the partition would often be chosen as the pivot element. Unfortunately, this causes worst-case behavior on already sorted arrays, which is a rather common use-case. The problem was easily solved by choosing either a random index for the pivot, choosing the middle index of the partition or (especially for longer partitions) choosing the <a href="http://en.m.wikipedia.org/wiki/Median" title="Median">median</a> of the first, middle and last element of the partition for the pivot (as recommended by <a href="http://en.m.wikipedia.org/wiki/Robert_Sedgewick_(computer_scientist)" title="Robert Sedgewick (computer scientist)">R. Sedgewick</a>).<sup id="cite_ref-sedgewickBook_3-0" class="reference"><a href="Qsort#cite_note-sedgewickBook-3"><span>[</span>4<span>]</span></a></sup><sup id="cite_ref-sedgewickQsortPaper_4-0" class="reference"><a href="Qsort#cite_note-sedgewickQsortPaper-4"><span>[</span>5<span>]</span></a></sup></p>
<p>Selecting a pivot element is also complicated by the existence of <a href="http://en.m.wikipedia.org/wiki/Integer_overflow" title="Integer overflow">integer overflow</a>. If the boundary indices of the subarray being sorted are sufficiently large, the naïve expression for the middle index, <i>(left + right)/2</i>, will cause overflow and provide an invalid pivot index. This can be overcome by using, for example, <i>left + (right-left)/2</i> to index the middle element, at the cost of more complex arithmetic. Similar issues arise in some other methods of selecting the pivot element.</p>
<h4> <span class="mw-headline" id="Optimizations">Optimizations</span>
</h4>
<p>Two other important optimizations, also suggested by <a href="http://en.m.wikipedia.org/wiki/Robert_Sedgewick_(computer_scientist)" title="Robert Sedgewick (computer scientist)">R. Sedgewick</a>, as commonly acknowledged, and widely used in practice are:<sup id="cite_ref-glibc_qsort_5-0" class="reference"><a href="Qsort#cite_note-glibc_qsort-5"><span>[</span>6<span>]</span></a></sup><sup id="cite_ref-6" class="reference"><a href="Qsort#cite_note-6"><span>[</span>7<span>]</span></a></sup><sup id="cite_ref-7" class="reference"><a href="Qsort#cite_note-7"><span>[</span>8<span>]</span></a></sup></p>
<ul>
<li>To make sure at most O(log N) space is used, <a href="http://en.wiktionary.org/wiki/recurse" class="extiw" title="wiktionary:recurse">recurse</a> first into the smaller half of the array, and use a <a href="http://en.m.wikipedia.org/wiki/Tail_call" title="Tail call">tail call</a> to recurse into the other.</li>
<li>Use <a href="http://en.m.wikipedia.org/wiki/Insertion_sort" title="Insertion sort">insertion sort</a>, which has a smaller constant factor and is thus faster on small arrays, for invocations on such small arrays (i.e. where the length is less than a threshold <i>t</i> determined experimentally). This can be implemented by leaving such arrays unsorted and running a single <a href="http://en.m.wikipedia.org/wiki/Insertion_sort" title="Insertion sort">insertion sort</a> pass at the end, because insertion sort handles nearly sorted arrays efficiently. A separate insertion sort of each small segment as they are identified adds the overhead of starting and stopping many small sorts, but avoids wasting effort comparing keys across the many segment boundaries, which keys will be in order due to the workings of the quicksort process. It also improves the cache use.</li>
</ul>
<h4> <span class="mw-headline" id="Parallelization">Parallelization</span>
</h4>
<p>Like <a href="http://en.m.wikipedia.org/wiki/Merge_sort" title="Merge sort">merge sort</a>, quicksort can also be <a href="http://en.m.wikipedia.org/wiki/Parallel_algorithm" title="Parallel algorithm">parallelized</a> due to its divide-and-conquer nature. Individual in-place partition operations are difficult to parallelize, but once divided, different sections of the list can be sorted in parallel. The following is a straightforward approach: If we have <img class="tex" alt="p" src="http://upload.wikimedia.org/math/8/3/8/83878c91171338902e0fe0fb97a8c47a.png"> processors, we can divide a list of <img class="tex" alt="n" src="http://upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png"> elements into <img class="tex" alt="p" src="http://upload.wikimedia.org/math/8/3/8/83878c91171338902e0fe0fb97a8c47a.png"> sublists in <i>O</i>(<i>n</i>) average time, then sort each of these in <img class="tex" alt="\textstyle O\left(\frac{n}{p} \log\frac{n}{p}\right)" src="http://upload.wikimedia.org/math/c/b/0/cb0bc7cdd9817843a2b46d97f92ddfb2.png"> average time. Ignoring the <i>O</i>(<i>n</i>) preprocessing and merge times, this is <a href="http://en.m.wikipedia.org/wiki/Linear_speedup" title="Linear speedup" class="mw-redirect">linear speedup</a>. If the split is blind, ignoring the values, the merge naïvely costs <i>O</i>(<i>n</i>). If the split partitions based on a succession of pivots, it is tricky to parallelize and naïvely costs <i>O</i>(<i>n</i>). Given <i>O</i>(log <i>n</i>) or more processors, only <i>O</i>(<i>n</i>) time is required overall, whereas an approach with <a href="http://en.m.wikipedia.org/wiki/Linear_speedup" title="Linear speedup" class="mw-redirect">linear speedup</a> would achieve <i>O</i>(log <i>n</i>) time for overall.</p>
<p>One advantage of this simple parallel quicksort over other parallel sort algorithms is that no synchronization is required, but the disadvantage is that sorting is still <i>O</i>(<i>n</i>) and only a sublinear speedup of <i>O</i>(log <i>n</i>) is achieved. A new thread is started as soon as a sublist is available for it to work on and it does not communicate with other threads. When all threads complete, the sort is done.</p>
<p>Other more sophisticated parallel sorting algorithms can achieve even better time bounds.<sup id="cite_ref-8" class="reference"><a href="Qsort#cite_note-8"><span>[</span>9<span>]</span></a></sup> For example, in 1991 David Powers described a parallelized quicksort (and a related <a href="http://en.m.wikipedia.org/wiki/Radix_sort" title="Radix sort">radix sort</a>) that can operate in <i>O</i>(log <i>n</i>) time on a CRCW <a href="http://en.m.wikipedia.org/wiki/Parallel_Random_Access_Machine" title="Parallel Random Access Machine" class="mw-redirect">PRAM</a> with <i>n</i> processors by performing partitioning implicitly.<sup id="cite_ref-9" class="reference"><a href="Qsort#cite_note-9"><span>[</span>10<span>]</span></a></sup></p>
<h2> <span class="mw-headline" id="Formal_analysis">Formal analysis</span>
</h2>
<h3> <span class="mw-headline" id="Average-case_analysis_using_discrete_probability">Average-case analysis using discrete probability</span>
</h3>
<p>Quicksort takes <i>O</i>(<i>n</i> log <i>n</i>) time on average, when the input is a random permutation. Why? For a start, it is not hard to see that the partition operation takes <i>O</i>(<i>n</i>) time.</p>
<p>In the most unbalanced case, each time we perform a partition we divide the list into two sublists of size 0 and <img class="tex" alt="n-1" src="http://upload.wikimedia.org/math/a/4/3/a438673491daae8148eae77373b6a467.png"> (for example, if all elements of the array are equal). This means each recursive call processes a list of size one less than the previous list. Consequently, we can make <img class="tex" alt="n-1" src="http://upload.wikimedia.org/math/a/4/3/a438673491daae8148eae77373b6a467.png"> nested calls before we reach a list of size 1. This means that the <a href="Call_stack" title="Call stack">call tree</a> is a linear chain of <img class="tex" alt="n-1" src="http://upload.wikimedia.org/math/a/4/3/a438673491daae8148eae77373b6a467.png"> nested calls. The <img class="tex" alt="i" src="http://upload.wikimedia.org/math/8/6/5/865c0c0b4ab0e063e5caa3387c1a8741.png">th call does <img class="tex" alt="O(n-i)" src="http://upload.wikimedia.org/math/1/7/e/17e452bcb87c8a1b8217d6d23e11324b.png"> work to do the partition, and <img class="tex" alt="\textstyle\sum_{i=0}^n (n-i) = O(n^2)" src="http://upload.wikimedia.org/math/e/1/1/e111b6dc31c7dbec42f0c2d1ba7a2a12.png">, so in that case Quicksort take <img class="tex" alt="O(n^2)" src="http://upload.wikimedia.org/math/1/8/9/189317b4b935a745fcfaf95940d2b4f0.png"> time. That is the worst case: given knowledge of which comparisons are performed by the sort, there are adaptive algorithms that are effective at generating worst-case input for quicksort on-the-fly, regardless of the pivot selection strategy.<sup id="cite_ref-10" class="reference"><a href="Qsort#cite_note-10"><span>[</span>11<span>]</span></a></sup></p>
<p>In the most balanced case, each time we perform a partition we divide the list into two nearly equal pieces. This means each recursive call processes a list of half the size. Consequently, we can make only <img class="tex" alt="\log n / \log 2" src="http://upload.wikimedia.org/math/0/c/d/0cd41a23133511178de2481f93a94e84.png"> nested calls before we reach a list of size 1. This means that the depth of the <a href="Call_stack" title="Call stack">call tree</a> is <img class="tex" alt="\log n / \log 2" src="http://upload.wikimedia.org/math/0/c/d/0cd41a23133511178de2481f93a94e84.png">. But no two calls at the same level of the call tree process the same part of the original list; thus, each level of calls needs only <i>O</i>(<i>n</i>) time all together (each call has some constant overhead, but since there are only <i>O</i>(<i>n</i>) calls at each level, this is subsumed in the <i>O</i>(<i>n</i>) factor). The result is that the algorithm uses only <i>O</i>(<i>n</i> log <i>n</i>) time.</p>
<p>In fact, it's not necessary to be perfectly balanced; even if each pivot splits the elements with 75% on one side and 25% on the other side (or any other fixed fraction), the call depth is still limited to <img class="tex" alt="\log n/ \log (4/3)" src="http://upload.wikimedia.org/math/9/f/2/9f20b52eaaf331b5b76f1150888d95f3.png">, so the total running time is still <i>O</i>(<i>n</i> log <i>n</i>).</p>
<p>So what happens on average? If the pivot has rank somewhere in the middle 50 percent, that is, between the 25th percentile and the 75th percentile, then it splits the elements with at least 25% and at most 75% on each side. If we could consistently choose a pivot from the two middle 50 percent, we would only have to split the list at most <img class="tex" alt="\log n/ \log (4/3)" src="http://upload.wikimedia.org/math/9/f/2/9f20b52eaaf331b5b76f1150888d95f3.png"> times before reaching lists of size 1, yielding an <i>O</i>(<i>n</i> log <i>n</i>) algorithm.</p>
<p>When the input is a random permutation, the pivot has a random rank, and so it is not guaranteed to be in the middle 50 percent. However, when we start from a random permutation, in each recursive call the pivot has a random rank in its list, and so it is in the middle 50 percent about half the time. That is good enough. Imagine that you flip a coin: heads means that the rank of the pivot is in the middle 50 percent, tail means that it isn't. Imagine that you are flipping a coin over and over until you get <i>k</i> heads. Although this could take a long time, on average only 2<i>k</i> flips are required, and the chance that you won't get <img class="tex" alt="k" src="http://upload.wikimedia.org/math/8/c/e/8ce4b16b22b58894aa86c421e8759df3.png"> heads after <img class="tex" alt="100k" src="http://upload.wikimedia.org/math/1/2/2/12277132c4446ec03bdb8b55891b24d4.png"> flips is highly improbable (this can be made rigorous using Chernoff bounds). By the same argument, Quicksort's recursion will terminate on average at a call depth of only <img class="tex" alt="2(\log n/ \log (4/3))" src="http://upload.wikimedia.org/math/4/5/3/453f99a8459a3010bd878696cf383154.png">. But if its average call depth is <i>O</i>(log <i>n</i>), and each level of the call tree processes at most <img class="tex" alt="n" src="http://upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png"> elements, the total amount of work done on average is the product, <i>O</i>(<i>n</i> log <i>n</i>). Note that the algorithm does not have to verify that the pivot is in the middle half—if we hit it any constant fraction of the times, that is enough for the desired complexity.</p>
<h3> <span class="mw-headline" id="Average-case_analysis_using_recurrences">Average-case analysis using recurrences</span>
</h3>
<p>An alternative approach is to set up a <a href="http://en.m.wikipedia.org/wiki/Recurrence_relation" title="Recurrence relation">recurrence relation</a> for the <i>T</i>(<i>n</i>) factor, the time needed to sort a list of size <img class="tex" alt="n" src="http://upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png">. In the most unbalanced case, a single Quicksort call involves <i>O</i>(<i>n</i>) work plus two recursive calls on lists of size <img class="tex" alt="0" src="http://upload.wikimedia.org/math/c/f/c/cfcd208495d565ef66e7dff9f98764da.png"> and <img class="tex" alt="n-1" src="http://upload.wikimedia.org/math/a/4/3/a438673491daae8148eae77373b6a467.png">, so the recurrence relation is</p>
<dl>
<dd><img class="tex" alt="T(n) = O(n) + T(0) + T(n-1) = O(n) + T(n-1)." src="http://upload.wikimedia.org/math/a/5/6/a56e1feb27396a1b11d04b6023d6a39a.png"></dd>
</dl>
<p>This is the same relation as for <a href="http://en.m.wikipedia.org/wiki/Insertion_sort" title="Insertion sort">insertion sort</a> and <a href="http://en.m.wikipedia.org/wiki/Selection_sort" title="Selection sort">selection sort</a>, and it solves to worst case <img class="tex" alt="T(n) = O(n^2)" src="http://upload.wikimedia.org/math/5/e/c/5ec9f6543350c4b9dafb09b5ae217f3b.png">.</p>
<p>In the most balanced case, a single quicksort call involves <i>O</i>(<i>n</i>) work plus two recursive calls on lists of size <img class="tex" alt="n/2" src="http://upload.wikimedia.org/math/a/2/f/a2f070a31330443ceb0dcf352fe50035.png">, so the recurrence relation is</p>
<dl>
<dd><img class="tex" alt="T(n) = O(n) + 2T\left(\frac{n}{2}\right)." src="http://upload.wikimedia.org/math/2/5/9/2591b18006e6e189ff08444815b5bf39.png"></dd>
</dl>
<p>The <a href="http://en.m.wikipedia.org/wiki/Master_theorem" title="Master theorem">master theorem</a> tells us that <i>T</i>(<i>n</i>) = <i>O</i>(<i>n</i> log <i>n</i>).</p>
<p>The outline of a formal proof of the <i>O</i>(<i>n</i> log <i>n</i>) expected time complexity follows. Assume that there are no duplicates as duplicates could be handled with linear time pre- and post-processing, or considered cases easier than the analyzed. When the input is a random permutation, the rank of the pivot is uniform random from 0 to <i>n</i>-1. Then the resulting parts of the partition have sizes i and n-i-1, and i is uniform random from 0 to <i>n</i>-1. So, averaging over all possible splits and noting that the number of comparisons for the partition is <img class="tex" alt="n-1" src="http://upload.wikimedia.org/math/a/4/3/a438673491daae8148eae77373b6a467.png">, the average number of comparisons over all permutations of the input sequence can be estimated accurately by solving the recurrence relation:</p>
<dl>
<dd><img class="tex" alt="C(n) = n - 1 + \frac{1}{n} \sum_{i=0}^{n-1} (C(i)+C(n-i-1))" src="http://upload.wikimedia.org/math/5/4/c/54c41caae12933ce5550402f95c8fc12.png"></dd>
</dl>
<p>Solving the recurrence gives <img class="tex" alt="C(n) = 2n \ln n = 1.39n \log_2 n." src="http://upload.wikimedia.org/math/8/9/b/89becafc7330e8f3d2c7e49c84c33a47.png"></p>
<p>This means that, on average, quicksort performs only about 39% worse than in its best case. In this sense it is closer to the best case than the worst case. Also note that a <a href="http://en.m.wikipedia.org/wiki/Comparison_sort" title="Comparison sort">comparison sort</a> cannot use less than <img class="tex" alt="\log_2(n!)" src="http://upload.wikimedia.org/math/9/e/6/9e6d43cfa222ad6876239c40506876ec.png"> comparisons on average to sort <img class="tex" alt="n" src="http://upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png"> items (as <a href="http://en.m.wikipedia.org/wiki/Comparison_sort#Lower_bound_for_the_average_number_of_comparisons" title="Comparison sort">explained in the article Comparison sort</a>) and in case of large <img class="tex" alt="n" src="http://upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png">, <a href="http://en.m.wikipedia.org/wiki/Stirling%27s_approximation" title="Stirling's approximation">Stirling's approximation</a> yields <img class="tex" alt="\log_2(n!) \approx n (\log_2 n - \log_2 e)" src="http://upload.wikimedia.org/math/9/e/e/9eebe0deb59c5497f9532d3df00f7809.png">, so quicksort is not much worse than an ideal comparison sort. This fast average runtime is another reason for quicksort's practical dominance over other sorting algorithms.</p>
<h3> <span class="mw-headline" id="Analysis_of_Randomized_quicksort">Analysis of Randomized quicksort</span>
</h3>
<p>Using the same analysis, one can show that Randomized quicksort has the desirable property that, for any input, it requires only <i>O</i>(<i>n</i> log <i>n</i>) <a href="http://en.m.wikipedia.org/wiki/Expected_value" title="Expected value">expected</a> time (averaged over all choices of pivots). However, there exists a combinatorial proof, more elegant than both the analysis using discrete probability and the analysis using recurrences.</p>
<p>To each execution of Quicksort corresponds the following binary search tree (BST): the initial pivot is the root node; the pivot of the left half is the root of the left subtree, the pivot of the right half is the root of the right subtree, and so on. The number of comparisons of the execution of Quicksort equals the number of comparisons during the construction of the BST by a sequence of insertions. So, the average number of comparisons for randomized Quicksort equals the average cost of constructing a BST when the values inserted <img class="tex" alt="(x_1,x_2,...,x_n)" src="http://upload.wikimedia.org/math/f/8/5/f85bf746c842098c40eff42587e12dab.png"> form a random permutation.</p>
<p>Consider a BST created by insertion of a sequence <img class="tex" alt="(x_1,x_2,...,x_n)" src="http://upload.wikimedia.org/math/f/8/5/f85bf746c842098c40eff42587e12dab.png"> of values forming a random permutation. Let C denote the cost of creation of the BST. We have: <img class="tex" alt="C=\sum_i \sum_{j&lt;i}" src="http://upload.wikimedia.org/math/8/9/c/89c7275d350a47b67c200258f329d13e.png"> (whether during the insertion of <img class="tex" alt="x_i" src="http://upload.wikimedia.org/math/0/5/e/05e42209d67fe1eb15a055e9d3b3770e.png"> there was a comparison to <img class="tex" alt="x_j" src="http://upload.wikimedia.org/math/f/4/b/f4bb95e27d8505366199bb81f2b75b6f.png">).</p>
<p>By linearity of expectation, the expected value E(C) of C is <img class="tex" alt="E(C)= \sum_i \sum_{j&lt;i}" src="http://upload.wikimedia.org/math/2/f/c/2fc772d6c4f6c90db215332c54df0628.png"> Pr(during the insertion of <img class="tex" alt="x_i" src="http://upload.wikimedia.org/math/0/5/e/05e42209d67fe1eb15a055e9d3b3770e.png"> there was a comparison to <img class="tex" alt="x_j" src="http://upload.wikimedia.org/math/f/4/b/f4bb95e27d8505366199bb81f2b75b6f.png">).</p>
<p>Fix i and j&lt;i. The values <img class="tex" alt="{x_1,x_2,...,x_j}" src="http://upload.wikimedia.org/math/9/c/2/9c226db01772e0a4dde4c25d6f2dcaa4.png">, once sorted, define j+1 intervals. The core structural observation is that <img class="tex" alt="x_i" src="http://upload.wikimedia.org/math/0/5/e/05e42209d67fe1eb15a055e9d3b3770e.png"> is compared to <img class="tex" alt="x_j" src="http://upload.wikimedia.org/math/f/4/b/f4bb95e27d8505366199bb81f2b75b6f.png"> in the algorithm if and only if <img class="tex" alt="x_i" src="http://upload.wikimedia.org/math/0/5/e/05e42209d67fe1eb15a055e9d3b3770e.png"> falls inside one of the two intervals adjacent to <img class="tex" alt="x_j" src="http://upload.wikimedia.org/math/f/4/b/f4bb95e27d8505366199bb81f2b75b6f.png">.</p>
<p>Observe that since <img class="tex" alt="(x_1,x_2,...,x_n)" src="http://upload.wikimedia.org/math/f/8/5/f85bf746c842098c40eff42587e12dab.png"> is a random permutation, <img class="tex" alt="(x_1,x_2,...,x_j,x_i)" src="http://upload.wikimedia.org/math/e/d/b/edb30fd71d643c22949ecb7b6f2a2516.png"> is also a random permutation, so the probability that <img class="tex" alt="x_i" src="http://upload.wikimedia.org/math/0/5/e/05e42209d67fe1eb15a055e9d3b3770e.png"> is adjacent to <img class="tex" alt="x_j" src="http://upload.wikimedia.org/math/f/4/b/f4bb95e27d8505366199bb81f2b75b6f.png"> is exactly <img class="tex" alt="2/(j+1)" src="http://upload.wikimedia.org/math/4/5/8/458b7f69bbf471ab8af20986f975f8ee.png">.</p>
<p>We end with a short calculation: <img class="tex" alt="E(C)=\sum_i \sum_{j&lt;i} 2/(j+1)= O(\sum_i \log i)=O(n \log n)." src="http://upload.wikimedia.org/math/e/d/5/ed58fbcfab5db5624cdaf9bf2f10fee1.png"></p>
<h3> <span class="mw-headline" id="Space_complexity">Space complexity</span>
</h3>
<p>The space used by quicksort depends on the version used.</p>
<p>The in-place version of quicksort has a space complexity of <i>O</i>(log <i>n</i>), even in the worst case, when it is carefully implemented using the following strategies:</p>
<ul>
<li>in-place partitioning is used. This unstable partition requires <i>O</i>(1) space.</li>
<li>After partitioning, the partition with the fewest elements is (recursively) sorted first, requiring at most <i>O</i>(log <i>n</i>) space. Then the other partition is sorted using <a href="http://en.m.wikipedia.org/wiki/Tail_recursion" title="Tail recursion" class="mw-redirect">tail recursion</a> or iteration, which doesn't add to the call stack. This idea, as discussed above, was described by <a href="http://en.m.wikipedia.org/wiki/Robert_Sedgewick_(computer_scientist)" title="Robert Sedgewick (computer scientist)">R. Sedgewick</a>, and keeps the stack depth bounded by <i>O</i>(log <i>n</i>).<sup id="cite_ref-sedgewickBook_3-1" class="reference"><a href="Qsort#cite_note-sedgewickBook-3"><span>[</span>4<span>]</span></a></sup><sup id="cite_ref-sedgewickQsortPaper_4-1" class="reference"><a href="Qsort#cite_note-sedgewickQsortPaper-4"><span>[</span>5<span>]</span></a></sup>
</li>
</ul>
<p>Quicksort with in-place and unstable partitioning uses only constant additional space before making any recursive call. Quicksort must store a constant amount of information for each nested recursive call. Since the best case makes at most <i>O</i>(log <i>n</i>) nested recursive calls, it uses <i>O</i>(log <i>n</i>) space. However, without Sedgewick's trick to limit the recursive calls, in the worst case quicksort could make <i>O</i>(<i>n</i>) nested recursive calls and need <i>O</i>(<i>n</i>) auxiliary space.</p>
<p>From a bit complexity viewpoint, variables such as <i>left</i> and <i>right</i> do not use constant space; it takes <i>O</i>(log <i>n</i>) bits to index into a list of <i>n</i> items. Because there are such variables in every stack frame, quicksort using Sedgewick's trick requires <img class="tex" alt="O((\log n)^2)" src="http://upload.wikimedia.org/math/8/a/5/8a599e1480dc575de472788e7fdcb191.png"> bits of space. This space requirement isn't too terrible, though, since if the list contained distinct elements, it would need at least <i>O</i>(<i>n</i> log <i>n</i>) bits of space.</p>
<p>Another, less common, not-in-place, version of quicksort uses <i>O</i>(<i>n</i>) space for working storage and can implement a stable sort. The working storage allows the input array to be easily partitioned in a stable manner and then copied back to the input array for successive recursive calls. Sedgewick's optimization is still appropriate.</p>
<h2> <span class="mw-headline" id="Selection-based_pivoting">Selection-based pivoting</span>
</h2>
<p>A <a href="http://en.m.wikipedia.org/wiki/Selection_algorithm" title="Selection algorithm">selection algorithm</a> chooses the <i>k</i>th smallest of a list of numbers; this is an easier problem in general than sorting. One simple but effective selection algorithm works nearly in the same manner as quicksort, except that instead of making recursive calls on both sublists, it only makes a single tail-recursive call on the sublist which contains the desired element. This small change lowers the average complexity to linear or <i>O</i>(<i>n</i>) time, and makes it an <a href="http://en.m.wikipedia.org/wiki/In-place_algorithm" title="In-place algorithm">in-place algorithm</a>. A variation on this algorithm brings the worst-case time down to <i>O</i>(<i>n</i>) (see <a href="http://en.m.wikipedia.org/wiki/Selection_algorithm" title="Selection algorithm">selection algorithm</a> for more information).</p>
<p>Conversely, once we know a worst-case <i>O</i>(<i>n</i>) selection algorithm is available, we can use it to find the ideal pivot (the median) at every step of quicksort, producing a variant with worst-case <i>O</i>(<i>n</i> log <i>n</i>) running time. In practical implementations, however, this variant is considerably slower on average.</p>
<h2> <span class="mw-headline" id="Variants">Variants</span>
</h2>
<p>There are four well known variants of quicksort:</p>
<ul>
<li>
<b>Balanced quicksort:</b> choose a pivot likely to represent the middle of the values to be sorted, and then follow the regular quicksort algorithm.</li>
<li>
<b>External quicksort:</b> The same as regular quicksort except the pivot is replaced by a buffer. First, read the M/2 first and last elements into the buffer and sort them. Read the next element from the beginning or end to balance writing. If the next element is less than the least of the buffer, write it to available space at the beginning. If greater than the greatest, write it to the end. Otherwise write the greatest or least of the buffer, and put the next element in the buffer. Keep the maximum lower and minimum upper keys written to avoid resorting middle elements that are in order. When done, write the buffer. Recursively sort the smaller partition, and loop to sort the remaining partition. This is a kind of three-way quicksort in which the middle partition (buffer) represents a sorted subarray of elements that are <i>approximately</i> equal to the pivot.</li>
<li>
<b>Three-way radix quicksort</b> (developed by Sedgewick and also known as <b>multikey quicksort</b>): is a combination of <a href="http://en.m.wikipedia.org/wiki/Radix_sort" title="Radix sort">radix sort</a> and quicksort. Pick an element from the array (the pivot) and consider the first character (key) of the string (multikey). Partition the remaining elements into three sets: those whose corresponding character is less than, equal to, and greater than the pivot's character. Recursively sort the "less than" and "greater than" partitions on the same character. Recursively sort the "equal to" partition by the next character (key). Given we sort using bytes or words of length W bits, the best case is O(KN) and the worst case O(2<sup>K</sup>N) or at least O(N<sup>2</sup>) as for standard quicksort, given for unique keys N&lt;2<sup>K</sup>, and K is a hidden constant in all standard <a href="http://en.m.wikipedia.org/wiki/Comparison_sort" title="Comparison sort">comparison sort</a> algorithms including quicksort. This is a kind of three-way quicksort in which the middle partition represents a (trivially) sorted subarray of elements that are <i>exactly</i> equal to the pivot.</li>
<li>
<b>Quick radix sort</b> (also developed by Powers as a o(K) parallel <a href="http://en.m.wikipedia.org/wiki/PRAM" title="PRAM" class="mw-redirect">PRAM</a> algorithm). This is again a combination of <a href="http://en.m.wikipedia.org/wiki/Radix_sort" title="Radix sort">radix sort</a> and quicksort but the quicksort left/right partition decision is made on successive bits of the key, and is thus O(KN) for N K-bit keys. Note that all <a href="http://en.m.wikipedia.org/wiki/Comparison_sort" title="Comparison sort">comparison sort</a> algorithms effectively assume an ideal K of O(logN) as if k is smaller we can sort in O(N) using a hash table or <a href="http://en.m.wikipedia.org/wiki/Integer_sorting" title="Integer sorting">integer sorting</a>, and if K &gt;&gt; logN but elements are unique within O(logN) bits, the remaining bits will not be looked at by either quicksort or quick radix sort, and otherwise all comparison sorting algorithms will also have the same overhead of looking through O(K) relatively useless bits but quick radix sort will avoid the worst case O(N<sup>2</sup>) behaviours of standard quicksort and quick radix sort, and will be faster even in the best case of those comparison algorithms under these conditions of uniqueprefix(K) &gt;&gt; logN. See Powers <sup id="cite_ref-11" class="reference"><a href="Qsort#cite_note-11"><span>[</span>12<span>]</span></a></sup> for further discussion of the hidden overheads in comparison, radix and parallel sorting.</li>
</ul>
<h2> <span class="mw-headline" id="Comparison_with_other_sorting_algorithms">Comparison with other sorting algorithms</span>
</h2>
<p>Quicksort is a space-optimized version of the <a href="http://en.m.wikipedia.org/wiki/Binary_tree_sort" title="Binary tree sort" class="mw-redirect">binary tree sort</a>. Instead of inserting items sequentially into an explicit tree, quicksort organizes them concurrently into a tree that is implied by the recursive calls. The algorithms make exactly the same comparisons, but in a different order. An often desirable property of a <a href="http://en.m.wikipedia.org/wiki/Sorting_algorithm" title="Sorting algorithm">sorting algorithm</a> is stability - that is the order of elements that compare equal is not changed, allowing controlling order of multikey tables (e.g. directory or folder listings) in a natural way. This property is hard to maintain for in situ (or in place) quicksort (that uses only constant additional space for pointers and buffers, and logN additional space for the management of explicit or implicit recursion). For variant quicksorts involving extra memory due to representations using pointers (e.g. lists or trees) or files (effectively lists), it is trivial to maintain stability. The more complex, or disk-bound, data structures tend to increase time cost, in general making increasing use of virtual memory or disk.</p>
<p>The most direct competitor of quicksort is <a href="http://en.m.wikipedia.org/wiki/Heapsort" title="Heapsort">heapsort</a>. Heapsort's worst-case running time is always <i>O</i>(<i>n</i> log <i>n</i>). But, heapsort is assumed to be on average somewhat slower than standard in-place quicksort. This is still debated and in research, with some publications indicating the opposite.<sup id="cite_ref-12" class="reference"><a href="Qsort#cite_note-12"><span>[</span>13<span>]</span></a></sup><sup id="cite_ref-13" class="reference"><a href="Qsort#cite_note-13"><span>[</span>14<span>]</span></a></sup><a href="http://en.m.wikipedia.org/wiki/Introsort" title="Introsort">Introsort</a> is a variant of quicksort that switches to heapsort when a bad case is detected to avoid quicksort's worst-case running time. If it is known in advance that heapsort is going to be necessary, using it directly will be faster than waiting for introsort to switch to it.</p>
<p>Quicksort also competes with <a href="http://en.m.wikipedia.org/wiki/Mergesort" title="Mergesort" class="mw-redirect">mergesort</a>, another recursive sort algorithm but with the benefit of worst-case <i>O</i>(<i>n</i> log <i>n</i>) running time. Mergesort is a <a href="http://en.m.wikipedia.org/wiki/Stable_sort" title="Stable sort" class="mw-redirect">stable sort</a>, unlike standard in-place quicksort and heapsort, and can be easily adapted to operate on <a href="Linked_list" title="Linked list">linked lists</a> and very large lists stored on slow-to-access media such as <a href="http://en.m.wikipedia.org/wiki/Disk_storage" title="Disk storage">disk storage</a> or <a href="http://en.m.wikipedia.org/wiki/Network_attached_storage" title="Network attached storage" class="mw-redirect">network attached storage</a>. Like mergesort, quicksort can be implemented as an in-place stable sort,<sup id="cite_ref-14" class="reference"><a href="Qsort#cite_note-14"><span>[</span>15<span>]</span></a></sup> but this is seldom done. Although quicksort can be written to operate on linked lists, it will often suffer from poor pivot choices without random access. The main disadvantage of mergesort is that, when operating on arrays, efficient implementations require <i>O</i>(<i>n</i>) auxiliary space, whereas the variant of quicksort with in-place partitioning and tail recursion uses only <i>O</i>(log <i>n</i>) space. (Note that when operating on linked lists, mergesort only requires a small, constant amount of auxiliary storage.)</p>
<p><a href="http://en.m.wikipedia.org/wiki/Bucket_sort" title="Bucket sort">Bucket sort</a> with two buckets is very similar to quicksort; the pivot in this case is effectively the value in the middle of the value range, which does well on average for uniformly distributed inputs.</p>
<h2> <span class="mw-headline" id="See_also">See also</span>
</h2>
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Introsort" title="Introsort">Introsort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Flashsort" title="Flashsort">Flashsort</a></li>
</ul>
<h2> <span class="mw-headline" id="Notes">Notes</span>
</h2>
<ol class="references">
<li id="cite_note-0">
<span class="mw-cite-backlink"><b><a href="Qsort#cite_ref-0">^</a></b></span> <span class="reference-text">S. S. Skiena, The Algorithm Design Manual, Second Edition, Springer, 2008, p. 129</span>
</li>
<li id="cite_note-1">
<span class="mw-cite-backlink"><b><a href="Qsort#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.cs.auckland.ac.nz/~jmor159/PLDS210/qsort1a.html">"Data structures and algorithm: Quicksort"</a>. Auckland University<span class="printonly">. <a rel="nofollow" class="external free" href="http://www.cs.auckland.ac.nz/~jmor159/PLDS210/qsort1a.html">http://www.cs.auckland.ac.nz/~jmor159/PLDS210/qsort1a.html</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Data+structures+and+algorithm%3A+Quicksort&amp;rft.atitle=&amp;rft.pub=Auckland+University&amp;rft_id=http%3A%2F%2Fwww.cs.auckland.ac.nz%2F%7Ejmor159%2FPLDS210%2Fqsort1a.html&amp;rfr_id=info:sid/en.wikipedia.org:Quicksort"><span style="display: none;"> </span></span></span>
</li>
<li id="cite_note-2">
<span class="mw-cite-backlink"><b><a href="Qsort#cite_ref-2">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://cacm.acm.org/magazines/2009/3/21782-an-interview-with-car-hoare/fulltext">"An Interview with C.A.R. Hoare"</a>. Communications of the ACM, March 2009 ("premium content")<span class="printonly">. <a rel="nofollow" class="external free" href="http://cacm.acm.org/magazines/2009/3/21782-an-interview-with-car-hoare/fulltext">http://cacm.acm.org/magazines/2009/3/21782-an-interview-with-car-hoare/fulltext</a></span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=An+Interview+with+C.A.R.+Hoare&amp;rft.atitle=&amp;rft.pub=Communications+of+the+ACM%2C+March+2009+%28%22premium+content%22%29&amp;rft_id=http%3A%2F%2Fcacm.acm.org%2Fmagazines%2F2009%2F3%2F21782-an-interview-with-car-hoare%2Ffulltext&amp;rfr_id=info:sid/en.wikipedia.org:Quicksort"><span style="display: none;"> </span></span></span>
</li>
<li id="cite_note-sedgewickBook-3">
<span class="mw-cite-backlink">^ <a href="Qsort#cite_ref-sedgewickBook_3-0"><sup><i><b>a</b></i></sup></a> <a href="Qsort#cite_ref-sedgewickBook_3-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><a href="http://en.m.wikipedia.org/wiki/Robert_Sedgewick_(computer_scientist)" title="Robert Sedgewick (computer scientist)">R. Sedgewick</a>, Algorithms in C, Parts 1-4: Fundamentals, Data Structures, Sorting, Searching, 3rd Edition, Addison-Wesley</span>
</li>
<li id="cite_note-sedgewickQsortPaper-4">
<span class="mw-cite-backlink">^ <a href="Qsort#cite_ref-sedgewickQsortPaper_4-0"><sup><i><b>a</b></i></sup></a> <a href="Qsort#cite_ref-sedgewickQsortPaper_4-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><a href="http://en.m.wikipedia.org/wiki/Robert_Sedgewick_(computer_scientist)" title="Robert Sedgewick (computer scientist)">R. Sedgewick</a>, Implementing quicksort programs, Comm. ACM, 21(10):847-857, 1978.</span>
</li>
<li id="cite_note-glibc_qsort-5">
<span class="mw-cite-backlink"><b><a href="Qsort#cite_ref-glibc_qsort_5-0">^</a></b></span> <span class="reference-text">qsort.c in <a href="http://en.m.wikipedia.org/wiki/GNU_libc" title="GNU libc" class="mw-redirect">GNU libc</a>: <a rel="nofollow" class="external autonumber" href="http://www.cs.columbia.edu/~hgs/teaching/isp/hw/qsort.c">[1]</a>, <a rel="nofollow" class="external autonumber" href="http://repo.or.cz/w/glibc.git/blob/HEAD:/stdlib/qsort.c">[2]</a></span>
</li>
<li id="cite_note-6">
<span class="mw-cite-backlink"><b><a href="Qsort#cite_ref-6">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external free" href="http://home.tiscalinet.ch/t_wolf/tw/ada95/sorting/index.html">http://home.tiscalinet.ch/t_wolf/tw/ada95/sorting/index.html</a></span>
</li>
<li id="cite_note-7">
<span class="mw-cite-backlink"><b><a href="Qsort#cite_ref-7">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external free" href="http://www.ugrad.cs.ubc.ca/~cs260/chnotes/ch6/Ch6CovCompiled.html">http://www.ugrad.cs.ubc.ca/~cs260/chnotes/ch6/Ch6CovCompiled.html</a></span>
</li>
<li id="cite_note-8">
<span class="mw-cite-backlink"><b><a href="Qsort#cite_ref-8">^</a></b></span> <span class="reference-text">R.Miller, L.Boxer, Algorithms Sequential &amp; Parallel, A Unified Approach, Prentice Hall, NJ, 2006</span>
</li>
<li id="cite_note-9">
<span class="mw-cite-backlink"><b><a href="Qsort#cite_ref-9">^</a></b></span> <span class="reference-text">David M. W. Powers, <a rel="nofollow" class="external text" href="http://citeseer.ist.psu.edu/327487.html">Parallelized Quicksort and Radixsort with Optimal Speedup</a>, <i>Proceedings of International Conference on Parallel Computing Technologies</i>. <a href="http://en.m.wikipedia.org/wiki/Novosibirsk" title="Novosibirsk">Novosibirsk</a>. 1991.</span>
</li>
<li id="cite_note-10">
<span class="mw-cite-backlink"><b><a href="Qsort#cite_ref-10">^</a></b></span> <span class="reference-text">M. D. McIlroy. A Killer Adversary for Quicksort. Software Practice and Experience: vol.29, no.4, 341–344. 1999. <a rel="nofollow" class="external text" href="http://citeseer.ist.psu.edu/212772.html">At Citeseer</a></span>
</li>
<li id="cite_note-11">
<span class="mw-cite-backlink"><b><a href="Qsort#cite_ref-11">^</a></b></span> <span class="reference-text">David M. W. Powers, <a rel="nofollow" class="external text" href="http://david.wardpowers.info/Research/AI/papers/199501-ACAW-PUPC.pdf">Parallel Unification: Practical Complexity</a>, Australasian Computer Architecture Workshop, Flinders University, January 1995</span>
</li>
<li id="cite_note-12">
<span class="mw-cite-backlink"><b><a href="Qsort#cite_ref-12">^</a></b></span> <span class="reference-text"><span class="citation web">Hsieh, Paul (2004). <a rel="nofollow" class="external text" href="http://www.azillionmonkeys.com/qed/sort.html">"Sorting revisited."</a>. www.azillionmonkeys.com<span class="printonly">. <a rel="nofollow" class="external free" href="http://www.azillionmonkeys.com/qed/sort.html">http://www.azillionmonkeys.com/qed/sort.html</a></span><span class="reference-accessdate">. Retrieved 26 April 2010</span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Sorting+revisited.&amp;rft.atitle=&amp;rft.aulast=Hsieh&amp;rft.aufirst=Paul&amp;rft.au=Hsieh%2C%26%2332%3BPaul&amp;rft.date=2004&amp;rft.pub=www.azillionmonkeys.com&amp;rft_id=http%3A%2F%2Fwww.azillionmonkeys.com%2Fqed%2Fsort.html&amp;rfr_id=info:sid/en.wikipedia.org:Quicksort"><span style="display: none;"> </span></span></span>
</li>
<li id="cite_note-13">
<span class="mw-cite-backlink"><b><a href="Qsort#cite_ref-13">^</a></b></span> <span class="reference-text"><span class="citation web">MacKay, David (1 December 2005). <a rel="nofollow" class="external text" href="http://users.aims.ac.za/~mackay/sorting/sorting.html">"Heapsort, Quicksort, and Entropy"</a>. users.aims.ac.za/~mackay<span class="printonly">. <a rel="nofollow" class="external free" href="http://users.aims.ac.za/~mackay/sorting/sorting.html">http://users.aims.ac.za/~mackay/sorting/sorting.html</a></span><span class="reference-accessdate">. Retrieved 26 April 2010</span>.</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Heapsort%2C+Quicksort%2C+and+Entropy&amp;rft.atitle=&amp;rft.aulast=MacKay&amp;rft.aufirst=David&amp;rft.au=MacKay%2C%26%2332%3BDavid&amp;rft.date=1+December+2005&amp;rft.pub=users.aims.ac.za%2F%7Emackay&amp;rft_id=http%3A%2F%2Fusers.aims.ac.za%2F%7Emackay%2Fsorting%2Fsorting.html&amp;rfr_id=info:sid/en.wikipedia.org:Quicksort"><span style="display: none;"> </span></span></span>
</li>
<li id="cite_note-14">
<span class="mw-cite-backlink"><b><a href="Qsort#cite_ref-14">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://h2database.googlecode.com/svn/trunk/h2/src/tools/org/h2/dev/sort/InPlaceStableQuicksort.java">A Java implementation of in-place stable quicksort</a></span>
</li>
</ol>
<h2> <span class="mw-headline" id="References">References</span>
</h2>
<ul>
<li>R. Sedgewick, Implementing quicksort programs, Comm. ACM, 21(10):847-857, 1978. <a rel="nofollow" class="external text" href="http://delivery.acm.org/10.1145/360000/359631/p847-sedgewick.pdf?key1=359631&amp;key2=9191985921&amp;coll=DL&amp;dl=ACM&amp;CFID=6618157&amp;CFTOKEN=73435998">Implementing Quicksort Programs</a>
</li>
<li>Brian C. Dean, "A Simple Expected Running Time Analysis for Randomized 'Divide and Conquer' Algorithms." <i>Discrete Applied Mathematics</i> 154(1): 1-5. 2006.</li>
<li>Hoare, C. A. R. "Partition: Algorithm 63," "Quicksort: Algorithm 64," and "Find: Algorithm 65." <a href="http://en.m.wikipedia.org/wiki/Comm._ACM" title="Comm. ACM" class="mw-redirect">Comm. ACM</a> 4(7), 321-322, 1961</li>
<li>Hoare, C. A. R. <a rel="nofollow" class="external text" href="http://dx.doi.org/10.1093/comjnl/5.1.10">"Quicksort."</a> Computer Journal 5 (1): 10-15. (1962). (Reprinted in Hoare and Jones: <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=SERIES11430.63445"><i>Essays in computing science</i></a>, 1989.)</li>
<li>David Musser. Introspective Sorting and Selection Algorithms, Software Practice and Experience vol 27, number 8, pages 983-993, 1997</li>
<li>
<a href="http://en.m.wikipedia.org/wiki/Donald_Knuth" title="Donald Knuth">Donald Knuth</a>. <i>The Art of Computer Programming</i>, Volume 3: <i>Sorting and Searching</i>, Third Edition. Addison-Wesley, 1997. <a href="http://en.m.wikipedia.org/wiki/Special:BookSources/0201896850" class="internal mw-magiclink-isbn">ISBN 0-201-89685-0</a>. Pages 113–122 of section 5.2.2: Sorting by Exchanging.</li>
<li>
<a href="http://en.m.wikipedia.org/wiki/Thomas_H._Cormen" title="Thomas H. Cormen">Thomas H. Cormen</a>, <a href="http://en.m.wikipedia.org/wiki/Charles_E._Leiserson" title="Charles E. Leiserson">Charles E. Leiserson</a>, <a href="http://en.m.wikipedia.org/wiki/Ronald_L._Rivest" title="Ronald L. Rivest" class="mw-redirect">Ronald L. Rivest</a>, and <a href="http://en.m.wikipedia.org/wiki/Clifford_Stein" title="Clifford Stein">Clifford Stein</a>. <i><a href="http://en.m.wikipedia.org/wiki/Introduction_to_Algorithms" title="Introduction to Algorithms">Introduction to Algorithms</a></i>, Second Edition. <a href="http://en.m.wikipedia.org/wiki/MIT_Press" title="MIT Press">MIT Press</a> and <a href="http://en.m.wikipedia.org/wiki/McGraw-Hill" title="McGraw-Hill">McGraw-Hill</a>, 2001. <a href="http://en.m.wikipedia.org/wiki/Special:BookSources/0262032937" class="internal mw-magiclink-isbn">ISBN 0-262-03293-7</a>. Chapter 7: Quicksort, pp. 145–164.</li>
<li>A. LaMarca and R. E. Ladner. "The Influence of Caches on the Performance of Sorting." Proceedings of the Eighth Annual ACM-SIAM Symposium on Discrete Algorithms, 1997. pp. 370–379.</li>
<li>
<a href="http://en.m.wikipedia.org/wiki/Faron_Moller" title="Faron Moller">Faron Moller</a>. <a rel="nofollow" class="external text" href="http://www.cs.swan.ac.uk/~csfm/Courses/CS_332/quicksort.pdf">Analysis of Quicksort</a>. CS 332: Designing Algorithms. Department of Computer Science, <a href="http://en.m.wikipedia.org/wiki/Swansea_University" title="Swansea University">Swansea University</a>.</li>
<li>Conrado Martínez and Salvador Roura, <i>Optimal sampling strategies in quicksort and quickselect.</i> SIAM J. Computing 31(3):683-705, 2001.</li>
<li>Jon L. Bentley and M. Douglas McIlroy, <a rel="nofollow" class="external text" href="http://citeseer.ist.psu.edu/bentley93engineering.html">Engineering a Sort Function</a>, <i>Software—Practice and Experience</i>, Vol. 23(11), 1249–1265, 1993</li>
</ul>
<h2> <span class="mw-headline" id="External_links">External links</span>
</h2>
<table class="metadata mbox-small plainlinks" style="border:1px solid #aaa; background-color:#f9f9f9;"><tr>
<td class="mbox-image"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/d/df/Wikibooks-logo-en-noslogan.svg/40px-Wikibooks-logo-en-noslogan.svg.png" width="40" height="40" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/d/df/Wikibooks-logo-en-noslogan.svg/60px-Wikibooks-logo-en-noslogan.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/d/df/Wikibooks-logo-en-noslogan.svg/80px-Wikibooks-logo-en-noslogan.svg.png 2x"></td>
<td class="mbox-text plainlist" style="">The Wikibook <i><a href="http://en.wikibooks.org/wiki/Algorithm_implementation" class="extiw" title="wikibooks:Algorithm implementation">Algorithm implementation</a></i> has a page on the topic of: <i><b><a href="http://en.wikibooks.org/wiki/Algorithm_implementation/Sorting/Quicksort" class="extiw" title="wikibooks:Algorithm implementation/Sorting/Quicksort">Quicksort</a></b></i>
</td>
</tr></table>
<ul>
<li>
<a rel="nofollow" class="external text" href="http://www.sorting-algorithms.com/quick-sort">Animated Sorting Algorithms: Quick Sort</a> – graphical demonstration and discussion of quick sort</li>
<li>
<a rel="nofollow" class="external text" href="http://www.sorting-algorithms.com/quick-sort-3-way">Animated Sorting Algorithms: 3-Way Partition Quick Sort</a> – graphical demonstration and discussion of 3-way partition quick sort</li>
<li><a rel="nofollow" class="external text" href="http://pages.stern.nyu.edu/~panos/java/Quicksort/index.html">Interactive Tutorial for Quicksort</a></li>
<li>
<a rel="nofollow" class="external text" href="http://www.yorku.ca/sychen/research/sorting/index.html">Quicksort applet</a> with "level-order" recursive calls to help improve algorithm analysis</li>
<li><a rel="nofollow" class="external text" href="http://opendatastructures.org/versions/edition-0.1e/ods-java/11_1_Comparison_Based_Sorti.html#SECTION001412000000000000000">Open Data Structures - Section 11.1.2 - Quicksort</a></li>
<li><a rel="nofollow" class="external text" href="http://fiehnlab.ucdavis.edu/staff/wohlgemuth/java/quicksort">Multidimensional quicksort in Java</a></li>
<li>
<a rel="nofollow" class="external text" href="http://en.literateprograms.org/Category:Quicksort">Literate implementations of Quicksort in various languages</a> on LiteratePrograms</li>
<li>
<a rel="nofollow" class="external text" href="http://coderaptors.com/?QuickSort">A colored graphical Java applet</a> which allows experimentation with initial state and shows statistics</li>
</ul>
<div style="clear:both;"></div>
<table cellspacing="0" class="navbox" style="border-spacing:0;;"><tr>
<td style="padding:2px;">
<table cellspacing="0" class="nowraplinks collapsible autocollapse navbox-inner" style="border-spacing:0;background:transparent;color:inherit;;">
<tr>
<th scope="col" style=";" class="navbox-title" colspan="2">
<div class="noprint plainlinks hlist navbar mini" style="">
<ul>
<li class="nv-view"><a href="http://en.m.wikipedia.org/wiki/Template:Sorting" title="Template:Sorting"><span title="View this template" style=";;background:none transparent;border:none;">v</span></a></li>
<li class="nv-talk"><a href="http://en.m.wikipedia.org/wiki/Template_talk:Sorting" title="Template talk:Sorting"><span title="Discuss this template" style=";;background:none transparent;border:none;">t</span></a></li>
<li class="nv-edit"><a class="external text" href="http://en.wikipedia.org/w/index.php?title=Template:Sorting&amp;action=edit"><span title="Edit this template" style=";;background:none transparent;border:none;">e</span></a></li>
</ul>
</div>
<div class="" style="font-size:110%;"><a href="http://en.m.wikipedia.org/wiki/Sorting_algorithm" title="Sorting algorithm">Sorting algorithms</a></div>
</th>
</tr>
<tr style="height:2px;">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=";;">Theory</th>
<td style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px;;;" class="navbox-list navbox-odd hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Computational_complexity_theory" title="Computational complexity theory">Computational complexity theory</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Big_O_notation" title="Big O notation">Big O notation</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Total_order" title="Total order">Total order</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/List_(computing)" title="List (computing)" class="mw-redirect">Lists</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Sorting_algorithm#Stability" title="Sorting algorithm">Stability</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Comparison_sort" title="Comparison sort">Comparison sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Adaptive_sort" title="Adaptive sort">Adaptive sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Sorting_network" title="Sorting network">Sorting network</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Integer_sorting" title="Integer sorting">Integer sorting</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=";;">Exchange sorts</th>
<td style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px;;;" class="navbox-list navbox-even hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Bubble_sort" title="Bubble sort">Bubble sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Cocktail_sort" title="Cocktail sort">Cocktail sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Odd%E2%80%93even_sort" title="Odd–even sort">Odd–even sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Comb_sort" title="Comb sort">Comb sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Gnome_sort" title="Gnome sort">Gnome sort</a></li>
<li><strong class="selflink">Quicksort</strong></li>
<li><a href="http://en.m.wikipedia.org/wiki/Stooge_sort" title="Stooge sort">Stooge sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Bogosort" title="Bogosort">Bogosort</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=";;">Selection sorts</th>
<td style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px;;;" class="navbox-list navbox-odd hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Selection_sort" title="Selection sort">Selection sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Heapsort" title="Heapsort">Heapsort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Smoothsort" title="Smoothsort">Smoothsort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Cartesian_tree#Application_in_sorting" title="Cartesian tree">Cartesian tree sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Tournament_sort" title="Tournament sort">Tournament sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Cycle_sort" title="Cycle sort">Cycle sort</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=";;">Insertion sorts</th>
<td style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px;;;" class="navbox-list navbox-even hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Insertion_sort" title="Insertion sort">Insertion sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Shellsort" title="Shellsort">Shellsort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Tree_sort" title="Tree sort">Tree sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Library_sort" title="Library sort">Library sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Patience_sorting" title="Patience sorting">Patience sorting</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=";;">Merge sorts</th>
<td style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px;;;" class="navbox-list navbox-odd hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Merge_sort" title="Merge sort">Merge sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Cascade_merge_sort" title="Cascade merge sort">Cascade merge sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Oscillating_merge_sort" title="Oscillating merge sort">Oscillating merge sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Polyphase_merge_sort" title="Polyphase merge sort">Polyphase merge sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Strand_sort" title="Strand sort">Strand sort</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=";;">Distribution sorts</th>
<td style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px;;;" class="navbox-list navbox-even hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/American_flag_sort" title="American flag sort">American flag sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Bead_sort" title="Bead sort">Bead sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Bucket_sort" title="Bucket sort">Bucket sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Burstsort" title="Burstsort">Burstsort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Counting_sort" title="Counting sort">Counting sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Pigeonhole_sort" title="Pigeonhole sort">Pigeonhole sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Proxmap_sort" title="Proxmap sort">Proxmap sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Radix_sort" title="Radix sort">Radix sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Flashsort" title="Flashsort">Flashsort</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=";;">Concurrent sorts</th>
<td style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px;;;" class="navbox-list navbox-odd hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Bitonic_sorter" title="Bitonic sorter">Bitonic sorter</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Batcher_odd%E2%80%93even_mergesort" title="Batcher odd–even mergesort">Batcher odd–even mergesort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Pairwise_sorting_network" title="Pairwise sorting network">Pairwise sorting network</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=";;">Hybrid sorts</th>
<td style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px;;;" class="navbox-list navbox-even hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Timsort" title="Timsort">Timsort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Introsort" title="Introsort">Introsort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Spreadsort" title="Spreadsort">Spreadsort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/UnShuffle_sort" title="UnShuffle sort">UnShuffle sort</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/JSort" title="JSort">JSort</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td></td>
</tr>
<tr>
<th scope="row" class="navbox-group" style=";;">Other</th>
<td style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px;;;" class="navbox-list navbox-odd hlist">
<div style="padding:0em 0.25em">
<ul>
<li><a href="http://en.m.wikipedia.org/wiki/Topological_sorting" title="Topological sorting">Topological sorting</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Pancake_sorting" title="Pancake sorting">Pancake sorting</a></li>
<li><a href="http://en.m.wikipedia.org/wiki/Spaghetti_sort" title="Spaghetti sort">Spaghetti sort</a></li>
</ul>
</div>
</td>
</tr>
</table>
</td>
</tr></table>

						<div class="section" id="mw-mf-language-section">
				<h2 id="section_language" class="section_heading">Read in another language</h2>
				<div id="content_language" class="content_block">
					<p>This article is available in 35 languages</p>
					<ul id="mw-mf-language-selection"><li><a href="http://ar.m.wikipedia.org/wiki/%D8%AA%D8%B1%D8%AA%D9%8A%D8%A8_%D8%B3%D8%B1%D9%8A%D8%B9" lang="ar" hreflang="ar">العربية</a></li><li><a href="http://bn.m.wikipedia.org/wiki/%E0%A6%95%E0%A7%81%E0%A6%87%E0%A6%95_%E0%A6%B8%E0%A6%B0%E0%A7%8D%E0%A6%9F" lang="bn" hreflang="bn">বাংলা</a></li><li><a href="http://bg.m.wikipedia.org/wiki/%D0%91%D1%8A%D1%80%D0%B7%D0%BE_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%B0%D0%BD%D0%B5" lang="bg" hreflang="bg">български</a></li><li><a href="http://ca.m.wikipedia.org/wiki/Quicksort" lang="ca" hreflang="ca">català</a></li><li><a href="http://cs.m.wikipedia.org/wiki/Quicksort" lang="cs" hreflang="cs">česky</a></li><li><a href="http://de.m.wikipedia.org/wiki/Quicksort" lang="de" hreflang="de">Deutsch</a></li><li><a href="http://es.m.wikipedia.org/wiki/Quicksort" lang="es" hreflang="es">español</a></li><li><a href="http://fa.m.wikipedia.org/wiki/%D9%85%D8%B1%D8%AA%D8%A8%E2%80%8C%D8%B3%D8%A7%D8%B2%DB%8C_%D8%B3%D8%B1%DB%8C%D8%B9" lang="fa" hreflang="fa">فارسی</a></li><li><a href="http://fr.m.wikipedia.org/wiki/Tri_rapide" lang="fr" hreflang="fr">français</a></li><li><a href="http://ko.m.wikipedia.org/wiki/%ED%80%B5_%EC%A0%95%EB%A0%AC" lang="ko" hreflang="ko">한국어</a></li><li><a href="http://hy.m.wikipedia.org/wiki/%D4%B1%D6%80%D5%A1%D5%A3_%D5%BF%D5%A5%D5%BD%D5%A1%D5%AF%D5%A1%D5%BE%D5%B8%D6%80%D5%B8%D6%82%D5%B4" lang="hy" hreflang="hy">Հայերեն</a></li><li><a href="http://is.m.wikipedia.org/wiki/Snarr%C3%B6%C3%B0un" lang="is" hreflang="is">íslenska</a></li><li><a href="http://it.m.wikipedia.org/wiki/Quicksort" lang="it" hreflang="it">italiano</a></li><li><a href="http://he.m.wikipedia.org/wiki/%D7%9E%D7%99%D7%95%D7%9F_%D7%9E%D7%94%D7%99%D7%A8" lang="he" hreflang="he">עברית</a></li><li><a href="http://kk.m.wikipedia.org/wiki/%D0%A2%D0%B5%D0%B7_%D1%81%D2%B1%D1%80%D1%8B%D0%BF%D1%82%D0%B0%D1%83" lang="kk" hreflang="kk">қазақша</a></li><li><a href="http://lv.m.wikipedia.org/wiki/%C4%80tr%C4%81s_k%C4%81rto%C5%A1anas_algoritms" lang="lv" hreflang="lv">latviešu</a></li><li><a href="http://lt.m.wikipedia.org/wiki/Greitojo_rikiavimo_algoritmas" lang="lt" hreflang="lt">lietuvių</a></li><li><a href="http://hu.m.wikipedia.org/wiki/Gyorsrendez%C3%A9s" lang="hu" hreflang="hu">magyar</a></li><li><a href="http://nl.m.wikipedia.org/wiki/Quicksort" lang="nl" hreflang="nl">Nederlands</a></li><li><a href="http://ja.m.wikipedia.org/wiki/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88" lang="ja" hreflang="ja">日本語</a></li><li><a href="http://no.m.wikipedia.org/wiki/Sorteringsalgoritme#Quick_sort" lang="no" hreflang="no">norsk (bokmål)‎</a></li><li><a href="http://uz.m.wikipedia.org/wiki/Quicksort" lang="uz" hreflang="uz">oʻzbekcha</a></li><li><a href="http://pl.m.wikipedia.org/wiki/Sortowanie_szybkie" lang="pl" hreflang="pl">polski</a></li><li><a href="http://pt.m.wikipedia.org/wiki/Quicksort" lang="pt" hreflang="pt">português</a></li><li><a href="http://ro.m.wikipedia.org/wiki/Quicksort" lang="ro" hreflang="ro">română</a></li><li><a href="http://ru.m.wikipedia.org/wiki/%D0%91%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0" lang="ru" hreflang="ru">русский</a></li><li><a href="http://sk.m.wikipedia.org/wiki/Quicksort" lang="sk" hreflang="sk">slovenčina</a></li><li><a href="http://sl.m.wikipedia.org/wiki/Hitro_urejanje" lang="sl" hreflang="sl">slovenščina</a></li><li><a href="http://sr.m.wikipedia.org/wiki/%D0%9A%D0%B2%D0%B8%D0%BA%D1%81%D0%BE%D1%80%D1%82" lang="sr" hreflang="sr">српски / srpski</a></li><li><a href="http://fi.m.wikipedia.org/wiki/Pikalajittelu" lang="fi" hreflang="fi">suomi</a></li><li><a href="http://sv.m.wikipedia.org/wiki/Quicksort" lang="sv" hreflang="sv">svenska</a></li><li><a href="http://tr.m.wikipedia.org/wiki/H%C4%B1zl%C4%B1_s%C4%B1ralama" lang="tr" hreflang="tr">Türkçe</a></li><li><a href="http://uk.m.wikipedia.org/wiki/%D0%A8%D0%B2%D0%B8%D0%B4%D0%BA%D0%B5_%D1%81%D0%BE%D1%80%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F" lang="uk" hreflang="uk">українська</a></li><li><a href="http://vi.m.wikipedia.org/wiki/S%E1%BA%AFp_x%E1%BA%BFp_nhanh" lang="vi" hreflang="vi">Tiếng Việt</a></li><li><a href="http://zh.m.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" lang="zh" hreflang="zh">中文</a></li></ul>
				</div>
			</div>			</div><!-- close #content_wrapper -->
			<div id="footer">
			<h2 class="section_heading" id="section_footer">
		<img src="http://bits.wikimedia.org/static-1.21wmf3/extensions/MobileFrontend/stylesheets/common/images/logo-copyright-en.png" class="license" alt="Wikipedia ®" />	</h2>
	<div class="content_block" id="content_footer">
		<ul class="settings">
			<li>
				<span class="left separator"><a id="mw-mf-display-toggle" href="http://en.wikipedia.org/w/index.php?title=Qsort&amp;mobileaction=toggle_view_desktop">Desktop</a></span><span class="right">Mobile</span>
			</li>
			<li class="notice">
				Article by <a href="http://en.m.wikipedia.org/w/index.php?title=Qsort&amp;action=history">contributors</a> like you<br>
				Content available under <a href="Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License?useformat=mobile">CC BY-SA 3.0</a>				<span>| <a href="http://wikimediafoundation.org/wiki/Terms_of_use?useformat=mobile">Terms of Use</a></span>
			</li>
		</ul>
		<ul class="links">
						<li>
			<a href='http://en.m.wikipedia.org/w/index.php?title=Special:MobileFeedback&amp;returnto=Quicksort&amp;feedbacksource=MobileFrontend'>
				Contact Wikipedia			</a>
			</li><li>
						<a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy</a></li><li>
			<a href="Wikipedia:About" title="Wikipedia:About">About</a></li><li>
			<a href="Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
		</ul>
	</div><!-- close footer.div / #content_footer -->
	</div><!-- close #footer -->
					</div><!-- close #mw-mf-page-center -->
		</div><!-- close #mw-mf-viewport -->
		
					</body>
	</html>